<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CPPLUSE</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-25T11:39:17.624Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>PSPLUSE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/54e1373e.html"/>
    <id>http://example.com/54e1373e.html</id>
    <published>2022-06-24T13:24:32.000Z</published>
    <updated>2022-06-25T11:39:17.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始Mysql数据库"><a href="#初始Mysql数据库" class="headerlink" title="初始Mysql数据库"></a>初始Mysql数据库</h2><h3 id="为什么学数据库"><a href="#为什么学数据库" class="headerlink" title="为什么学数据库"></a>为什么学数据库</h3><p>1、岗位需求</p><p>2、现在的世界，大数据时代，得数据者得天下</p><p>3、被迫需求：存数据</p><p>4、数据库是所有软件体系中最核心的存在 DBA</p><h3 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><p>数据库：(DB,DataBase)</p><p>概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万!</p><p>作用:存储数据，管理数据 Excel</p><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><p>关系型数据库：(SQL)</p><ul><li>MySQL, Oracle, sql Server, DB2, SQLite</li><li>通过表和表之间，行和列之间的关系进行数据的存储</li></ul><p>非关系型数据库：(NoSQL) Not Only SQL</p><ul><li>Redis, MongDB</li><li>非关系型数据库，对象存储，通过对象自身的属性来决定。</li></ul><p>**DBMS(数据库管理系统) **</p><ul><li>数据库的管理软件，科学有效的管理我们的数据，维护和获取</li><li>MySQL ，数据管理系统！</li></ul><h3 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h3><p>MySQL是一个<strong>关系型数据库管理系统</strong></p><p>前世： 瑞典MySQL AB 公司</p><p>今身： 属于 Oracle 旗下产品</p><p>MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p><p>开源的数据库软件</p><p>体积小，速度快，总体拥有成本低，招人成本比较低。</p><p>中小型网站，或者大型网站，集群</p><p>官网： <a href="https://www.mysql.com/">https://www.mysql.com/</a></p><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>命令行连接！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql -u root -p123456 --连接数据库</span><br><span class="line"></span><br><span class="line">update mysql.user set authentication_string=password(<span class="string">&#x27;123456&#x27;</span>) where user=<span class="string">&#x27;root&#x27;</span> and Host=<span class="string">&#x27;localhost&#x27;</span>;  --修改密码</span><br><span class="line"></span><br><span class="line">flush privileges;--刷新权限</span><br><span class="line">--------------------------------------------------</span><br><span class="line">--所有语句使用;结尾--</span><br><span class="line"></span><br><span class="line">show databases;--查看所有的数据库</span><br><span class="line"></span><br><span class="line">mysql&gt; use school--切换数据库， use 数据库名</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">show tables;--查看数据库中所有的表</span><br><span class="line">describe student;--显示数据库中所有的表的信息</span><br><span class="line">create database westos;--创建一个数据库</span><br><span class="line"></span><br><span class="line">exit;--退出连接</span><br><span class="line"></span><br><span class="line">--单行注释（sql本来注释）</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><p>操作数据库》操作数据库中的表》操作数据库中表的数据</p><p>MySQL不区分大小写</p><h3 id="操作数据库-1"><a href="#操作数据库-1" class="headerlink" title="操作数据库"></a>操作数据库</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS westos;</span><br></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS westos</span><br></pre></td></tr></table></figure><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ``,如果你的表名或者字段名是一个特殊字符，需要带``</span><br><span class="line">USE &#x27;school&#x27;</span><br></pre></td></tr></table></figure><h4 id="产看数据库"><a href="#产看数据库" class="headerlink" title="产看数据库"></a>产看数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES--查看所有数据库</span><br></pre></td></tr></table></figure><h3 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h3><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul><li><p>tinyint 十分小的数据 1个字节</p></li><li><p>smallint 较小的数据 2个字节</p></li><li><p>mediumint 中等大小 3个字节</p></li><li><p>int 标准的整数 4个字节（常用）</p></li><li><p>bigint 较大的数据 8个字节</p></li><li><p>float 浮点数 4个字节</p></li><li><p>double 浮点数 8个字节 （精度问题）</p></li><li><p>decimal 字符串形式的浮点数,金融计算的时候，一般用</p></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>char 字符串固定大小 0-255</li><li>varchar 可变字符串 0-65535（常用）</li><li>tinytext 微型文本 2^8-1</li><li>text 文本串 2^16-1 (保存大文本)</li></ul><h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4><p>java.util.Date</p><ul><li>date YYYY-MM-DD，日期</li><li>time HH:mm:ss 时间格式</li><li>datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式</li><li>timestamp 时间戳 1970.1.1到现在的毫秒数</li><li>year 年份表示</li></ul><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><ul><li>没有值，未知</li><li>注意，不要使用null进行运算，结果为null</li></ul><h3 id="数据库的字段类型（重点）"><a href="#数据库的字段类型（重点）" class="headerlink" title="数据库的字段类型（重点）"></a>数据库的字段类型（重点）</h3><h4 id="unsigened"><a href="#unsigened" class="headerlink" title="unsigened:"></a>unsigened:</h4><ul><li><p>无符号的整数</p></li><li><p>声明该列不能声明负数</p></li></ul><h4 id="zerofill"><a href="#zerofill" class="headerlink" title="zerofill:"></a>zerofill:</h4><ul><li>0填充的</li><li>10的长度 1 – 0000000001 不足位数用0 填充</li></ul><h4 id="自增："><a href="#自增：" class="headerlink" title="自增："></a>自增：</h4><ul><li>通常理解为自增，自动在上一条记录的基础上+1</li><li>通常用来设计唯一的主键 index,必须是整数类似</li><li>可以自定义设置主键自增的起始值和步长</li></ul><h4 id="非空-NULL-not-Null"><a href="#非空-NULL-not-Null" class="headerlink" title="非空 NULL not Null"></a>非空 NULL not Null</h4><ul><li><p>假设设置为 not null，如何不给他赋值，就会报错</p></li><li><p>NULL 如果不填写，默认为NULL</p></li></ul><h4 id="默认："><a href="#默认：" class="headerlink" title="默认："></a>默认：</h4><ul><li>设置默认的值！</li></ul><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--目标:创建一个schoo1数据库</span><br><span class="line"></span><br><span class="line">--创建学生表(列,字段)使用SQL 创建</span><br><span class="line"></span><br><span class="line">--学号int 登录密码varchar(20)姓名,性别varchar(2),出生日期(datatime)，家庭住址，emai1--注意点，使用英文()，表的名称和字段尽量使用括起来</span><br><span class="line"></span><br><span class="line">-- AUTO_ INCREMENT 自增</span><br><span class="line"></span><br><span class="line">--字符串使用单引号括起来!</span><br><span class="line"></span><br><span class="line">--所有的语句后面加，(英文的)，最后一个不用加</span><br><span class="line"></span><br><span class="line">-- PRIMARY KEY 主键，一般- 一个表只有一个唯一 -的主键!</span><br><span class="line">CREATE DATABASE school</span><br><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,</span><br><span class="line">`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,</span><br><span class="line">`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] `表名`（</span><br><span class="line">`字段名` 列类型[属性][索引][注释],</span><br><span class="line">`字段名` 列类型[属性][索引][注释],</span><br><span class="line">...</span><br><span class="line">`字段名` 列类型[属性][索引][注释]</span><br><span class="line">）[表类型][表的字符集设置][注释]</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE DATABASE school -- 查看创建数据库的语句</span><br><span class="line">SHOW CREATE TABLE student -- 查看student数据表的定义语句</span><br><span class="line">DESC student -- 显示表的结构</span><br></pre></td></tr></table></figure><h3 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 关于数据库引擎</span><br><span class="line">/*</span><br><span class="line">INNODB 默认使用</span><br><span class="line">MYISAM 早些年使用</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>​    </p><table><thead><tr><th align="center"></th><th align="center">MYISAM</th><th align="center">INNODB</th></tr></thead><tbody><tr><td align="center">事务支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">数据行锁定</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">外键约束</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">表空间的大小</td><td align="center">较小</td><td align="center">较大，约为MYISAM的两倍</td></tr></tbody></table><p>常规使用操作：</p><ul><li>MYISAM 节约空间，速度较快，</li><li>INNODB 安全性高，事务处理，多表多用户操作</li></ul><h4 id="在物理空间存在的位置"><a href="#在物理空间存在的位置" class="headerlink" title="在物理空间存在的位置"></a>在物理空间存在的位置</h4><p>所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库</p><p>本质还是文件的存储</p><p>MySQL 引擎在物理文件上的区别</p><ul><li>innoDB 在数据库表中，只有一个*.frm文件，以及上级目录下的ibdata1文件</li><li>MYISAM 对应的文件<ul><li>*.frm - 表结构的定义文件</li><li>*. MYD -数据文件</li><li>*.MYI 索引文件</li></ul></li></ul><h4 id="设置数据库字符集编码"><a href="#设置数据库字符集编码" class="headerlink" title="设置数据库字符集编码"></a>设置数据库字符集编码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHARTSET=UTF8</span><br></pre></td></tr></table></figure><p>不设置的话，会是mysql默认的字符集编码-（不支持中文）</p><p>可以在my.ini中配置默认的编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure><h3 id="修改删除表"><a href="#修改删除表" class="headerlink" title="修改删除表"></a>修改删除表</h3><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改表名 ALTER TABLE 旧表面 AS 新表名</span><br><span class="line">ALTER TABLE student RENAME  AS student1</span><br><span class="line">-- 增加表的字段 ALTER TABLE 表名 ADD 字段名 列属性</span><br><span class="line">ALTER TABLE student1 ADD age INT(11)</span><br><span class="line">-- 修改表的字段（重命名，修改约束）</span><br><span class="line">ALTER TABLE student1 MODIFY age VARCHAR(11)  -- 修改约束</span><br><span class="line">ALTER TABLE student1 CHANGE age age1 INT(1)  -- 字段重命名</span><br><span class="line"></span><br><span class="line">-- 删除表的字段</span><br><span class="line">ALTER TABLE student1 DROP age1</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除表</span><br><span class="line">DROP TABLE IF EXISTS student1</span><br></pre></td></tr></table></figure><p>所有的创建和删除操作尽量加上判断，以免报错</p><p>注意点：</p><ul><li>`` 字段名，使用这个包裹</li><li>注释 – /**/</li><li>sql 关键字大小写不敏感，建议写小写</li><li>所有的符号全部用英文</li></ul><h2 id="MySQL数据管理"><a href="#MySQL数据管理" class="headerlink" title="MySQL数据管理"></a>MySQL数据管理</h2><h3 id="外键（了解）"><a href="#外键（了解）" class="headerlink" title="外键（了解）"></a>外键（了解）</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>在创建表的时候，增加约束（麻烦，比较复杂）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `grade`(</span><br><span class="line">`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;,</span><br><span class="line">`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,</span><br><span class="line">PRIMARY KEY (`gradeid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">-- 学生表的 gradeid 字段 要去引用年级表的gradeid</span><br><span class="line">-- 定义外键KEY</span><br><span class="line">-- 给这个外键添加约束（执行引用） references 引用</span><br><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,</span><br><span class="line">`gradeid` INT(10) NOT NULL COMMENT &#x27;学生年级&#x27;,</span><br><span class="line">`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,</span><br><span class="line">`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `FK_gardeid` (`gradeid`),</span><br><span class="line">CONSTRAINT `FK_gardeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (gradeid)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><p>删除有外键关系的表的时候，必须先删除引用的表（从表），再删除被引用的表（主表）</p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>创建表成功后添加外键</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `grade`(</span><br><span class="line">`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;,</span><br><span class="line">`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,</span><br><span class="line">PRIMARY KEY (`gradeid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">-- 学生表的 gradeid 字段 要去引用年级表的gradeid</span><br><span class="line">-- 定义外键KEY</span><br><span class="line">-- 给这个外键添加约束（执行引用） references 引用</span><br><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,</span><br><span class="line">`gradeid` INT(10) NOT NULL COMMENT &#x27;学生年级&#x27;,</span><br><span class="line">`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,</span><br><span class="line">`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line"></span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">-- 创建表的时候没有外键关系</span><br><span class="line">ALTER TABLE `student`</span><br><span class="line">ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`);</span><br><span class="line"></span><br><span class="line">-- ALTER TABLE`表`  ADD CONSTRAINT 约束名 FOREIGN KEY（作为外键的列） 引用到哪个表的哪个字段</span><br></pre></td></tr></table></figure><p>以上的操作都是物理外键，数据库级别外键，不建议使用。（避免数据库过多造成困扰）</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）</li><li>我们想使用多张表的数据，想使用外键（程序去实现）</li></ul><h3 id="DML语言（全记住）"><a href="#DML语言（全记住）" class="headerlink" title="DML语言（全记住）"></a>DML语言（全记住）</h3><p>数据库意义：数据存储，数据管理</p><p>DML语言：数据操作语言</p><ul><li>Insert</li><li>update</li><li>delete</li></ul><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 插入语句（添加）</span><br><span class="line">-- nsert into 表名（[字段一], [字段二]）values(&#x27;值1&#x27;),(&#x27;值2&#x27;)</span><br><span class="line"></span><br><span class="line">INSERT INTO `grade` (`gradename`) VALUES(&#x27;大四&#x27;)</span><br><span class="line"></span><br><span class="line">-- 由于主键自增我们可以省略（如何不写表的字段，他会一一匹配）</span><br><span class="line">INSERT INTO `grade` VALUES(&#x27;大三&#x27;)</span><br><span class="line">INSERT INTO `grade` (`gradeid`,`gradename`) VALUES (&#x27;大三&#x27;,&#x27;null&#x27;)</span><br><span class="line"></span><br><span class="line">-- 一般写插入语句，我们一定要数据和字段一一对应。</span><br><span class="line">-- 插入多个字段</span><br><span class="line">INSERT INTO `grade`(`gradename`) VALUES (&#x27;大二&#x27;),(&#x27;大一&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `student`(`name`) VALUES (&#x27;张三&#x27;)</span><br><span class="line"></span><br><span class="line">INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES (&#x27;张三&#x27;,&#x27;aaaaa&#x27;,&#x27;男&#x27;)</span><br><span class="line">INSERT INTO `student`(`name`,`pwd`,`sex`) </span><br><span class="line">VALUES (&#x27;李四&#x27;,&#x27;aaaaa&#x27;,&#x27;男&#x27;),(&#x27;王五&#x27;,&#x27;23232&#x27;,&#x27;女&#x27;)</span><br></pre></td></tr></table></figure><p>语法：– insert into 表名（[字段一], [字段二]）values(‘值1’),(‘值2’)</p><p>注意事项：</p><p>1.字段和字段之间用逗号分开</p><p>2.字段可以省略，但是后面的值必须一一对应</p><p>3.可以同时插入多条数据，VALUES后面的值需要使用，隔开即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO `student`(`name`,`pwd`,`sex`) </span><br><span class="line">VALUES (&#x27;李四&#x27;,&#x27;aaaaa&#x27;,&#x27;男&#x27;),(&#x27;王五&#x27;,&#x27;23232&#x27;,&#x27;女&#x27;)</span><br></pre></td></tr></table></figure><h3 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h3><h4 id="update-修改谁（条件）-set-原来的值-新值"><a href="#update-修改谁（条件）-set-原来的值-新值" class="headerlink" title="update 修改谁（条件） set 原来的值=新值"></a>update 修改谁（条件） set 原来的值=新值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改学员名字</span><br><span class="line"></span><br><span class="line">UPDATE `student` SET `name`=&#x27;囷&#x27; WHERE id =1;</span><br><span class="line">-- 不指定条件的情况下，会改动所有表</span><br><span class="line">UPDATE `student` SET `name`=&#x27;233&#x27;</span><br><span class="line"></span><br><span class="line">-- 语法；</span><br><span class="line">-- UPDATE 表名 set column_name,[] = value where 条件</span><br></pre></td></tr></table></figure><p>条件：where 子句 运算符 id 等于 某个值，大于某个值，在某个区间内修改</p><p>操作符返回布尔值</p><table><thead><tr><th align="center"><strong>操作符</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>范围</strong></th><th align="center"><strong>结果</strong></th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td><td align="center">5=6</td><td align="center">false</td></tr><tr><td align="center">!= &lt;&gt;</td><td align="center">不等于</td><td align="center">5！=6</td><td align="center">true</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">&gt;=</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">&lt;=</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">between and</td><td align="center">在某个范围内，闭合区间</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">and</td><td align="center">&amp;&amp;</td><td align="center">5&gt;1and1&gt;2</td><td align="center">false</td></tr><tr><td align="center">or</td><td align="center">||</td><td align="center">5&gt;1or1&gt;2</td><td align="center">true</td></tr></tbody></table><p>注意：</p><ul><li><p>column_name 是数据库的列，带上``</p></li><li><p>条件，是筛选的条件，如果没有指定，则会修改所有的列</p></li><li><p>value 是一个具体的值，也可以是一个变量</p></li><li><p>多个设置的属性之间，使用英文逗号隔开</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `student` SET `birthday`=CURRENT_TIME where `name`=&#x27;李四&#x27; AND SEX = &#x27;男&#x27;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h4><p>语法 <code>delete from 表名 [where 条件]</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除数据 (避免这样写)</span><br><span class="line">DELETE FROM `student`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 删除指定</span><br><span class="line">DELETE FROM `student` where id= 1</span><br></pre></td></tr></table></figure><h4 id="TRUNCATE-命令"><a href="#TRUNCATE-命令" class="headerlink" title="TRUNCATE 命令"></a>TRUNCATE 命令</h4><p>作用：完全清空一个数据库，表的结构和索引不会变</p><h4 id="delete-和-TRUNCATE-区别"><a href="#delete-和-TRUNCATE-区别" class="headerlink" title="delete 和 TRUNCATE 区别"></a>delete 和 TRUNCATE 区别</h4><ul><li>相同点： 都能删除数据，都不会删除表结构</li><li>不同：<ul><li>TRUNCATE 重新设置自增列 计数器会归零</li><li>TRUNCATE 不会影响事务</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 测试delete 和 truncate 区别</span><br><span class="line"></span><br><span class="line">CREATE TABLE `test`(</span><br><span class="line">`id` INT(4) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`coll` VARCHAR(20) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO `test`(`coll`) VALUES(&#x27;1&#x27;),(&#x27;2&#x27;),(&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">DELETE FROM `test` -- 不会影响自增</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE `test` -- 自增会归零</span><br></pre></td></tr></table></figure><p>了解即可：<code>delete删除的问题</code> 重启数据库，现象</p><ul><li>innoDB 自增列会从1开始（存在内存当中，断电即失）</li><li>MyISAM 继续从上一个自增量开始（存在文件中，不会丢失）</li></ul><h2 id="DQL查询数据（最重点）"><a href="#DQL查询数据（最重点）" class="headerlink" title="DQL查询数据（最重点）"></a>DQL查询数据（最重点）</h2><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>(Data Query Language) :数据查询语言</p><ul><li>所有的查询操作都用它 Select</li><li>简单的查询，复杂的查询它都能做</li><li>数据库中最核心的语言</li><li>使用频率最高的语言</li></ul><h3 id="指定查询字段"><a href="#指定查询字段" class="headerlink" title="指定查询字段"></a>指定查询字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询  SELECT 字段 FROM 表</span><br><span class="line"></span><br><span class="line">-- 查询指定字段  such as</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM student</span><br><span class="line"></span><br><span class="line">-- 别名，给结果起一个名字 AS   可以给字段起别名 也可以给表起别名</span><br><span class="line">SELECT `StudentNo` AS 学号,`StudentName`AS 学生姓名 FROM student AS S</span><br><span class="line"></span><br><span class="line">-- 函数 Concat(a,b)</span><br><span class="line">SELECT CONCAT(&#x27;姓名：&#x27;,StudentName) AS 新名字 FROM student</span><br></pre></td></tr></table></figure><p>语法： <code>SELECT 字段 ... FROM 表</code></p><p>有时候，列名字不是那么见名知意。我们起别名 AS 字段名 AS 别名 表名 AS 别名</p><p>去重</p><p>作用：去除select语句查询出来的结果中重复的语句，重复的语句只显示一条</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询一下有哪些同学参加了考试，成绩</span><br><span class="line">SELECT * FROM result -- 查询全部的考试成绩</span><br><span class="line">-- 查询有哪些同学参加了考试</span><br><span class="line">SELECT `studentNo` FROM result </span><br><span class="line">-- 发现重复数据，去重</span><br><span class="line">SELECT DISTINCT `studentNo` FROM result </span><br></pre></td></tr></table></figure><p>数据库的列（表达式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT VERSION()  --查询系统版本（函数）</span><br><span class="line">SELECT 100*3-1 AS 计算结果 -- 用来计算（表达式）</span><br><span class="line">SELECT @@auto_increment_increment --查询自增的步长（变量）</span><br><span class="line"></span><br><span class="line">-- 学员考试成绩+1 分 查看</span><br><span class="line">SELECT `StudentNo`,`StudentResult`+1 AS &#x27;提分后&#x27; FROM result</span><br></pre></td></tr></table></figure><p>数据库中的表达式： 文本值，列，Null , 函数，计算表达式，系统变量…</p><p>select 表达式 from 表</p><h3 id="where-条件子句"><a href="#where-条件子句" class="headerlink" title="where 条件子句"></a>where 条件子句</h3><p>作用：检索数据中符合条件的值</p><p>逻辑运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">语法</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">and &amp;&amp;</td><td align="center">a and b a&amp;&amp;b</td><td align="center">逻辑与</td></tr><tr><td align="center">or ||</td><td align="center">a or b a</td><td align="center">逻辑或</td></tr><tr><td align="center">Not !=</td><td align="center">not a !a</td><td align="center">逻辑非</td></tr></tbody></table><p>尽量使用英文</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询考试成绩在95分到100分之间</span><br><span class="line">SELECT `StduentNo`,`StudentResult` FROM result</span><br><span class="line">WHERE StudentResult &gt;=95 AND StudentResult&lt;=100</span><br><span class="line"></span><br><span class="line">-- 模糊查询（区间）</span><br><span class="line">SELECT `StduentNo`,`StudentResult` FROM result</span><br><span class="line">WHERE StudentResult BETWEEN 95 AND 100</span><br><span class="line"></span><br><span class="line">-- 除了1000号学生之外的同学成绩</span><br><span class="line">SELECT `StduentNo`,`StudentResult` FROM result</span><br><span class="line">WHERE NOT StudentNo = 1000</span><br></pre></td></tr></table></figure><p>模糊查询：比较运算符</p><table><thead><tr><th align="center"><strong>运算符</strong></th><th align="center"><strong>语法</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">I S NULL</td><td align="center">a is null</td><td align="center">如果操作符为null 结果为真</td></tr><tr><td align="center">IS NOT NULL</td><td align="center">a is not null</td><td align="center">如果操作符为not null 结果为真</td></tr><tr><td align="center">BETWEEN</td><td align="center">a between b and c</td><td align="center">若a在b 和c之间则为真</td></tr><tr><td align="center"><strong>LIKE</strong></td><td align="center">a like b</td><td align="center">SQL匹配，如果a 匹配到b 则为真</td></tr><tr><td align="center"><strong>IN</strong></td><td align="center">a in (a1,a2,a3…)</td><td align="center">假设a 在 a1,a2,a3其中的某一个中，为真</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--  查询姓刘的同学</span><br><span class="line">-- like结合 %（代表0到任意字符）  _(一个字符)</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentName LIKE &#x27;刘%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询姓刘的同学，名字后只有一个字</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentName LIKE &#x27;刘_&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询姓刘的同学，名字后只有两个字</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentName LIKE &#x27;刘__&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名字中间有嘉字的同学 %嘉%</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentName LIKE &#x27;%嘉%&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===================IN(具体的一个或者多个值)===========================</span><br><span class="line">-- 查询1001 1002 1003 学员信息</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentNo = 1001</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentNo = 1002</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentNo = 1003</span><br><span class="line"></span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE StudentNo IN (1001,1002,1003);</span><br><span class="line"></span><br><span class="line">-- 查询在北京的学生</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE `Address` IN(&#x27;安徽&#x27;,&#x27;河南洛阳&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===================NULL NOT NULL===================================</span><br><span class="line">-- 查询地址为空的学生 null &#x27;&#x27;</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE address=&#x27;&#x27;OR address IS NULL</span><br><span class="line"></span><br><span class="line">-- 查询有出生日期的同学  不为空</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM `student`</span><br><span class="line">WHERE `BornDate` IS NOT NULL;</span><br></pre></td></tr></table></figure><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><h4 id="JOIN-对比"><a href="#JOIN-对比" class="headerlink" title="JOIN 对比"></a>JOIN 对比</h4><p><img src="https://img-blog.csdnimg.cn/20200708013553742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200708013558863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======================联表查询 join ==============================</span><br><span class="line">-- 查询参加考试的同学 （学号，姓名，考试编号，分数）</span><br><span class="line"></span><br><span class="line">SELECT * FROM student </span><br><span class="line">SELECT * FROM result</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">1. 分析需求，分析查询的字段来自哪些表</span><br><span class="line">   2.确定使用哪种连接查询？7种</span><br><span class="line">   确定交叉点（这两个表中哪个数据是相同的）</span><br><span class="line">   判断的条件： 学生表中 studentNo = 成绩表中 studentNo </span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- JION（表） ON （判断的条件）连接查询</span><br><span class="line">-- where 等值查询</span><br><span class="line">SELECT studentNo,studentName,SubjectNo,StudentResult</span><br><span class="line">FROM student AS s</span><br><span class="line">INNER JOIN result AS r</span><br><span class="line">WHERE s.studentNo=r.studentNo</span><br><span class="line"></span><br><span class="line">--Right Join</span><br><span class="line">SELECT s.studentNo,studentName,SubjectNo,StudentResult</span><br><span class="line">FROM student AS s</span><br><span class="line">RIGHT JOIN result AS r</span><br><span class="line">ON s.studentNo = r.studentNo</span><br><span class="line"></span><br><span class="line">--LEFT Join</span><br><span class="line">SELECT s.studentNo,studentName,SubjectNo,StudentResult</span><br><span class="line">FROM student AS s</span><br><span class="line">LEFT JOIN result AS r</span><br><span class="line">ON s.studentNo = r.studentNo</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>操作</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">Inner join</td><td align="center">如果表中至少有一个匹配，就返回行</td></tr><tr><td align="center">left join</td><td align="center">即使左表中没有匹配，也会从左表中返回所有的值</td></tr><tr><td align="center">right jion</td><td align="center">即使右表中没有匹配，也会从右表中返回所有的值</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询考的同学</span><br><span class="line">SELECT s.studentNo,studentName,SubjectNo,StudentResult</span><br><span class="line">FROM student AS s</span><br><span class="line">LEFT JOIN result AS r</span><br><span class="line">ON s.studentNo = r.studentNo</span><br><span class="line">WHERE StudentResult IS NULL</span><br><span class="line"></span><br><span class="line">-- 查询了参加考试同学的信息：学号：学生姓名：科目名：分数</span><br><span class="line">SELECT s.`studentNo`,`studentName`,`SubjectName`,`studentResult`</span><br><span class="line">FROM student s</span><br><span class="line">RIGHT JOIN result r</span><br><span class="line">ON r.studentNo=s.studentNo</span><br><span class="line">INNER JOIN `subject` sub</span><br><span class="line">ON r.SubjectNo=sub.SubjectNo</span><br><span class="line"></span><br><span class="line">-- 我要查询哪些数据 SELECT ....</span><br><span class="line">-- 从哪几个表中查 FROM 表 xxx JOIN 连接的表 ON 交叉条件</span><br><span class="line">-- 假设存在一中多张表查询，先查询两章表，然后再慢慢增加</span><br><span class="line"></span><br><span class="line">--FROM a LEFT JOIN b   左为准</span><br><span class="line">--FROM a RIGHT JOIN b右为准</span><br></pre></td></tr></table></figure><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>自己的表跟自己的表连接，核心：一张表拆为两张一样的表</p><p>父类</p><table><thead><tr><th align="center"><strong>categoryid</strong></th><th align="center"><strong>categoryName</strong></th></tr></thead><tbody><tr><td align="center">2</td><td align="center">信息技术</td></tr><tr><td align="center">3</td><td align="center">信息技术</td></tr><tr><td align="center">5</td><td align="center">信息技术</td></tr></tbody></table><p>子类</p><table><thead><tr><th><strong>pid</strong></th><th><strong>categoryid</strong></th><th><strong>categoryName</strong></th></tr></thead><tbody><tr><td>3</td><td>4</td><td>数据库</td></tr><tr><td>2</td><td>8</td><td>办公信息</td></tr><tr><td>3</td><td>6</td><td>web开发</td></tr><tr><td>5</td><td>7</td><td>ps技术</td></tr></tbody></table><p>操作：查询父类对应子类关系</p><p>父类    子类</p><table><thead><tr><th><strong>父类</strong></th><th><strong>子类</strong></th></tr></thead><tbody><tr><td>信息技术</td><td>办公信息</td></tr><tr><td>软件开发</td><td>数据库</td></tr><tr><td>软件开发</td><td>web开发</td></tr><tr><td>美术设计</td><td>ps技术</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询父子信息</span><br><span class="line"></span><br><span class="line">SELECT a.`categroryName` AS `父栏目`,b.`categroryName` AS `子栏目`</span><br><span class="line">FROM `catgroy` AS a,`catgroy` AS b</span><br><span class="line">WHERE a.`categoryid`=b.`pid`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询学员所属的年级（学号，学生的姓名，年级）</span><br><span class="line">SELECT studentNo,studentName,gradeName</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN `grade` g</span><br><span class="line">ON s.`GradeId`=g.`GradeId`</span><br></pre></td></tr></table></figure><h3 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">============================分页 limit 和排序order by=================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 排序：  升序ASC  降序  DESC</span><br><span class="line">SELECT  xx</span><br><span class="line">FROM xx</span><br><span class="line">JOIN xx</span><br><span class="line">WHERE  xx</span><br><span class="line">ORDER BY  xx</span><br><span class="line">ASC   ||  DESC</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 为什么要分页</span><br><span class="line">-- 缓解数据库压力，给人的体验更好</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 分页，每页显示五条数据</span><br><span class="line"></span><br><span class="line">-- 语法： limit 当前页，页面的大小</span><br><span class="line">-- limit 0,5 1-5</span><br><span class="line">-- limit 1,5 1-5</span><br><span class="line">-- limit 6,5</span><br><span class="line">SELECT s.`StudentNo`,`StudentName`,`SubjectName`,`StudentResult`</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN `result` r</span><br><span class="line">ON s.`StudentNo`=r.`StudentNo`</span><br><span class="line">INNER JOIN `subject` sub</span><br><span class="line">ON r.`subjectNo`=sub.`subjectNo`</span><br><span class="line">WHERE subjectName=&#x27;数据结构-1&#x27;</span><br><span class="line">ORDER BY StudentResult ASC</span><br><span class="line">LIMIT 0,5</span><br><span class="line"></span><br><span class="line">-- 第一页 limit 0,5</span><br><span class="line">-- 第二页 limit 5,5</span><br><span class="line">-- 第三页 limit 10,5</span><br><span class="line">-- 第N页 limit 5*（n-1）,5</span><br></pre></td></tr></table></figure><p>语法 <code>limit(查询起始下标，pagesize)</code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>where (这个值是计算出来的)</p><p>本质：<code>在where语句中嵌套一个子查询语句</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ===========================where=========================</span><br><span class="line"></span><br><span class="line">-- 1.查询 数据库结构-1的所有考试结构（学号，科目编号，成绩） 降序</span><br><span class="line">-- 方式一： 连接查询</span><br><span class="line">SELECT `StudentNo`,r.`SubjectName`,`StudentResult`</span><br><span class="line">FROM `result` r</span><br><span class="line">INNER JOIN `subject` sub</span><br><span class="line">ON r.SubjectNo = sun.SubjectNo</span><br><span class="line">WHERE subjectName = &#x27;数据库结构-1&#x27;</span><br><span class="line">ORDER BY StudentResult DESC</span><br><span class="line"></span><br><span class="line">-- 方式二：使用子查询(由里及外)</span><br><span class="line">SELECT `StudentNo`,r.`SubjectName`,`StudentResult`</span><br><span class="line">FROM `result`</span><br><span class="line">WHERE StudentNo=(</span><br><span class="line">SELECT SubjectNo FROM  `subject` </span><br><span class="line">    WHERE SubjectName = &#x27;数据库结构-1&#x27;</span><br><span class="line">)</span><br><span class="line">ORDER BY StudentResult DESC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 分数不少于80分的学生的学号和姓名</span><br><span class="line">SELECT DISTINCT s.`StudentNo`,`StudentName`</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN result r</span><br><span class="line">ON r.StudentNo = s.StudentNo</span><br><span class="line">WHERE StudentResult&gt;=80</span><br><span class="line"></span><br><span class="line">-- 在这个基础上 增加一个科目 ，高等数学-2</span><br><span class="line">SELECT DISTINCT s.`StudentNo`,`StudentName`</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN result r</span><br><span class="line">ON r.StudentNo = s.StudentNo</span><br><span class="line">WHERE StudentResult&gt;=80 AND `SubjectNo`=(</span><br><span class="line">    SELECT Subject FROM `subject`</span><br><span class="line">    WHERE SubjectName=&#x27;高等数学-2&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 查询课程为 高等数学-2 且分数不小于80分的同学的学号和姓名</span><br><span class="line">SELECT s.`StudentNo`,`StudentName`</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN result r</span><br><span class="line">ON s.StudentNo = r.StudentNo</span><br><span class="line">INNER JOIN `subject` sub</span><br><span class="line">ON r.`SubjectName`=&#x27;高等数学-2&#x27;</span><br><span class="line">WHERE `SubjectaName`=&#x27;高等数学-2&#x27; AND StudentResult &gt;=80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 再改造 (由里即外)</span><br><span class="line">SELECT `StudentNo`,`StudentName` FROM student</span><br><span class="line">WHERE StudentNo IN(</span><br><span class="line">SELECT StudentNo result WHERE StudentResult &gt;80 AND SubjectNo =(</span><br><span class="line">SELECT SubjectNo FROM `subject` WHERE `SubjectaName`=&#x27;高等数学-2&#x27;</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询不同课程的平均分，最高分，最低分，平均分大于80</span><br><span class="line">-- 核心：（根据不同的课程分组）</span><br><span class="line"></span><br><span class="line">SELECT `SubjectName`,AVG(StudentResult),MAX(StudentResult)</span><br><span class="line">FROM result r</span><br><span class="line">INNER JOIN `Subject` sub</span><br><span class="line">ON r.SubjectNo=sub.SubjectNo</span><br><span class="line"></span><br><span class="line">GROUP BY r.SubjectNo -- 通过什么字段来分组</span><br><span class="line">HAVING AVG(StudentResult)&gt;80</span><br></pre></td></tr></table></figure><h2 id="MySQL函数"><a href="#MySQL函数" class="headerlink" title="MySQL函数"></a>MySQL函数</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数学运算</span><br><span class="line"></span><br><span class="line">SELECT ABS(-8) -- 绝对值</span><br><span class="line">SELECT CEILING(9.4) -- 向上取整</span><br><span class="line">SELECT FLOOR(9.4)  -- 向下取整</span><br><span class="line">SELECT RAND() -- 返回0-1随机数</span><br><span class="line">SELECT SIGN(-10) -- 判断一个数的符号 0-0 负数返回-1 正数返回1</span><br><span class="line"></span><br><span class="line">-- 字符串函数</span><br><span class="line">SELECT CHAR_LENGTH(&#x27;2323232&#x27;) -- 返回字符串长度</span><br><span class="line">SELECT CONCAT(&#x27;我&#x27;,&#x27;233&#x27;) -- 拼接字符串</span><br><span class="line">SELECT INSERT(&#x27;java&#x27;,1,2,&#x27;cccc&#x27;) -- 从某个位置开始替换某个长度</span><br><span class="line">SELECT UPPER(&#x27;abc&#x27;) </span><br><span class="line">SELECT LOWER(&#x27;ABC&#x27;)</span><br><span class="line">SELECT REPLACE(&#x27;坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;)</span><br><span class="line"></span><br><span class="line">-- 查询姓 周 的同学 ，改成邹</span><br><span class="line">SELECT REPLACE(studentname,&#x27;周&#x27;,&#x27;邹&#x27;) FROM student</span><br><span class="line">WHERE studentname LIKE &#x27;周%&#x27;</span><br><span class="line"></span><br><span class="line">-- 时间跟日期函数（记住）</span><br><span class="line">SELECT CURRENT_DATE() -- 获取当前日期</span><br><span class="line">SELECT CURDATE() -- 获取当前日期</span><br><span class="line">SELECT NOW() -- 获取当前日期</span><br><span class="line">SELECT LOCATIME()  -- 本地时间</span><br><span class="line">SELECT SYSDATE()  -- 系统时间</span><br><span class="line"></span><br><span class="line">SELECT YEAR(NOW())</span><br><span class="line">SELECT MONTH(NOW())</span><br><span class="line">SELECT DAY(NOW())</span><br><span class="line">SELECT HOUR(NOW())</span><br><span class="line">SELECT MINUTE(NOW())</span><br><span class="line">SELECT SECOND(NOW())</span><br><span class="line"></span><br><span class="line">-- 系统</span><br><span class="line">SELECT SYSTEM_USER()</span><br><span class="line">SELECT USER()</span><br><span class="line">SELECT VERSION()</span><br></pre></td></tr></table></figure><h3 id="聚合函数（常用）"><a href="#聚合函数（常用）" class="headerlink" title="聚合函数（常用）"></a>聚合函数（常用）</h3><table><thead><tr><th align="center"><strong>函数名称</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><strong>COUNT()</strong></td><td align="center">计数</td></tr><tr><td align="center">SUM()</td><td align="center">求和</td></tr><tr><td align="center">AVG()</td><td align="center">平均值</td></tr><tr><td align="center">MAX()</td><td align="center">最大值</td></tr><tr><td align="center">MIN()</td><td align="center">最小值</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><h3 id="数据库级别MD5加密（拓展）"><a href="#数据库级别MD5加密（拓展）" class="headerlink" title="数据库级别MD5加密（拓展）"></a>数据库级别MD5加密（拓展）</h3><p>什么是MD5</p><p>主要增强算法复杂度不可逆性。</p><p>MD5不可逆，具体的MD5是一样的</p><p>MD5破解原理，背后有一个字典，MD5加密后的值，加密前的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `testmd5`(</span><br><span class="line">`id` INT(4) NOT NULL,</span><br><span class="line">`name` VARCHAR(20) NOT NULL,</span><br><span class="line">`pwd` VARCHAR(50) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line"></span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=UTF8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 明文密码</span><br><span class="line">INSERT INTO testmd5 VALUES(1,&#x27;张三&#x27;,&#x27;123456&#x27;),(2,&#x27;李四&#x27;,&#x27;123456&#x27;),(3,&#x27;王五&#x27;,&#x27;123456&#x27;)</span><br><span class="line"></span><br><span class="line">-- 加密</span><br><span class="line">UPDATE testmd5 SET pwd=MD5(pwd) WHERE id =1</span><br><span class="line">UPDATE testmd5 SET pwd=MD5(pwd) WHERE id !=1  -- 加密全部</span><br><span class="line"></span><br><span class="line">-- 插入时加密</span><br><span class="line"></span><br><span class="line">INSERT INTO testmd5 VALUES(4,&#x27;小明&#x27;,MD5(&#x27;123456&#x27;))</span><br><span class="line">INSERT INTO testmd5 VALUES(5,&#x27;红&#x27;,MD5(&#x27;123456&#x27;))</span><br><span class="line"></span><br><span class="line">-- 如何校验，将用户传递过来的密码，进行MD5加密，然后对比加密后的值</span><br><span class="line">SELECT * FROM testmd5 WHERE `name`=&#x27;红&#x27; AND pwd=MD5(&#x27;123456&#x27;)</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>要么都成功，要么都失败</p><hr><p>SQL执行， A给B转账 A 1000–&gt; 200 B200<br>SQL 执行， B收到A的钱 A800 — B400</p><hr><p>将一组SQL放在一个批次中执行</p><h4 id="事务原则-："><a href="#事务原则-：" class="headerlink" title="事务原则 ："></a>事务原则 ：</h4><p>ACID原则 原子性，一致性，隔离性，持久性 （脏读，幻读…）</p><p>原子性（Atomicity）</p><p>要么都成功，要么都失败</p><p>一致性（Consistency）</p><p>事务前后的数据完整性要保持一致</p><p>持久性（Durability）–事务提交</p><p>事务一旦提交就不可逆转，被持久化到数据库中</p><p>隔离性</p><p>事务产生多并发时，互不干扰</p><h4 id="隔离产生的问题"><a href="#隔离产生的问题" class="headerlink" title="隔离产生的问题"></a>隔离产生的问题</h4><p>脏读：<br>指一个事务读取了另外一个事务未提交的数据。</p><p>不可重复读：<br>在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对）</p><p>虚读(幻读)<br>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。<br>（一般是行影响，多了一行）</p><h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mysql 自动开启事务提交</span><br><span class="line">SET autocommit=0 -- 关闭</span><br><span class="line">SET autocommit=1 -- 开启（默认的）</span><br><span class="line"></span><br><span class="line">-- 手动处理事务</span><br><span class="line">SET autocommit =0 -- 关闭自动提交</span><br><span class="line"></span><br><span class="line">-- 事务开启</span><br><span class="line"></span><br><span class="line">START TRANSACTION -- 标记一个事务的开始，从这个之后的SQP都在同一个事务内</span><br><span class="line"></span><br><span class="line">INSERT XX</span><br><span class="line">INSERT XX</span><br><span class="line"></span><br><span class="line">-- 提交 ： 持久化(成功)</span><br><span class="line">COMMIT </span><br><span class="line">-- 回滚：  回到原来的样子（失败）</span><br><span class="line">ROLLBACK</span><br><span class="line">-- 事务结束</span><br><span class="line">SET autocommit = 1 -- 开启自动提交</span><br><span class="line">-- 了解</span><br><span class="line">SAVEPOINT 保存点名称 -- 设置一个事务的保存点</span><br><span class="line">ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点 -- 删除保存点</span><br></pre></td></tr></table></figure><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci</span><br><span class="line">USE shop</span><br><span class="line">CREATE TABLE `account`(</span><br><span class="line">`id` INT(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(30) NOT NULL,</span><br><span class="line">`money` DECIMAL(9,2) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO account(`name`,`money`)</span><br><span class="line">VALUES(&#x27;A&#x27;,2000),(&#x27;B&#x27;,10000)</span><br><span class="line"></span><br><span class="line">-- 模拟转账：事务</span><br><span class="line">SET autocommit = 0; -- 关闭自动提交</span><br><span class="line">START TRANSACTION -- 开启事务（一组事务）</span><br><span class="line">UPDATE account SET money = money-500 WHERE `name` = &#x27;A&#x27; -- A 转账给B</span><br><span class="line">UPDATE account SET money = money+500 WHERE `name` = &#x27;B&#x27; -- B 收到钱</span><br><span class="line"></span><br><span class="line">COMMIT ; -- 提交事务</span><br><span class="line">ROLLBACK ; -- 回滚</span><br><span class="line"></span><br><span class="line">SET autocommit=1 -- 恢复默认值</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>在一个表中，主键索引只能有一个，唯一索引可以有多个</p><ul><li>主键索引 （PRIMARY KEY）<ul><li>唯一的标识，主键不可重复，只能有一个列作为主键</li></ul></li><li>唯一索引 （UNIQUE KEY）<ul><li>避免重复的列出现，唯一索引可以重复，多个列都可以标识唯一索引</li></ul></li><li>常规索引（KEY/INDEX）<ul><li>默认的，index,key关键字来设置</li></ul></li><li>全文索引（FULLTEXT）<ul><li>在特点的数据库引擎下才有，MyISAM</li><li>快速定位数据</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 索引的使用</span><br><span class="line">-- 1.在创建表的时候给字段增加索引</span><br><span class="line">-- 2.创建完毕后，增加索引</span><br><span class="line"></span><br><span class="line">-- 显示所有的索引信息</span><br><span class="line">SHOW INDEX FROM 表</span><br><span class="line"></span><br><span class="line">-- 增加一个索引</span><br><span class="line">ALTER TABLE 表 ADD FULLTEXT INDEX 索引名（字段名）</span><br><span class="line"></span><br><span class="line">-- EXPLAIN 分析sql执行状况</span><br><span class="line">EXPLAIN SELECT * FROM student -- 非全文索引</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试索引"><a href="#测试索引" class="headerlink" title="测试索引"></a>测试索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `app_user` (</span><br><span class="line">`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(50) DEFAULT &#x27;&#x27;,</span><br><span class="line">`email` VARCHAR(50) NOT NULL,</span><br><span class="line">`phone` VARCHAR(20) DEFAULT &#x27;&#x27;,</span><br><span class="line">`gender` TINYINT(4) UNSIGNED DEFAULT &#x27;0&#x27;,</span><br><span class="line">`password` VARCHAR(100) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">`age` TINYINT(4) DEFAULT NULL,</span><br><span class="line">`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">-- 插入100万数据</span><br><span class="line">DELIMITER $$ --  写函数之前必写</span><br><span class="line">CREATE FUNCTION mock_data()</span><br><span class="line">RETURNS INT </span><br><span class="line">BEGIN</span><br><span class="line">DECLARE num INT DEFAULT 1000000;</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">WHILE i&lt;num DO</span><br><span class="line">-- 插入语句</span><br><span class="line">INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`)</span><br><span class="line">VALUE(CONCAT(&#x27;用户&#x27;,i),&#x27;534240118@qq.com&#x27;,FLOOR (CONCAT(&#x27;18&#x27;,RAND()*9999999)),FLOOR (RAND()*2),</span><br><span class="line">UUID(),FLOOR (RAND()*100));</span><br><span class="line"></span><br><span class="line">SET i = i+1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`)</span><br><span class="line">VALUE(CONCAT(&#x27;用户&#x27;,i),&#x27;534240118@qq.com&#x27;,FLOOR (CONCAT(&#x27;18&#x27;,RAND()*9999999)),FLOOR (RAND()*2),</span><br><span class="line">UUID(),FLOOR (RAND()*100))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT mock_data();</span><br><span class="line"></span><br><span class="line">SELECT * FROM app_user WHERE `name`=&#x27;用户9999&#x27; -- 接近半秒</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM app_user WHERE `name`=&#x27;用户9999&#x27;  -- 查询99999条记录</span><br><span class="line"></span><br><span class="line">-- id _ 表名_字段名</span><br><span class="line">-- create index on 字段</span><br><span class="line">CREATE INDEX id_app_user_name ON app_user(`name`); -- 0.001 s</span><br><span class="line">EXPLAIN SELECT * FROM app_user WHERE `name`=&#x27;用户9999&#x27;  -- 查询一条记录</span><br></pre></td></tr></table></figure><p>索引在小数据的时候，用处不大，但是在大数据的时候，区别十分明显</p><h3 id="索引原则"><a href="#索引原则" class="headerlink" title="索引原则"></a>索引原则</h3><ul><li>索引不是越多越好</li><li>不要对经常变动的数据加索引</li><li>小数据量的表不需要加索引</li><li>索引一般加在常用来查询的字段上</li></ul><h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><p>Hash 类型的索引</p><p>Btree: 默认innodb 的数据结构</p><p>阅读： <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><h2 id="权限管理和备份"><a href="#权限管理和备份" class="headerlink" title="权限管理和备份"></a>权限管理和备份</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="SQLyog-可视化管理"><a href="#SQLyog-可视化管理" class="headerlink" title="SQLyog 可视化管理"></a>SQLyog 可视化管理</h4><p><img src="https://img-blog.csdnimg.cn/20200708013449970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="SQL命令操作"><a href="#SQL命令操作" class="headerlink" title="SQL命令操作"></a>SQL命令操作</h4><p>用户表：mysql.user</p><p>本质：对这张表进行，增删改查</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建用户  CREATE USER 用户名 IDENTIFIED BY &#x27;密码&#x27;</span><br><span class="line">CREATE USER sanjin IDENTIFIED BY &#x27;123456&#x27;</span><br><span class="line"></span><br><span class="line">-- 修改密码（修改当前密码）</span><br><span class="line">SET PASSWORD = PASSWORD(&#x27;111111&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 修改密码（修改指定用户密码）</span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR sanjin = PASSWORD(&#x27;111111&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 重命名  rename user 原名字 to 新名字</span><br><span class="line">RENAME USER sanjin TO sanjin2</span><br><span class="line"></span><br><span class="line">-- 用户授权   ALL PRIVILEGES 全部的权限   库，表</span><br><span class="line">-- ALL PRIVILEGES 除了给别人授权，其他都能干</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO sanjin2</span><br><span class="line"></span><br><span class="line">-- 查询权限</span><br><span class="line">SHOW GRANTS FOR sanjin2  -- 查看指定用户的权限</span><br><span class="line">SHOW GRANTS FOR root@localhost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 撤销权限 REVOKE 哪些权限，在哪个库撤销，给谁撤销</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM sanjin2</span><br><span class="line"></span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER sanjin2</span><br></pre></td></tr></table></figure><h3 id="MySQL备份"><a href="#MySQL备份" class="headerlink" title="MySQL备份"></a>MySQL备份</h3><p>为什么备份：</p><ul><li>保证重要数据不丢失</li><li>数据转移</li></ul><p>MySQL数据库备份的方式</p><ul><li><p>直接拷贝物理文件</p></li><li><p>在SQLyog这种可视化工具中手动导出</p><ul><li>在想要导出的表或者库中，右键选择备份和导出</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200708013418659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200708013426360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="规范数据库设计"><a href="#规范数据库设计" class="headerlink" title="规范数据库设计"></a>规范数据库设计</h2><p>当数据库比较复杂的时候，我们就需要设计了</p><p>糟糕的数据库设计：</p><ul><li>数据冗余，浪费空间</li><li>数据库插入和删除都会麻烦，异常【屏蔽使用物理外键】</li><li>程序的性能差</li></ul><p>良好的数据库设计：</p><ul><li>节省内存空间</li><li>保证数据库的完整性</li><li>方便我们开发系统</li></ul><p>软件开发中，关于数据库的设计</p><ul><li>分析需求：分析业务和需要处理的数据库的需求</li><li>概要设计：设计关系图 E-R图</li></ul><p>设计数据库的步骤（个人博客）</p><ul><li><p>收集信息，分析需求</p><ul><li>用户表（用户登录注销，用户的个人信息，写博客，创建分类）</li><li>分类表（文章分类，谁创建的）</li><li>文章表（文章的信息）</li><li>友链表（友链信息）</li><li>自定义表（系统信息，某个关键的字，或者某些主字段）</li><li>说说表（发表心情…id ,content ,time）</li></ul></li><li><p>标识实体（把需求落地到每个字段）</p></li><li><p>标识实体之间的关系</p><ul><li>写博客 user–&gt;blog</li><li>创建分类 user–&gt;category</li><li>关注 user–&gt;user</li><li>友链–&gt;links</li><li>评论 user–&gt;user</li></ul></li></ul><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>为什么需要数据规范化？</p><ul><li><p>信息重复</p></li><li><p>更新异常</p></li><li><p>插入异常</p></li><li><p>删除异常</p><ul><li>无法正常显示异常</li></ul></li><li><p>删除异常</p><ul><li>丢失有效的信息</li></ul></li></ul><p>三大范式</p><p>第一范式（1NF）</p><p>原子性：保证每一列不可再分</p><p>第二范式（2NF）</p><p>前提：满足第一范式</p><p>每张表只描述一件事情</p><p>第三范式（3NF）</p><p>前提：满足第一范式和第二范式</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>（规范数据库的设计）</p><h3 id="规范性和性能的问题"><a href="#规范性和性能的问题" class="headerlink" title="规范性和性能的问题"></a>规范性和性能的问题</h3><p>关联查询的表，不得超过三张表</p><ul><li>考虑商业化的需求和目标（成本和用户体验） 数据库的性能更加重要</li><li>再规范性能的问题的时候，需要适当的考虑一下，规范性</li><li>故意给某些表加一些冗余的字段（从多表，变成单表）</li><li>故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li></ul><h2 id="JDBC-重点"><a href="#JDBC-重点" class="headerlink" title="JDBC(重点)"></a>JDBC(重点)</h2><h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p>驱动：声卡，显卡，数据库</p><p><img src="https://img-blog.csdnimg.cn/20200708013306539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们的程序会通过数据库驱动，和数据库打交道！</p><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>SUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个(Java操作数据库的)规范，JDBC</p><p>这些规范的实现由具体的厂商去做</p><p>对于开发人员来说，我们只需要掌握JDBC的接口操作即可</p><p><img src="https://img-blog.csdnimg.cn/20200708013314340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>java.sql</p><p>javax.sql</p><p>还需要导入数据库驱动包</p><h3 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h3><p>创建测试数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">USE jdbcStudy;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `users`(</span><br><span class="line">id INT PRIMARY KEY,</span><br><span class="line">NAME VARCHAR(40),</span><br><span class="line">PASSWORD VARCHAR(40),</span><br><span class="line">email VARCHAR(60),</span><br><span class="line">birthday DATE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO `users`(id,NAME,PASSWORD,email,birthday)</span><br><span class="line">VALUES(1,&#x27;zhansan&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-04&#x27;),</span><br><span class="line">(2,&#x27;lisi&#x27;,&#x27;123456&#x27;,&#x27;lisi@sina.com&#x27;,&#x27;1981-12-04&#x27;),</span><br><span class="line">(3,&#x27;wangwu&#x27;,&#x27;123456&#x27;,&#x27;wangwu@sina.com&#x27;,&#x27;1979-12-04&#x27;)</span><br></pre></td></tr></table></figure><p>1.创建一个普通项目</p><p>2.导入数据库驱动</p><p>3.编写测试代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson01;</span><br><span class="line">//我的第一个JDBC程序</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class JdbcFirstDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //1. 加载驱动</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//固定写法</span><br><span class="line">        //2. 用户信息和url</span><br><span class="line">        //useUnicode=true&amp;characterEncoding=utf8&amp;&amp;useSSL=true</span><br><span class="line">        String url =&quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;&amp;useSSL=false&quot;;</span><br><span class="line">        String name = &quot;root&quot;;</span><br><span class="line">        String password = &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    //3. 连接成功，返回数据库对象  connection代表数据库</span><br><span class="line">    Connection connection= DriverManager.getConnection(url,name,password);</span><br><span class="line">    //4. 执行SQL的对象 statement 执行SQL的对象</span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">    //5. 执行SQL的对象 去执行SQL   可能存在结果，查看返回结果</span><br><span class="line">    String sql=&quot;SELECT * FROM users&quot;;</span><br><span class="line">    ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果</span><br><span class="line">    while(resultSet.next())&#123;</span><br><span class="line">        System.out.println(&quot;id+&quot;+resultSet.getObject(&quot;id&quot;));</span><br><span class="line">        System.out.println(&quot;name+&quot;+resultSet.getObject(&quot;NAME&quot;));</span><br><span class="line">        System.out.println(&quot;password+&quot;+resultSet.getObject(&quot;PASSWORD&quot;));</span><br><span class="line">        System.out.println(&quot;email+&quot;+resultSet.getObject(&quot;email&quot;));</span><br><span class="line">        System.out.println(&quot;birthday+&quot;+resultSet.getObject(&quot;birthday&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 释放连接</span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤总结：<br>1.加载驱动</p><p>2.连接数据库 DriverManager</p><p>3.获取执行SQL的对象 Statement</p><p>4.获得返回的结果集</p><p>5.释放连接</p><h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//固定写法</span><br><span class="line">Connection connection= DriverManager.getConnection(url,name,password);</span><br><span class="line"></span><br><span class="line">//connection代表数据库</span><br><span class="line">//数据库设置自动提交</span><br><span class="line">//事务提交</span><br><span class="line">//事务回滚</span><br><span class="line">connection.rollback();</span><br><span class="line">connection.commit();</span><br><span class="line">connection.setAutoCommit();</span><br></pre></td></tr></table></figure><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String url =&quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;&amp;useSSL=false&quot;;</span><br><span class="line"></span><br><span class="line">//mysql 默认3306</span><br><span class="line">//协议://主机地址:端口号/数据库名？参数1&amp;参数2&amp;参数3</span><br><span class="line"></span><br><span class="line">//Oracle   1521</span><br><span class="line">//jdbc:oralce:thin:@localhost:1521:sid</span><br></pre></td></tr></table></figure><h4 id="statement-执行SQL的对象-pPrepareStatement-执行SQL的对象"><a href="#statement-执行SQL的对象-pPrepareStatement-执行SQL的对象" class="headerlink" title="statement 执行SQL的对象 pPrepareStatement 执行SQL的对象"></a>statement 执行SQL的对象 pPrepareStatement 执行SQL的对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String sql=&quot;SELECT * FROM users&quot;;//编写Sql</span><br><span class="line"></span><br><span class="line">statement.executeQuery();</span><br><span class="line">statement.execute();</span><br><span class="line">statement.executeUpdate();//更新，插入，删除，返回一个受影响的行数</span><br></pre></td></tr></table></figure><p>ResultSet 查询的结果集，封装了所以的查询结果</p><h4 id="获得指定的数据类型"><a href="#获得指定的数据类型" class="headerlink" title="获得指定的数据类型"></a>获得指定的数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果</span><br><span class="line">        resultSet.getObject();//在不知道列类型下使用</span><br><span class="line">        resultSet.getString();//如果知道则指定使用</span><br><span class="line">        resultSet.getInt();</span><br></pre></td></tr></table></figure><h4 id="遍历-指针"><a href="#遍历-指针" class="headerlink" title="遍历,指针"></a>遍历,指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resultSet.next(); //移动到下一个</span><br><span class="line">resultSet.afterLast();//移动到最后</span><br><span class="line">resultSet.beforeFirst();//移动到最前面</span><br><span class="line">resultSet.previous();//移动到前一行</span><br><span class="line">resultSet.absolute(row);//移动到指定行</span><br></pre></td></tr></table></figure><h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//6. 释放连接</span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();//耗资源</span><br></pre></td></tr></table></figure><h3 id="statement对象"><a href="#statement对象" class="headerlink" title="statement对象"></a>statement对象</h3><p>Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。</p><p>Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sq|语句， executeUpdate执行完后， 将会返回一个整数(即增删改语句导致了数据库几行数据发生了变化)。</p><p>Statement.executeQuery方法用于向数据库发生查询语句，executeQuery方法返回代表查询结果的ResultSet对象。</p><h4 id="CRUD操作-create"><a href="#CRUD操作-create" class="headerlink" title="CRUD操作-create"></a>CRUD操作-create</h4><p>使用executeUpdate(String sql)方法完成数据添加操作，示例操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">        String sql = &quot;insert into user(...) values(...)&quot;;</span><br><span class="line">        int num = statement.executeUpdate(sql);</span><br><span class="line">        if(num&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;插入成功&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="CRUD操作-delete"><a href="#CRUD操作-delete" class="headerlink" title="CRUD操作-delete"></a>CRUD操作-delete</h4><p>使用executeUpdate(String sql)方法完成数据删除操作，示例操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">        String sql = &quot;delete from user where id =1&quot;;</span><br><span class="line">        int num = statement.executeUpdate(sql);</span><br><span class="line">        if(num&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;删除成功&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>CURD操作-update</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用executeUpdate(String sql)方法完成数据修改操作，示例操作：</span><br><span class="line"></span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">        String sql = &quot;update user set name =&#x27;&#x27; where name = &#x27;&#x27;&quot;;</span><br><span class="line">        int num = statement.executeUpdate(sql);</span><br><span class="line">        if(num&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;修改成功&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="CURD操作-read"><a href="#CURD操作-read" class="headerlink" title="CURD操作-read"></a>CURD操作-read</h4><p>使用executeUpdate(String sql)方法完成数据查询操作，示例操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">        String sql = &quot;select * from  user where id =1&quot;;</span><br><span class="line">        ResultSet rs= statement.executeQuery(sql);</span><br><span class="line">        if(rs.next())&#123;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码实现</p><p>1.提取工具类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson02.utils;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class JdbcUtils &#123;</span><br><span class="line">    private static String driver = null;</span><br><span class="line">    private static String url = null;</span><br><span class="line">    private static String username = null;</span><br><span class="line">    private static String password = null;</span><br><span class="line">    static &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);</span><br><span class="line">            Properties properties = new Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            driver=properties.getProperty(&quot;driver&quot;);</span><br><span class="line">            url=properties.getProperty(&quot;url&quot;);</span><br><span class="line">            username=properties.getProperty(&quot;username&quot;);</span><br><span class="line">            password=properties.getProperty(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">        //1.驱动只用加载一次</span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">//2.获取连接</span><br><span class="line">public static Connection getConnection() throws Exception&#123;</span><br><span class="line">    return DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;</span><br><span class="line">//3.释放资源</span><br><span class="line">public static void release(Connection conn, Statement st, ResultSet rs) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    if(rs!=null)&#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    if (st!=null)&#123;</span><br><span class="line">        st.close();</span><br><span class="line">    &#125;</span><br><span class="line">    if(conn!=null)&#123;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.编写增删改的方法，exectueUpdate</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson02.utils;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import static com.kuang.lesson02.utils.JdbcUtils.*;</span><br><span class="line"></span><br><span class="line">public class TestInnsert &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Connection conn =null;</span><br><span class="line">        Statement st = null;</span><br><span class="line">        ResultSet rs =null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    try &#123;</span><br><span class="line">         conn = getConnection();//获取连接</span><br><span class="line">        st = conn.createStatement();//获取SQL执行对象</span><br><span class="line">        String sql = &quot;INSERT INTO users(id,`NAME`,`PASSWORD`,`email`,`birthday`)&quot; +</span><br><span class="line">                &quot;VALUES(5,&#x27;sanjin&#x27;,&#x27;123456&#x27;,&#x27;233223@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;;</span><br><span class="line"></span><br><span class="line">        int i = st.executeUpdate(sql);</span><br><span class="line">        if(i&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;插入成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.查询 executeQuery</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson02.utils;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import static com.kuang.lesson02.utils.JdbcUtils.*;</span><br><span class="line"></span><br><span class="line">public class TestInnsert &#123;</span><br><span class="line">    public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">        Connection conn =null;</span><br><span class="line">        Statement st = null;</span><br><span class="line">        ResultSet rs =null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    try &#123;</span><br><span class="line">         conn = getConnection();//获取连接</span><br><span class="line">        st = conn.createStatement();//获取SQL执行对象</span><br><span class="line">        String sql = &quot;select * from users&quot;;</span><br><span class="line">        rs=st.executeQuery(sql);//查询完毕返回结果集</span><br><span class="line"></span><br><span class="line">        while (rs.next())&#123;</span><br><span class="line">            System.out.println(rs.getString(&quot;NAME&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL注入问题</p><p>sql存在漏洞，会被攻击导致数据泄露 SQL会被拼接 or</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson02.utils;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import static com.kuang.lesson02.utils.JdbcUtils.getConnection;</span><br><span class="line"></span><br><span class="line">public class SQL注入 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    //SQL注入</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> login(&quot;&#x27; or &#x27;1=1&quot;,&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void login(String name,String password)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    Connection conn =null;</span><br><span class="line">    Statement st = null;</span><br><span class="line">    ResultSet rs =null;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    try &#123;</span><br><span class="line">        conn = getConnection();//获取连接</span><br><span class="line">        st = conn.createStatement();//获取SQL执行对象</span><br><span class="line">        String sql = &quot;select * from users where `NAME`=&#x27;&quot;+ name +&quot;&#x27;  AND `PASSWORD`=&#x27;&quot;+ password +&quot;&#x27;&quot; ;</span><br><span class="line">        rs=st.executeQuery(sql);//查询完毕返回结果集</span><br><span class="line"></span><br><span class="line">        while (rs.next())&#123;</span><br><span class="line">            System.out.println(rs.getString(&quot;NAME&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JdbcUtils.release(conn,st,rs);</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PreparedStatement对象"><a href="#PreparedStatement对象" class="headerlink" title="PreparedStatement对象"></a>PreparedStatement对象</h3><p>PreparedStatement 可以防止SQL注入 ，效率更高。</p><ol><li>新增</li><li>删除</li><li>查询</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson03;</span><br><span class="line"></span><br><span class="line">import com.kuang.lesson02.utils.JdbcUtils;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection= null;</span><br><span class="line">        PreparedStatement pstm=null;</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">        connection = JdbcUtils.getConnection();</span><br><span class="line">        //区别</span><br><span class="line">        //使用问好占位符代替参数</span><br><span class="line">        String sql = &quot;insert into users(id,`NAME`) values(?,?)&quot;;</span><br><span class="line">        pstm = connection.prepareStatement(sql);//预编译sql，先写sql然后不执行</span><br><span class="line">        //手动赋值</span><br><span class="line">        pstm.setInt(1,8);</span><br><span class="line">        pstm.setString(2,&quot;SANJIN&quot;);</span><br><span class="line"></span><br><span class="line">        //执行</span><br><span class="line">        int i = pstm.executeUpdate();</span><br><span class="line">        if (i&gt;0)&#123;</span><br><span class="line">            System.out.println(&quot;插入成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JdbcUtils.release(connection,pstm,null);</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止SQL注入本质，传递字符 带有“ ”，转义字符会被转义</p><p>10.6 使用IDEA连接数据库</p><p><img src="https://img-blog.csdnimg.cn/20200708013123797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>连接成功后，可以选择数据库</p><p><img src="https://img-blog.csdnimg.cn/20200708013148715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>双击数据库</p><p><img src="https://img-blog.csdnimg.cn/20200708013157507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>更新数据</p><p><img src="https://img-blog.csdnimg.cn/20200708013204924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzOTU2NTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>编写sql代码的地方</p><p><img src="https://img-blog.csdnimg.cn/20200708013211958.png" alt="在这里插入图片描述"></p><h3 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h3><p>要么都成功，要么都失败</p><p>ACID原则</p><p>原子性：要么全部完成，要么都不完成</p><p>一致性：结果总数不变</p><p>隔离性：多个进程互不干扰</p><p>持久性：一旦提交不可逆，持久化到数据库了</p><p>隔离性的问题：</p><p>脏读： 一个事务读取了另一个没有提交的事务</p><p>不可重复读：在同一个事务内，重复读取表中的数据，表发生了改变</p><p>虚读（幻读）：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致</p><p>代码实现</p><ol><li><p>开启事务conn.setAutoCommit(false);</p></li><li><p>一组业务执行完毕，提交事务</p></li><li><p>可以在catch语句中显示的定义回滚，但是默认失败会回滚</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.lesson04;</span><br><span class="line"></span><br><span class="line">import com.kuang.lesson02.utils.JdbcUtils;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Action &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">    Connection conn =null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        //关闭数据库的自动提交功能， 开启事务</span><br><span class="line">        conn.setAutoCommit(false);</span><br><span class="line">        //自动开启事务</span><br><span class="line">        String sql = &quot;update account set money = money-500 where id = 1&quot;;</span><br><span class="line">        ps =conn.prepareStatement(sql);</span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">        String sql2 = &quot;update account set money = money-500 where id = 2&quot;;</span><br><span class="line">        ps=conn.prepareStatement(sql2);</span><br><span class="line">        ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        //业务完毕，提交事务</span><br><span class="line">        conn.commit();</span><br><span class="line">        System.out.println(&quot;操作成功&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //如果失败，则默认回滚</span><br><span class="line">            conn.rollback();//如果失败，回滚</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JdbcUtils.release(conn,ps,rs);</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接–执行完毕–释放</p><p>连接–释放 十分浪费资源</p><p>池化技术： 准备一些预先的资源，过来就连接预先准备好的</p><p>常用连接数 100</p><p>最少连接数：100</p><p>最大连接数 ： 120 业务最高承载上限</p><p>排队等待，</p><p>等待超时：100ms</p><p>编写连接池，实现一个接口 DateSource</p><p>开源数据源实现(拿来即用)</p><p>DBCP</p><p>C3P0</p><p>Druid: 阿里巴巴</p><p>使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了</p><p>DBCP</p><p>需要用到的jar包</p><p>dbcp.ar</p><p>C3P0</p><p>结论</p><p>无论使用什么数据源，本质是不变的，DateSource接口不会变，方法就不会变</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;初始Mysql数据库&quot;&gt;&lt;a href=&quot;#初始Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;初始Mysql数据库&quot;&gt;&lt;/a&gt;初始Mysql数据库&lt;/h2&gt;&lt;h3 id=&quot;为什么学数据库&quot;&gt;&lt;a href=&quot;#为什么学数据库&quot; class=&quot;headerlink&quot; title=&quot;为什么学数据库&quot;&gt;&lt;/a&gt;为什么学数据库&lt;/h3&gt;&lt;p&gt;1、岗位需求&lt;/p&gt;
&lt;p&gt;2、现在的世界，大数据时代，得数据者得天下&lt;/p&gt;
&lt;p&gt;3、被迫需求：存数据&lt;/p&gt;
&lt;p&gt;4、数据库是所有软件体系中最核心的存在 DBA&lt;/p&gt;
&lt;h3 id=&quot;什么是数据库&quot;&gt;&lt;a href=&quot;#什么是数据库&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库&quot;&gt;&lt;/a&gt;什么是数据库&lt;/h3&gt;&lt;p&gt;数据库：(DB,DataBase)&lt;/p&gt;
&lt;p&gt;概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万!&lt;/p&gt;
&lt;p&gt;作用:存储数据，管理数据 Excel&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/20dbfd00.html"/>
    <id>http://example.com/20dbfd00.html</id>
    <published>2022-06-24T02:13:57.000Z</published>
    <updated>2022-06-24T07:18:34.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预科"><a href="#预科" class="headerlink" title="预科"></a>预科</h2><h3 id="什么是计算机"><a href="#什么是计算机" class="headerlink" title="什么是计算机"></a>什么是计算机</h3><ol><li>名称：Computer，全称电子计算机，俗称电脑。</li><li>定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。</li><li>组成：由硬件和软件组成。</li><li>形式：常见显示有台式计算机、笔记本计算机、大型计算机等。</li><li>应用：科学计算、数据处理、自动控制、计算机辅助设计、人工智能、网络等领域。</li></ol><h3 id="硬件及冯诺依曼结构"><a href="#硬件及冯诺依曼结构" class="headerlink" title="硬件及冯诺依曼结构"></a>硬件及冯诺依曼结构</h3><h4 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h4><p>组成：cpu，主板，内存，电源，主机箱，硬盘，显卡，键盘、鼠标，显示器。</p><h4 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h4><p><img src="https://img-blog.csdnimg.cn/20210427081055529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h4 id="软件及软件开发"><a href="#软件及软件开发" class="headerlink" title="软件及软件开发"></a>软件及软件开发</h4><h4 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h4><h4 id="Windows常用快捷键"><a href="#Windows常用快捷键" class="headerlink" title="Windows常用快捷键"></a>Windows常用快捷键</h4><p>Alt+f4关闭窗口 Shift+Delete永久删除 ctrl+w自动保存</p><p>死机：任务管理器结束进程</p><h4 id="基本的Dos命令"><a href="#基本的Dos命令" class="headerlink" title="基本的Dos命令"></a>基本的Dos命令</h4><p>打开CMD的方式</p><ol><li>开始+系统+命令提示符</li><li>win键+R+输入cmd (推荐使用)</li><li>在任意的文件夹下，按住Shift键+鼠标右击，打开命令行窗口</li><li>在资源管理器地址栏路径前面加 “cmd ”</li><li>管理员运行方式：命令提示符右键以管理员身份运行（最高权限运行）</li></ol><p>常用的Dos命令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 盘符切换 E:</span><br><span class="line"># 查看当前目录下所有文件 dir</span><br><span class="line"># 切换目录 cd /d E:\idea</span><br><span class="line"># 返回上一级目录 cd ..</span><br><span class="line"># 进入同级目录下的下一级目录 cd <span class="title function_">tmp</span><span class="params">(该目录下的文件名)</span></span><br><span class="line"># 清屏 cls (clear screen)</span><br><span class="line"># 退出终端 exit</span><br><span class="line"># 查看电脑当前IP地址 ipconfig</span><br><span class="line"></span><br><span class="line"># 打开计算器 calc</span><br><span class="line"># 打开画图 mspaint</span><br><span class="line"># 新建记事本 notepad</span><br><span class="line"></span><br><span class="line"># 在当前目录新建文件夹 md <span class="title function_">test</span><span class="params">(文件夹名)</span></span><br><span class="line"># 新建文件 cd&gt; a.txt(文件名)</span><br><span class="line"># 删除文件 del a.txt(文件名)</span><br><span class="line"># 删除目录 rd <span class="title function_">test</span><span class="params">(目录名)</span></span><br><span class="line"></span><br><span class="line"># ping命令(复制链接进入Dos直接单击鼠标右键粘贴)</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><h4 id="计算机语言发展史"><a href="#计算机语言发展史" class="headerlink" title="计算机语言发展史"></a>计算机语言发展史</h4><ul><li>第一代语言：机器语言</li><li>第二代语言：汇编语言</li><li>第三代语言：高级语言</li></ul><h4 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h4><p>C、C++、Java、C#、Python、PHP、JavaScript …</p><p>大体上分为：<strong>面向过程</strong>与<strong>面向对象</strong>两大类</p><p>C语言是典型的<strong>面向过程</strong>的语言，C++，Java是典型的<strong>面向对象</strong>的语言</p><hr><h2 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h2><h3 id="Java帝国的诞生"><a href="#Java帝国的诞生" class="headerlink" title="Java帝国的诞生"></a>Java帝国的诞生</h3><p><img src="https://img-blog.csdnimg.cn/20210427081209316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h4 id="Java特性与优势"><a href="#Java特性与优势" class="headerlink" title="Java特性与优势"></a>Java特性与优势</h4><p><img src="https://img-blog.csdnimg.cn/20210427081218160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><ul><li>简单性</li><li>面对对象</li><li>可移植性</li><li>高性能</li><li>分布式</li><li>多态性</li><li>多线程</li><li>安全性</li><li>健壮性</li></ul><h4 id="Java三大版本"><a href="#Java三大版本" class="headerlink" title="Java三大版本"></a>Java三大版本</h4><ul><li>Write Once，Run Anywhere</li><li>JavaSE: 标准版 (桌面程序，控制台开发…)</li><li>JavaME: 嵌入式开发 (手机，小家电…)，已经凉了</li><li>JavaEE: E企业级开发 (Web端，服务端开发…)，JavaSE为基础</li></ul><h4 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h4><ul><li>JDK：Java Development Kit (Java开发者工具，包括 JRE，JVM)</li><li>JRE：Java Runtime Environment (Java运行时环境)</li><li>JVM：Java Virtual Machine (Java虚拟机，跨平台核心)</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427081317290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h4 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h4><h5 id="卸载JDk"><a href="#卸载JDk" class="headerlink" title="卸载JDk"></a>卸载JDk</h5><ol><li>删除Java安装目录</li><li>删除环境变量JAVA_HOME</li><li>删除path下关于JAVA的目录</li><li>Java -version</li></ol><h5 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h5><ol><li>百度搜索JDK8，找到下载地址</li><li>同意协议，下载电脑对应的版本，如64位操作系统下载 jdk-8u281-windows-x64.exe</li><li>双击安装JDK</li><li>记住安装路径</li><li>配置环境变量<ol><li>我的电脑-》属性-》系统高级设置-》环境变量</li><li>系统变量 新建–&gt; JAVA_HOME 输入对应的jdk安装路径</li><li>path变量–&gt;% JAVA_HOME%\bin</li></ol></li><li>测试是否成功 cmd–&gt;Java -version</li></ol><hr><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>单行注释 //</li><li>多行注释 /* */</li><li>文档注释 /** */</li></ol><h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><ul><li>Java 所有的组成部分都需要名字。类名、变量名、方法名都被称为标识符</li></ul><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><img src="https://img-blog.csdnimg.cn/2021042708142877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h4 id="标识符注意点"><a href="#标识符注意点" class="headerlink" title="标识符注意点"></a>标识符注意点</h4><ul><li>所有标识符都应该以 字母、$(美元符)、_(下划线) 开头</li><li>首字母之后可以是 字母、$、_ 或数字任何字符组合</li><li>关键字不能作为变量名或方法名</li><li>标识符大小写敏感</li><li>可以用中文命名，但不建议使用，即使用拼音命名也Low</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>强类型语言</p><ul><li>要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</li></ul></li><li><p>弱类型语言：JavaScript，Python</p></li><li><p>Java的数据类型分为两大类</p><ul><li>基本类型（primitive type），有8大基本类型，此外都是引用类型</li><li>引用类型（reference type）</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210427081748164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//最常用，只要别超过21亿（2^31-1）</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//-128~127</span></span><br><span class="line"><span class="type">short</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">30L</span>; <span class="comment">//long类型数字后面要加个L(尽量用大写，小写l容易与1搞混)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小数：浮点数</span></span><br><span class="line"><span class="type">float</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">50.1F</span>; <span class="comment">//float类型数字后面要加个F</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">3.141592653589793238</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;国&#x27;</span>;</span><br><span class="line"><span class="comment">//字符串, String不是关键字，是类</span></span><br><span class="line"><span class="comment">//String namea = &quot;薛之谦&quot;;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//布尔值：是非</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h4><ul><li>位(bit)：是计算机内部数据存储的最小单位，11001100是一个八位二进制数</li><li>字节(byte, B)：是计算机中 数据处理 的基本单位，习惯上用大写B表示</li><li>1B(byte) = 8bit，1字节等于8位</li><li>字符：指计算机中使用的字母，数字，字和符号<ul><li>1bit表示1位</li><li>1Byte表示一个字节 1B=8b</li><li>1024B = 1KB, 1024KB = 1M, 1024M = 1G</li></ul></li></ul><h4 id="扩展及面试题"><a href="#扩展及面试题" class="headerlink" title="扩展及面试题"></a>扩展及面试题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数扩展： 二进制0b八进制0十进制十六进制0x</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>; <span class="comment">//八进制 8</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制 16</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点数扩展：</span></span><br><span class="line"><span class="comment">//面试题：银行业务字母怎么表示钱? BigDecimal(数学工具类)</span></span><br><span class="line"><span class="comment">//float double是有问题的，最好避免使用浮点数进行比较</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.1f</span>; <span class="comment">//0.1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span>/<span class="number">10</span>;  <span class="comment">//0.1</span></span><br><span class="line">System.out.println(f==d); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//浮点数 位有限，舍入误差，大约</span></span><br><span class="line"><span class="comment">//最好避免使用浮点数进行比较</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">23131313131f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> f1+<span class="number">1</span>;</span><br><span class="line">System.out.println(f1==f2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符扩展：所有字符本质还是数字</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(c1);<span class="comment">//a</span></span><br><span class="line">System.out.println((<span class="type">int</span>)c1);<span class="comment">//强制类型转换,97</span></span><br><span class="line">System.out.println(c2);<span class="comment">//中</span></span><br><span class="line">System.out.println((<span class="type">int</span>)c2);<span class="comment">//强制类型转换,20013</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编码 Unicode表（97=a,65=A）2字节 0-65536</span></span><br><span class="line"><span class="comment">//U000~UFFFF 十六进制（u0061=a,相当于十进制的97）</span></span><br><span class="line">System.out.println(<span class="string">&#x27;\u0061&#x27;</span>);  <span class="comment">//a &#x27;\&#x27;是转义字符</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//布尔值扩展</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="literal">true</span>)&#123;&#125; <span class="comment">//新手</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;&#125;<span class="comment">//老手这样写 Less is More(代码要精简易读)</span></span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</li><li>容量高–&gt;低：</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427081848182.png"></p><ul><li>运算中，不同类型的数据先转化位同一类型，再进行运算。<ul><li>强制转换，（类型）变量名，容量由高到低</li><li>自动转换，容量由低到高</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强制转换 （类型）变量名 高--低</span></span><br><span class="line"><span class="comment">//自动转换 低--高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i; <span class="comment">//强制转换 内存溢出 -128~127</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span>i; <span class="comment">//自动转换</span></span><br><span class="line"></span><br><span class="line">System.out.println(i); <span class="comment">//128</span></span><br><span class="line">System.out.println(b); <span class="comment">//-128</span></span><br><span class="line">System.out.println(d); <span class="comment">//128.0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   注意点：</span></span><br><span class="line"><span class="comment">   1.不能对布尔值进行转换</span></span><br><span class="line"><span class="comment">   2.不能把对象类型转换为不相干的类型</span></span><br><span class="line"><span class="comment">   3.在把高容器转换到低容量的时候，强制转换</span></span><br><span class="line"><span class="comment">   4.可能存在内存溢出，或者精度问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println((<span class="type">int</span>)<span class="number">23.7</span>); <span class="comment">//23 丢失精度</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c+<span class="number">1</span>;</span><br><span class="line">System.out.println(n); <span class="comment">//98</span></span><br><span class="line">System.out.println((<span class="type">char</span>)n); <span class="comment">//b</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当操作数比较大时，注意溢出问题</span></span><br><span class="line"><span class="comment">//JDK7新特性，数字之间可以用下划线分割</span></span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>; <span class="comment">//10亿，下划线不会被打印出来</span></span><br><span class="line">System.out.println(money); <span class="comment">//1000000000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">years</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> money*years;  <span class="comment">//数据大，溢出</span></span><br><span class="line">System.out.println(total); <span class="comment">//-1474836480</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">total2</span> <span class="operator">=</span> money*years; <span class="comment">//默认是int，转换前就有溢出问题</span></span><br><span class="line">System.out.println(total2); <span class="comment">//-1474836480</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">total3</span> <span class="operator">=</span> money*(<span class="type">long</span>)years; <span class="comment">//先把一个数转Long</span></span><br><span class="line">System.out.println(total3); <span class="comment">//20000000000</span></span><br></pre></td></tr></table></figure><h3 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h3><ul><li>变量是什么：就是可以变化的量</li><li>Java是一种强类型语言，每个变量都必须声明其类型</li><li>Java变量是程序中最基本的存储单元，要素包括变量名，变量类型和作用域</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型 变量名 = 值;</span></span><br><span class="line">type varName [=value][&#123;,varName[=value]&#125;];</span><br><span class="line"><span class="comment">//可以使用逗号隔开同多个类型的变量，但不建议在一行定义多个变量</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>类变量（static）</li><li>实例变量</li><li>局部变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">allClicks</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//类变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>; <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>; <span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常量：初始化后不能再改变的值，不会变动的值。</span><br><span class="line">可以理解为一种特殊的变量，其值被设定后，在程序运行过程不允许被更改。</span><br><span class="line"><span class="comment">//常量一般用大写字符</span></span><br><span class="line"><span class="keyword">final</span> 常量名=值;</span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰符 不存在先后顺序，static可以写final后面</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> doube PI=<span class="number">3.14</span>; <span class="comment">//类变量，该类下的全局范围</span></span><br></pre></td></tr></table></figure><h4 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h4><ul><li>所有变量、方法、类名：见名知意</li><li>类成员变量：首字母小写+驼峰原则：lastName</li><li>局部变量：首字母小写+驼峰原则</li><li>常量：大写字母和下划线：MAX_VALUE</li><li>类名：首字母大写+驼峰原则：Man，GoodMan</li><li>方法名：首字母小写+驼峰原则：run()，fastRun()</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://img-blog.csdnimg.cn/20210427081956511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">System.out.println(a/b); <span class="comment">//0</span></span><br><span class="line">System.out.println((<span class="type">double</span>)a/b); <span class="comment">//0.5</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> c=<span class="number">12300000000</span>;</span><br><span class="line">System.out.println(a+b); <span class="comment">//int</span></span><br><span class="line">System.out.println(a+c); <span class="comment">//long 自动转换式子中容量大的数据类型</span></span><br></pre></td></tr></table></figure><h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ++自增 --自减 单目运算符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++; <span class="comment">//b=a,a=a+1 先赋值 即b=3 a=4</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a; <span class="comment">//a=a+1,c=a 先自增 即a=5 c=5</span></span><br><span class="line"></span><br><span class="line">System.out.println(a); <span class="comment">//5</span></span><br><span class="line">System.out.println(b); <span class="comment">//3</span></span><br><span class="line">System.out.println(c); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//幂运算 2^3 2*2*2=8</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// (底数，指数)double型</span></span><br><span class="line">System.out.println(pow); <span class="comment">//8.0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展：笔试题 i=5 s=(i++)+(++i)+(i--)+(--i) s=?</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> s=(i++)+(++i)+(i--)+(--i);</span><br><span class="line">System.out.println(s); <span class="comment">//24</span></span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&amp;&amp; 逻辑与运算：两个变量都为真，结果为<span class="literal">true</span></span><br><span class="line">|| 逻辑与运算：两个变量有一个为真，结果为<span class="literal">true</span></span><br><span class="line">! 取反，真变为假，假变为真</span><br><span class="line"><span class="comment">// 与(snd) 或(or) 非(取反)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a&amp;&amp;b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a||b); <span class="comment">// true</span></span><br><span class="line">System.out.println(!(a&amp;&amp;b)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c=<span class="number">5</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> (c&lt;<span class="number">5</span>)&amp;&amp;(c++&lt;<span class="number">5</span>); <span class="comment">//第一个值为false，后面就不进行判定了</span></span><br><span class="line">System.out.println(d); <span class="comment">//false</span></span><br><span class="line">System.out.println(c); <span class="comment">//5 c++未执行</span></span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A = 0011 1100</span></span><br><span class="line"><span class="comment">    B = 0000 1101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    A&amp;B 0000 1101 按位与</span></span><br><span class="line"><span class="comment">    A|B 0011 1101 按位或</span></span><br><span class="line"><span class="comment">    A^B 0011 0001 异或</span></span><br><span class="line"><span class="comment">    ~B  1111 0010 非</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    面试题：2*8 怎么算最快？ 2&lt;&lt;3</span></span><br><span class="line"><span class="comment">    &lt;&lt;左移  *2 效率极高！！</span></span><br><span class="line"><span class="comment">    &gt;&gt;右移  /2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">3</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">a+=b; <span class="comment">// a = a+b</span></span><br><span class="line">a-=b; <span class="comment">// a = a-b</span></span><br><span class="line"></span><br><span class="line">System.out.println(a); <span class="comment">//10</span></span><br><span class="line"><span class="comment">//字符串连接符 + ，转化为String类型,然后拼接    注意！！</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+a+b); <span class="comment">//1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">&quot;&quot;</span>); <span class="comment">//30 先进行运算，再转为String拼接</span></span><br><span class="line">System.out.println(a+b+<span class="string">&quot;str&quot;</span>); <span class="comment">//30str</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x ? y : z</span></span><br><span class="line"><span class="comment">//如果x为真，则结果为y,否则为z</span></span><br><span class="line"><span class="comment">//if(x) y; else z;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> score&lt;<span class="number">60</span>?<span class="string">&quot;及格&quot;</span>:<span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">System.out.println(type); <span class="comment">//及格</span></span><br></pre></td></tr></table></figure><h4 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h4><ul><li>为了更好地组织类，Java提供了包机制，由于区分类名的命名空间</li><li>包的语法格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg2[.pkg3...]];</span><br></pre></td></tr></table></figure><ul><li>一般利用公司域名倒置作为包名；com.kuangstudy.www</li><li>为了能够使用一个包的成员，需要在Java程序中导入该包</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2...].(className|*); <span class="comment">//通配符* 导入包下所有的类</span></span><br></pre></td></tr></table></figure><ul><li>参考：阿里巴巴Java开发手册</li></ul><h3 id="JavaDoc生成文档"><a href="#JavaDoc生成文档" class="headerlink" title="JavaDoc生成文档"></a>JavaDoc生成文档</h3><ul><li><p>javadoc命令是用来生成自己API文档的</p></li><li><p>参数信息</p><ul><li>@author 作者名</li></ul></li></ul><ul><li><p>@version 版本号</p></li><li><p>@since 指明最早用的jdk版本</p></li><li><p>@param 参数名</p></li><li><p>@return 返回值情况</p></li><li><p>@throws 异常抛出情况</p></li><li><p>API文档：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- <span class="doctag">@author</span> Kuangshen</span></span><br><span class="line"><span class="comment">- <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">- <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">String name;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - <span class="doctag">@author</span> kuangshen</span></span><br><span class="line"><span class="comment">  - <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">  - <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  - <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>打开某个类所在文件夹下的cmd命令行</li><li>输入：javadoc -encoding UTF-8 -charset UTF-8 Doc(类名).java</li><li>会自动生成该类有关的API文档，查看文件夹发现多了一些文件</li><li>打开 index.html（首页）查看文档注释</li></ol><hr><h2 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h2><h3 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h3><ul><li>之前我们学的基本语法并没有实现程序和人的交互，Java给我们提供了一个工具类，可以获取用户的输入java.util.Scanner是Java5的新特征，我们通过Scanner类来获取用户的输入。</li><li>基本语法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure><ul><li>通过Scanner类的 next()与 nextLine()方法获取用户的字符串，读取前一般用hasNext()与hasNextLine()判断是否还有输入的数据。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个扫描器对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;使用next方式接收&quot;</span>);</span><br><span class="line"><span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line"><span class="keyword">if</span>(scanner.hasNext())&#123;  <span class="comment">//使用hasNextLie()会接收一行 &quot;hello word&quot;</span></span><br><span class="line">    <span class="comment">//使用next方式接收</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next(); </span><br><span class="line">    System.out.println(<span class="string">&quot;输入的内容为：&quot;</span>+str);</span><br><span class="line">    <span class="comment">//input: hello word</span></span><br><span class="line">    <span class="comment">//输入的内容为：hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//凡是属于IO流的类如果不关闭会一直占用资源</span></span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><ol><li>一定要读取到有效字符才可以结束输入</li><li>对输入有效字符之前遇到的空白，next()方法会将其去掉</li><li>只有输入有效字符后才将其后面输入的空白作为结束符</li><li>next()不能得到带有空格的字符串</li></ol><h4 id="nextLine"><a href="#nextLine" class="headerlink" title="nextLine()"></a>nextLine()</h4><ol><li>以Enter作为结束符，即返回输入回车之前所有的字符</li><li>nextLine()可以获取空白</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从键盘接收数据</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;输入的内容为：&quot;</span>+str);</span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextInt())&#123;</span><br><span class="line">    <span class="type">int</span> i=scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;输入的整数为：&quot;</span>+i);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入的不是整数数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ul><li>Java的基本结构就是顺序结构，除非特别指明，否则就按语句一条一条执行。</li><li>顺序结构是最简单的算法结构。</li><li>语句语句之间是按从上到下执行的，它是由若干个依次执行的处理步骤组成的，它是如何一种算法都离不开的一种基本算法结构。</li></ul><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul><li>if单选择结构 if( )</li><li>if双选择结构 if( ){ }else{ }</li><li>if多选择结构 if( ){ }else if{ }else{}</li><li>嵌套的if结构 if( ){ if( ) }</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">60</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">80</span>) System.out.println(<span class="string">&quot;且优秀&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;缺考&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch多选择结构"><a href="#switch多选择结构" class="headerlink" title="switch多选择结构"></a>switch多选择结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>; <span class="comment">//JDK新特性 可以是字符串(字符本质还是数字)</span></span><br><span class="line"><span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//可选，跳出当前结构</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;合格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//默认，以上值没匹配到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDEA反编译之后.class文件与源代码对比</p><p><img src="https://img-blog.csdnimg.cn/20210427082240517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>循环</span><br><span class="line"><span class="comment">//计算1+2+3+...+100</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum); <span class="comment">//5050</span></span><br></pre></td></tr></table></figure><ul><li>do…while循环</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先执行后判断，至少执行一次</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;<span class="number">100</span>) <span class="comment">//跟上面效果一样</span></span><br></pre></td></tr></table></figure><ul><li>for循环</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//（初始化;条件判断;迭代）</span><br><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">for(; ; )&#123;...&#125; //死循环</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习1：输出1-1000能被5整除的数，每行输出3个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>); <span class="comment">//输出完不换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i%(<span class="number">3</span>*<span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2：输出九九乘法表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        System.out.print(j+<span class="string">&quot;*&quot;</span>+i+<span class="string">&quot;=&quot;</span>+i*j+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;; <span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x:numbers)&#123;</span><br><span class="line">    System.out.println(x); <span class="comment">//遍历数组的元素 10 20 30 40 50</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h3><ul><li>break可用在任何循环的主体部分，由于强行退出循环，也可以用在switch语句。</li><li>continue用于循环语句中，终止某次循环过程，跳过剩余语句，之间进行下一次循环条件判断。</li><li>标签：后面跟一个冒号的标识符 label:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印101-150之间所有的质数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">outer:<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">101</span>;i&lt;=<span class="number">150</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span> outer; <span class="comment">//不建议使用标签</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程控制练习"><a href="#流程控制练习" class="headerlink" title="流程控制练习"></a>流程控制练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印等腰空心三角形</span></span><br><span class="line"><span class="comment">/*  例如：输入为4时</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">         * *</span></span><br><span class="line"><span class="comment">        *   *</span></span><br><span class="line"><span class="comment">       * * * *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//n为三角形高</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*n-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=n)&#123; <span class="comment">//若不为最后一行</span></span><br><span class="line">            <span class="keyword">if</span>(i+j==n+<span class="number">1</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>); <span class="comment">//三角形左腰边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+j==n+<span class="number">2</span>*i-<span class="number">1</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>); <span class="comment">//三角形右腰边</span></span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j%<span class="number">2</span>!=<span class="number">0</span>)&#123;  <span class="comment">//最后一行，底边</span></span><br><span class="line">            System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h2><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><ul><li>Java的方法类似与其他语言的函数，是一段用来完成特定功能的代码片段。</li><li>方法包含一个方法头和一个方法体。<ul><li>修饰符：可选，定义了方法的访问类型，告诉编译器如何调用该方法。</li><li>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法没有返回值，则returnValueType为关键字void。</li><li>方法名：是方法的实际名称，方法名与参数表共同构成方法签名。</li><li>参数类型：像一个占位符。方法被调用时，传递值给参数，该值称为实参或变量。参数列表是指方法的参数类型、顺序和参数个数。参数是可选的，方法可以不包含任何参数。<ul><li>形式参数：在方法被调用时用于接收外界输入的数据。</li><li>实参：调用方法时实际传给方法的数据。</li></ul></li></ul></li><li>方法体：方法体包含具体的语句，定义该方法的功能。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名,...）&#123;</span><br><span class="line">   方法体...</span><br><span class="line">   <span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><ul><li>调用方法：对象名.方法名(实参列表)。</li><li>Java支持两种调用方法的方式，根据方法是否返回值来选择。</li><li>当方法返回一个值的时候，方法调用通常被当成一个值。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">larger</span> <span class="operator">=</span> max(<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure><ul><li>如果方法返回值是void，方法调用一定是一条语句。</li><li>扩展：值传递和引用传递 ( Java都是值传递)。</li><li>调用其他类的方法，除非是static静态方法，不然必须实例化这个类(new)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> Demo01.add(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 通过类名直接调用静态方法</span></span><br><span class="line">        System.out.println(add); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static静态方法，否则就要new实例化来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递 &amp;引用传递"></a>值传递 &amp;引用传递</h3><p><img src="https://img-blog.csdnimg.cn/20210427082403886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427082454225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul><li><p>重载是在一个类中，有相同的方法名，参数列表不同的方法。</p></li><li><p>方法重载的规则：</p><ul><li>方法名称必须相同</li><li>参数列表必须不同（个数、参数类型、或排序不同）</li><li>返回类型可以相同也可以不相同</li><li>仅仅返回类型不同不足以成为方法的重载</li></ul></li><li><p>实现理论</p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li></ul></li></ul><h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><ul><li>有时候你希望运行一个程序时候传递给它消息，这要靠传递命令行参数给main()函数实现。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//args.length 数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;args[&quot;</span>+i+<span class="string">&quot;]: &quot;</span>+args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到当前类的文件夹，打开cmd.</p><p><img src="%E5%9F%BA%E7%A1%80.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70-165603926880022.png"></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li>Jdk1.5开始，Java支持传递同类型的可变参数给一个方法。</li><li>在方法声明中，在指定参数类型后加一个省略号 (…)。</li><li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">int</span>... num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有值传入&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; result)&#123;</span><br><span class="line">            result = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值是：&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    printMax(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//最大值是：4</span></span><br><span class="line">    printMax(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;); <span class="comment">//最大值是：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li><p>递归就是：A方法调用A方法，自己调用自己！</p></li><li><p>递归策略只需少量的代码可描述解题过程中多次重复计算，大大减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p></li><li><p>递归结构</p><ul><li>递归头：什么时候不调用自身方法，没有头 将陷入死循环。</li><li>递归体：什么时候需要调用自身方法。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阶乘 n! n*(n-1)*...*2*1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*f(n-<span class="number">1</span>); <span class="comment">//递归：调用自身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">5</span>)); <span class="comment">//5!= 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ul><li>数组是相同类型数据的有序集合</li><li>数组描述的是相同类型的若干数据，按照一定先后次序排序组合而成</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过下标访问它们</li></ul><h3 id="数组的声明创建"><a href="#数组的声明创建" class="headerlink" title="数组的声明创建"></a>数组的声明创建</h3><ul><li>首先必须声明数组变量，才能在程序中使用数组。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar; <span class="comment">//首选</span></span><br><span class="line">dataType arrayRefVar[]; <span class="comment">//效果相同,但不是首选</span></span><br></pre></td></tr></table></figure><ul><li>Java语言使用new操作符来创建数组，语法如下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize]; <span class="comment">//int[] nums=new int[10]</span></span><br></pre></td></tr></table></figure><ul><li>数组的元素是通过索引访问的，数组索引从0开始</li><li>获取数组长度：arrays.length</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums; <span class="comment">//1.声明一个数组</span></span><br><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//2.创建一个数组</span></span><br><span class="line"><span class="comment">//3.给数组元素赋值</span></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">nums[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">nums[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123; <span class="comment">//打印数组所有元素</span></span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src="https://img-blog.csdnimg.cn/20210427082623150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427082639964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><hr><h3 id="数组的三种初始化"><a href="#数组的三种初始化" class="headerlink" title="数组的三种初始化"></a>数组的三种初始化</h3><ul><li>静态初始化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态初始化：创建+赋值</span></span><br><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans=&#123;<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="number">2</span>,<span class="number">2</span>)&#125;</span><br></pre></td></tr></table></figure><ul><li>动态初始化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含默认初始化</span></span><br><span class="line"><span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">//默认值为0</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>默认初始化<ul><li>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</li></ul></li></ul><h3 id="数组的基本特点"><a href="#数组的基本特点" class="headerlink" title="数组的基本特点"></a>数组的基本特点</h3><ol><li><p>其长度是确定的，数组一旦被创建，它的大小就是不可改变的。</p></li><li><p>其元素必须是相同类型，不允许出现混合类型。</p></li><li><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</p></li><li><p>数组变量属于引用类型，数组也可以看作对象，其中每个元素相当于该对象的成员变量。</p></li><li><p>数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，</p></li><li><p>数组本身是在堆中的。</p></li></ol><h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><p><img src="https://img-blog.csdnimg.cn/20210427082726194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><ul><li>For-Each循环</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//打印全部的数组元素 JDK1.5 没有下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> array : arrays) &#123;</span><br><span class="line">    System.out.println(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组作方法入参</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组作返回值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverse(<span class="type">int</span>[] arrays)&#123;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arrays.length];</span><br><span class="line">    <span class="comment">//反转的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">        result[i] = arrays[arrays.length-i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul><li>多维数组可以看成数组的数组，比如二维数组就是一个特殊的数组，其每一个元素都是一个一维数组。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>]; <span class="comment">//二维数组,三行两列</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210427082746289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//打印二维数组所有元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123; <span class="comment">//arrays.length=3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">        System.out.print(array[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ul><li>数组的工具类java.util.Arrays</li><li>由于数组对象本身并没有什么方法可以供我们使用，但API提供了一个工具类Arrays供我们使用。</li><li>Array类中的方法都是static修饰的静态方法，使用时直接使用类名进行调用，可以不用对象调用。</li><li>常用功能<ul><li>给数组赋值：fill方法。</li><li>排序：sort方法，升序。</li><li>比较数组：equals方法比较数组中元素值是否相等。</li><li>查找数组元素：binarySearch对排序好的数组进行二分查找法操作。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9000</span>,<span class="number">32145</span>,<span class="number">451</span>,<span class="number">21</span>&#125;;</span><br><span class="line">System.out.println(a); <span class="comment">// [I@28d93b30 (hashcode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.toString 打印数组元素</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">//[1, 2, 3, 4, 9000, 32145, 451, 21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法查找某值 返回下标</span></span><br><span class="line">System.out.println(Arrays.binarySearch(a, <span class="number">9000</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">Arrays.fill(a,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>); <span class="comment">//数组[a[2]~a[4])之间填充0</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">//[1, 2, 0, 0, 9000, 32145, 451, 21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//升序排序</span></span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序是八大排序最出名的排序算法。</li><li>代码：两层循环，外层冒泡轮数，里层依次比较。</li><li>当我们看到嵌套循环，应该立马就可以得出这个算法的时间复杂度为O(n2)。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="comment">//1.比较数组中两个相邻的元素，如果第一个数大于第二个数，交换它们位置</span></span><br><span class="line"><span class="comment">//2.每一次比较，都会产生一个最大或最小的数字(升序为最大数)</span></span><br><span class="line"><span class="comment">//3.下一轮则可以少一次排序</span></span><br><span class="line"><span class="comment">//4.依次循环，直到结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//外层循环，次数length-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//内层循环：如果第一个数大于第二个数，交换它们位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp=array[j];</span><br><span class="line">                array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a=&#123;<span class="number">8</span>,<span class="number">1</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">19</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] sort = sort(a);</span><br><span class="line">    System.out.println(Arrays.toString(sort)); <span class="comment">//[-2, 1, 8, 19, 35, 47]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思考：如何优化？</li></ul><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p><img src="https://img-blog.csdnimg.cn/20210427082948815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427083015623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个二维数组 11*11  0：没有棋子，1：黑棋  2：白棋</span></span><br><span class="line"><span class="type">int</span>[][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">array1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">array1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//输出原始的数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;原始的数组：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] array : array1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为稀疏数组保存</span></span><br><span class="line"><span class="comment">//1.有效值的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//有效值总数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建一个稀疏数组</span></span><br><span class="line"><span class="type">int</span>[][] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.遍历二维数组，将有效值存放到稀疏数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array1[i].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            array2[count][<span class="number">0</span>] = i;</span><br><span class="line">            array2[count][<span class="number">1</span>] = j;</span><br><span class="line">            array2[count][<span class="number">2</span>] = array1[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.输出稀疏数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array2[i].length; j++) &#123;</span><br><span class="line">        System.out.print(array2[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">输出原始的数组</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00100000000</span></span><br><span class="line"><span class="comment">00020000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">00000000000</span></span><br><span class="line"><span class="comment">稀疏数组</span></span><br><span class="line"><span class="comment">11112</span></span><br><span class="line"><span class="comment">121</span></span><br><span class="line"><span class="comment">232</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="初识面向对象"><a href="#初识面向对象" class="headerlink" title="初识面向对象"></a>初识面向对象</h3><h4 id="面向过程-amp-面向对象"><a href="#面向过程-amp-面向对象" class="headerlink" title="面向过程&amp;面向对象"></a>面向过程&amp;面向对象</h4><ul><li>面向过程思想<ul><li>步骤清晰简单，第一步做什么，第二部做什么…</li><li>面向过程适合处理一些较为简单的问题</li></ul></li><li>面向对象思想<ul><li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li></ul></li><li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</li></ul><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><ul><li>面向对象编程（Object-Oriented Programming, OOP）</li><li>本质：以类的方式组织代码，以对象的组织(封装)数据。</li><li>抽象</li><li>三大特性<ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li>从认识论的角度考虑是先有对象后有类。对象是具体的事物，类是对象的抽象。</li><li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li></ul><h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><ul><li>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但并不能代表某一个具体的事物。<ul><li>动物、植物、手机、电脑…</li><li>Person类、Pet类、Cat类等，都是用来描述/定义某一具体的事物应该具备的特点和行为。</li></ul></li><li>对象是抽象概念的具体实例，如张三是人的一个具体实例、张三家里的狗旺财就是狗的一个具体实例。</li></ul><h3 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h3><ul><li>使用new来创建对象。</li><li>使用new关键字创建的时候，除了分配内存之外，还会给创建好的对象进行默认的初始化，以及对类中构造器的调用。</li><li>类中的构造器也被称为构造方法，创建对象时必须要调用。有以下特点：</li><li>必须和类的名字相同</li><li>没有返回类型，也不能写void</li><li>一个类即使什么都不写，也会存在一个默认的构造方法</li></ul><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//一个类即使什么都不写，也会存在一个默认的无参构造方法</span></span><br><span class="line">    <span class="comment">//显示地定义构造器</span></span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//作用：1. 使用new关键字，本质是在调用构造器</span></span><br><span class="line">    <span class="comment">//2. 用来初始化对象的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125; <span class="comment">//无参构造</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有参构造 3.一旦定义了有参构造，无参就必须显示定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Alt+insert 快捷键插入构造方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内存分析-1"><a href="#内存分析-1" class="headerlink" title="内存分析"></a>内存分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个宠物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//默认 null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age; <span class="comment">//默认 0</span></span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;叫了一声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用类，创建调用对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>();</span><br><span class="line">    </span><br><span class="line">        dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">        dog.age = <span class="number">3</span>;</span><br><span class="line">        dog.shout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象通过引用类型来操作：栈 - - -&gt;堆</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427083120326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427083125469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p>封装</p><ul><li><p>该露的露，该藏的藏</p><ul><li>我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据细节由自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li></ul></li><li><p>封装（数据的隐藏）</p><ul><li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，称为信息隐藏。</li></ul></li><li><p>作用</p><ol><li><p>提高程序的安全性，保护数据</p></li><li><p>隐藏代码的实现细节</p></li><li><p>统一接口</p></li><li><p>系统可维护性增加了</p></li></ol></li></ul><p><img src="https://img-blog.csdnimg.cn/20210427083157156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>继承的本质是对某一批类的抽象，从而实现对世界更好地建模。</p></li><li><p>extends的意思是”扩展“。子类是父类的扩展，使用关键字extends来表示。</p></li><li><p>Java中类只有单继承，没有多继承！一个类只能继承一个父类。</p></li><li><p>继承是类与类之间的一种关系，此外还有依赖、组合、聚合等。</p></li><li><p>继承关系的两个类，一个为子类（派生类），一个为<strong>父类（基类）</strong>子类继承父类。</p></li><li><p>子类和父类之间，从意义上讲应该具有”is a“的关系。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类(子类)继承 人类(父类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123; <span class="comment">/*Person extends Object*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类继承了父类，就会拥有父类的全部方法，而private私有属性及方法无法继承。</li><li>在Java中，所有类，都默认直接或间接继承Object类 (Ctrl+H 可以查看类关系)</li><li>被final修饰的类，无法被继承（断子绝孙）。</li></ul><h3 id="super-amp-this"><a href="#super-amp-this" class="headerlink" title="super &amp; this"></a>super &amp; this</h3><ol><li>super()调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的方法或构造方法中</li><li>**super()和this()**不能同时调用构造方法，因为this也必须写在第一行</li></ol><ul><li>super与this的区别：super代表父类对象的引用，只能在继承条件下使用；this调用自身对象，没有继承也可以使用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">//隐藏代码，默认调用了父类的无参构造，要写只能写第一行</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210427083247265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427083318162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><ul><li><p>重写：子类的方法必须与父类方法必须一致，方法体不同。</p></li><li><p>重写是方法的重写，与属性无关</p></li><li><p>重写方法只与非静态方法有关，与静态方法无关（静态方法不能被重写）</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123; <span class="comment">//继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方法的调用之和左边定义的类型有关</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.test(); <span class="comment">//打印 A==&gt;test()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类的引用指向了子类，但静态方法没有被重写</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        b.test(); <span class="comment">//打印 B==&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改A.java, B.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//非静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写了B的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类的引用指向了子类</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//子类重写了父类的方法，执行子类的方法</span></span><br><span class="line">b.test(); <span class="comment">//打印变成了 A==&gt;test()</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">静态方法是类的方法，非静态方法是对象的方法</span></span><br><span class="line"><span class="comment">有static时，b调用了B类的方法，因为b是b类定义的</span></span><br><span class="line"><span class="comment">没有static时，b调用的是对象的方法，而b是A类new出来的对象，调用A的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>静态方法属于类，非静态方法属于对象</p></li><li><p>注意点：</p><ol><li><p>方法名、参数列表必须相同</p></li><li><p>修饰符范围可以扩大，不能缩小（public&gt;protect&gt;private）</p></li><li><p>抛出的异常 范围可以被缩小，不能扩大</p></li><li><p>被**static(属于类，不属于实例)，final(常量方法)，private(私有)**修饰的方法不能重写</p></li></ol></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>动态编译：类型</p></li><li><p>即同一方法可以根据发送对象的不同而采用不同的行为方式</p></li><li><p>一个对象的实际类型是确定的，但可以指向对象的引用可以有很多</p></li><li><p>多态存在条件</p><ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/2021042708335834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><ul><li><p>注意点：</p><ul><li><p>多态是方法的多态，没有属性的多态</p></li><li><p>父类和子类，有联系 类型转换异常: ClassCastException</p></li><li><p>存在条件：继承关系，方法需要重写，父类引用指向子类对象！</p></li></ul></li></ul><h3 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h3><ul><li>instanceof 引用类型比较，判断一个对象是什么类型</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object &gt; String</span></span><br><span class="line">    <span class="comment">// Objest &gt; Person &gt; Student</span></span><br><span class="line">    <span class="comment">// Objest &gt; Person &gt; Teacher</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="comment">// X instanceof Y，X引用指向的对象是不是Y的子类</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Student); <span class="comment">//true</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Teacher); <span class="comment">//false</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Object); <span class="comment">//true</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> String); <span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型之间的转化：父-子（高-低）,低可以转换为高</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Syudent</span>(); <span class="comment">//只能用Person方法（重写了用子类重写过的方法）</span></span><br><span class="line">    (Syudent)obj.go(); <span class="comment">//强转之后可以用Student方法(Student-&gt;go())</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型转换</strong></p><ol><li>父类引用指向子类的对象</li><li>把子类转换为父类，向上转型，会丢失自己原来的一些方法</li><li>把父类转换为子类，向下转型，强制转换，才调用子类方法</li><li>方便方法的调用(转型)，减少重复的代码，简洁。</li></ol><p><strong>Static</strong></p><ul><li>静态变量可以直接用类名访问，也称类变量。</li><li>静态变量(或方法)对于类，所有对象（实例）所共享。</li><li>静态区代码 加载类时一起被初始化，最早执行且只执行一次（第一次new）。</li><li>Math-&gt;随机数:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种随机数，不用导包</span></span><br><span class="line">        System.out.println(Math.random()); <span class="comment">//0.7562202902634543</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第二种随机数，静态导入包</span></span><br><span class="line">        System.out.println(random()); <span class="comment">//0.5391606223844663</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类(abstract)</p><ul><li>abstract修饰的类就是抽象类，修饰的方法就是抽象方法。</li><li>抽象类中可以没有抽象方法，但有抽象方法的类一定要声明为抽象类。</li><li>抽象类不能使用new来创建对象，它是用来让子类继承的。</li><li>抽象方法只有方法的声明，没有实现，让其子类实现。</li><li>子类继承抽象类，必须实现抽象类的所有方法，否则该子类也要声明为抽象类。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract 抽象类 类只能单继承（接口可以多继承）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Action</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//约束~有人帮我们实现~</span></span><br><span class="line">    <span class="comment">//抽象方法只有方法名，没有方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.不能new抽象类，只能靠子类去实现它，仅作为一个约束</span></span><br><span class="line">    <span class="comment">//2.抽象方法只能出现在抽象类中，抽象类可以有普通方法</span></span><br><span class="line">    <span class="comment">//3.抽象类有构造器，可以派生子类</span></span><br><span class="line">    <span class="comment">//4.抽象类的意义：约束，提高开发效率。但是类只能单继承，所以有局限 用的不多</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范(抽象方法)都有</li><li>接口：只有规范，没有方法实现，专业的约束！约束与实现分离：面向接口编程~</li><li>接口就是规范，定义的是一组规则，”你是什么…必须做什么…”的思想。</li><li>接口的本质是约束，就像人间法律一样，制定好大家都遵守。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interface接口,接口都要有继承类</span></span><br><span class="line"><span class="comment">//实现类（implements 可以继承多个接口）</span></span><br><span class="line"><span class="comment">//多继承，利用接口实现多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//定义的属性都是常量,默认修饰 public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">99</span>; <span class="comment">//一般不用</span></span><br><span class="line">    <span class="comment">//所有的定义的方法都是抽象的 默认public abstract</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点</p><ul><li>接口没有构造方法，不能被实例化</li><li>实现类必须要重写接口中的方法</li><li>实现类（implements） 可以实现多个接口</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li>内部类就是在一个类的内部再定义一个类，比如A类中定义了一个B类，那么B就是A的内部类，而A相对B来说就是外部类</li></ul><ol><li>成员内部类：可以操作外部类的私有属性及方法</li><li>静态内部类：static修饰，不能访问外部类私有属性</li><li>局部内部类：外部类的方法里定义的类</li><li>匿名内部类：没有名字初始化类</li></ol><p><img src="https://img-blog.csdnimg.cn/20210427083429180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p>软件程序在运行过程中，经常可能遇到异常问题，异常英文(Exception)，意思是例外，这些例外情况需要我们写程序做出合理的处理，而不至于让程序崩溃。</p></li><li><p>异常指程序运行中出现的不期而至的各种状况：文件找不到，网络连接错误，非法参数等。</p></li><li><p>异常发生在程序运行期间，它影响了正常的执行流程。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210427083507444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><ul><li>检查型异常：最具代表性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如用户要打开一个不存在的文件时引发的异常，这些异常在编译时不能被简单地忽略。</li><li>运行时异常：是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时忽略。</li><li>错误Error：错误不是异常，而是脱离程序员控制的问题。错误在代码经常被忽略。例如当栈溢出，一个异常就发生了，它们在编译也检查不到。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427083535592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427083557330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/2021042708360855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p>异常处理机制</p><ul><li>抛出异常</li><li>捕获异常</li><li>异常处理关键字：try、catch、finally、throw、throws</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//try监控区域</span></span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123; <span class="comment">//catch 捕获异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;程序出现异常，变量b不能为0&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123; <span class="comment">//一定会执行，处理善后工作，如关闭资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123; <span class="comment">//抛出异常一般在方法中使用</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(); <span class="comment">//主动抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ctrl+Alt+T 快捷键插入 try-catch</span></span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p><img src="https://img-blog.csdnimg.cn/20210427083645704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/2021042708372149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427083725235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427083739287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a>集合介绍</h3><ul><li><strong>概念</strong>：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</li><li><strong>集合和数组的区别</strong>：</li></ul><ol><li>数组长度固定，集合长度不固定。</li><li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li></ol><ul><li><strong>位置</strong>： java.util.*;</li></ul><h3 id="Collection体系集合"><a href="#Collection体系集合" class="headerlink" title="Collection体系集合"></a><strong>Collection体系集合</strong></h3><hr><p><img src="https://img-blog.csdnimg.cn/img_convert/ec57a697f1c31f2334d78d607d964db7.png"></p><h3 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a><strong>Collection父接口</strong></h3><hr><ul><li><p>特点：代表一组任意类型的对象，无序、无下标、不能重复。</p></li><li><p>Collection集合的方法：</p><ul><li>boolean add(Object obj) //添加一个对象。</li><li>boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</li><li>void clear() //清空此集合中的所有对象。</li><li>boolean contains(Object o) //检查此集合中是否包含o对象。</li><li>boolean equals(Object o) //比较此集合是否与指定对象相等。</li><li>boolean isEmpty() //判断此集合是否为空。</li><li>boolean remove(Object o) //在此集合中移除o对象。</li><li>int size() //返回此集合中的元素个数。</li><li>Object[] toArray() //姜此集合转换成数组。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection接口的使用（一）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        Collection collection=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();        </span><br><span class="line"><span class="comment">//      * 1.添加元素</span></span><br><span class="line">        Collection.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        Collection.add(<span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">        Collection.add(<span class="string">&quot;榴莲&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span>+collection.size());</span><br><span class="line">        System.out.println(collection);</span><br><span class="line"><span class="comment">//      * 2.删除元素</span></span><br><span class="line">        collection.remove(<span class="string">&quot;榴莲&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除之后：&quot;</span>+collection.size());</span><br><span class="line"><span class="comment">//      * 3.遍历元素</span></span><br><span class="line">        <span class="comment">//3.1 使用增强for </span></span><br><span class="line">        <span class="keyword">for</span>(Object object : collection)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 使用迭代器（迭代器专门用来遍历集合的一种方式）</span></span><br><span class="line">        <span class="comment">//hasnext();判断是否有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除当前元素</span></span><br><span class="line">        Iterator iterator=collection.Itertor();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasnext())&#123;</span><br><span class="line">            String object=(String)iterator.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="comment">//删除操作</span></span><br><span class="line">            <span class="comment">//collection.remove(s);引发错误：并发修改异常</span></span><br><span class="line">            <span class="comment">//iterator.remove();应使用迭代器的方法</span></span><br><span class="line"><span class="comment">//      * 4.判断</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;西瓜&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(collection.isEmpty());<span class="comment">//false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection接口的使用（二）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Collection collection=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">//1.添加数据</span></span><br><span class="line">collection.add(s1);</span><br><span class="line">collection.add(s2);</span><br><span class="line">collection.add(s3);</span><br><span class="line"><span class="comment">//collection.add(s3);可重复添加相同对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+collection.size());</span><br><span class="line">System.out.println(collection.toString());</span><br><span class="line"><span class="comment">//2.删除数据</span></span><br><span class="line">collection.remove(s1);</span><br><span class="line">System.out.println(<span class="string">&quot;删除之后：&quot;</span>+collection.size());</span><br><span class="line"><span class="comment">//3.遍历数据</span></span><br><span class="line"><span class="comment">//3.1 增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object object:collection) &#123;</span><br><span class="line">Student student=(Student) object;</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2迭代器</span></span><br><span class="line"><span class="comment">//迭代过程中不能使用collection的删除方法</span></span><br><span class="line">Iterator iterator=collection.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Student student=(Student) iterator.next();</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断和上一块代码类似。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a><strong>Collection子接口</strong></h3><hr><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h4><ul><li><p>特点：有序、有下标、元素可以重复。</p></li><li><p>方法：</p><ul><li>void add(int index,Object o) //在index位置插入对象o。</li><li>boolean addAll(index,Collection c) //将一个集合中的元素添加到此集合中的index位置。</li><li>Object get(int index) //返回集合中指定位置的元素。</li><li>List subList(int fromIndex,int toIndex) //返回fromIndex和toIndex之间的集合元素。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List子接口的使用（一）</span></span><br><span class="line"><span class="comment"> * 特点：1.有序有下标 2.可以重复</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> * 5.获取位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">list.add(<span class="number">0</span>,<span class="string">&quot;yu&quot;</span>);<span class="comment">//插入操作</span></span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+list.size());</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//list.remove(&quot;yu&quot;);结果同上</span></span><br><span class="line">System.out.println(<span class="string">&quot;删除之后：&quot;</span>+list.size());</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line"><span class="comment">//3.遍历元素</span></span><br><span class="line"><span class="comment">//3.1 使用for遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();++i) &#123;</span><br><span class="line">System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 使用增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object object:list) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.3 使用迭代器</span></span><br><span class="line">Iterator iterator=list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.4使用列表迭代器，listIterator可以双向遍历，添加、删除及修改元素。</span></span><br><span class="line">ListIterator listIterator=list.listIterator();</span><br><span class="line"><span class="comment">//从前往后</span></span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">System.out.println(listIterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从后往前（此时“遍历指针”已经指向末尾）</span></span><br><span class="line"><span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">System.out.println(listIterator.previous());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(list.isEmpty());</span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;tang&quot;</span>));</span><br><span class="line"><span class="comment">//5.获取位置</span></span><br><span class="line">System.out.println(list.indexOf(<span class="string">&quot;tang&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List子接口的使用（二）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> * 5.获取位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//1.添加数字数据（自动装箱）</span></span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line">list.add(<span class="number">30</span>);</span><br><span class="line">list.add(<span class="number">40</span>);</span><br><span class="line">list.add(<span class="number">50</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+list.size());</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//list.remove(20);很明显数组越界错误，改成如下</span></span><br><span class="line"><span class="comment">//list.remove(Object(20));</span></span><br><span class="line"><span class="comment">//list.remove(new Integer(20));</span></span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+list.size());</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line"><span class="comment">//3-5不再演示，与之前类似</span></span><br><span class="line"><span class="comment">//6.补充方法subList，返回子集合，含头不含尾</span></span><br><span class="line">List list2=list.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(list2.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a><strong>List实现类</strong></h3><h4 id="ArrayList-重点"><a href="#ArrayList-重点" class="headerlink" title="ArrayList[重点]"></a><strong>ArrayList[重点]</strong></h4><ul><li>数组结构实现，查询块、增删慢；</li><li>JDK1.2版本，运行效率快、线程不安全。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：数组；</span></span><br><span class="line"><span class="comment"> * 特点：查找遍历速度快，增删慢。</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> * 5.查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ArrayList arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;唐&quot;</span>, <span class="number">21</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;何&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;余&quot;</span>, <span class="number">21</span>);</span><br><span class="line">arrayList.add(s1);</span><br><span class="line">arrayList.add(s2);</span><br><span class="line">arrayList.add(s3);</span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+arrayList.size());</span><br><span class="line">System.out.println(arrayList.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">arrayList.remove(s1);</span><br><span class="line"><span class="comment">//arrayList.remove(new Student(&quot;唐&quot;, 21));</span></span><br><span class="line"><span class="comment">//注：这样可以删除吗（不可以）？显然这是两个不同的对象。</span></span><br><span class="line"><span class="comment">//假如两个对象属性相同便认为其是同一对象，那么如何修改代码？</span></span><br><span class="line"><span class="comment">//3.遍历元素</span></span><br><span class="line"><span class="comment">//3.1使用迭代器</span></span><br><span class="line">Iterator iterator=arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2使用列表迭代器</span></span><br><span class="line">ListIterator listIterator=arrayList.listIterator();</span><br><span class="line"><span class="comment">//从前往后遍历</span></span><br><span class="line"><span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">System.out.println(listIterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从后往前遍历</span></span><br><span class="line"><span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">System.out.println(listIterator.previous());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(arrayList.isEmpty());</span><br><span class="line"><span class="comment">//System.out.println(arrayList.contains(new Student(&quot;何&quot;, 22)));</span></span><br><span class="line"><span class="comment">//注：与上文相同的问题。</span></span><br><span class="line"><span class="comment">//5.查找</span></span><br><span class="line">System.out.println(arrayList.indexOf(s1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：Object里的equals(this==obj)用地址和当前对象比较，如果想实现代码中的问题，可以在学生类中重写equals方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="comment">//1.是否为同一对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>==obj) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (obj==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.判断是否是Student类型</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">Student student=(Student) obj;</span><br><span class="line"><span class="comment">//4.比较属性</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.name.equals(student.getName())&amp;&amp;<span class="built_in">this</span>.age==student.age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不满足，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a><strong>ArrayList源码分析</strong></h3><ul><li>默认容量大小：<code>private static final int DEFAULT_CAPACITY = 10;</code></li><li>存放元素的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>：<code>transient Object[] elementData;</code></li><li>实际元素个数：<code>private int size;</code></li><li>创建对象时调用的无参构造函数：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">//这是一个空的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码说明当你没有向集合中添加任何元素时，集合容量为0。那么默认的10个容量怎么来的呢？</p><p>这就得看看add方法的源码了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你new了一个数组，当前容量为0，size当然也为0。这时调用add方法进入到<code>ensureCapacityInternal(size + 1);</code>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中的参数minCapacity传入的值为size+1也就是 1，接着我们再进入到<code>calculateCapacity(elementData, minCapacity)</code>里面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文说过，elementData就是存放元素的数组，当前容量为0，if条件成立，返回默认容量<code>DEFAULT_CAPACITY</code>也就是10。这个值作为参数又传入<code>ensureExplicitCapacity()</code>方法中，进入该方法查看源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不要管modCount这个变量。</p><p>因为elementData数组长度为0，所以if条件成立，调用grow方法，<strong>重要的部分来了</strong>，我们再次进入到grow方法的源码中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法先声明了一个oldCapacity变量将数组长度赋给它，其值为0；又声明了一个newCapacity变量其值为oldCapacity+一个增量，可以发现这个增量是和原数组长度有关的量，当然在这里也为0。第一个if条件满足，newCapacity的值为10（这就是默认的容量，不理解的话再看看前面）。第二个if条件不成立，也可以不用注意，因为MAX_ARRAY_SIZE的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>这个值太大了以至于第二个if条件没有了解的必要。</p><p>最后一句话就是为elementData数组赋予了新的长度，<code>Arrays.copyOf()</code>方法返回的数组是新的数组对象，原数组对象不会改变，该拷贝不会影响原来的数组。<code>copyOf()</code>的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。</p><p>这时候再回到add的方法中，接着就向下执行<code>elementData[size++] = e;</code>到这里为止关于ArrayList就讲解得差不多了，当数组长度为10的时候你们可以试着过一下源码，查一下每次的增量是多少（答案是每次扩容为原来的1.5倍）。</p><hr><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h3><ul><li>数组结构实现，查询快、增删慢；</li><li>JDK1.0版本，运行效率慢、线程安全。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector的演示使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *1.添加数据</span></span><br><span class="line"><span class="comment"> *2.删除数据</span></span><br><span class="line"><span class="comment"> *3.遍历</span></span><br><span class="line"><span class="comment"> *4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Vector vector=<span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//1.添加数据</span></span><br><span class="line">vector.add(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">vector.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">vector.add(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+vector.size());</span><br><span class="line"><span class="comment">//2.删除数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vector.remove(0); vector.remove(&quot;tang&quot;);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//3.遍历</span></span><br><span class="line"><span class="comment">//使用枚举器</span></span><br><span class="line">Enumeration enumeration=vector.elements();</span><br><span class="line"><span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) enumeration.nextElement();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(vector.isEmpty());</span><br><span class="line">System.out.println(vector.contains(<span class="string">&quot;he&quot;</span>));</span><br><span class="line"><span class="comment">//5. Vector其他方法</span></span><br><span class="line"><span class="comment">//firstElement()  lastElement()  ElementAt();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h3><ul><li>链表结构实现，增删快，查询慢。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList的用法</span></span><br><span class="line"><span class="comment"> * 存储结构：双向链表</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">LinkedList linkedList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;唐&quot;</span>, <span class="number">21</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;何&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;余&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">linkedList.add(s1);</span><br><span class="line">linkedList.add(s2);</span><br><span class="line">linkedList.add(s3);</span><br><span class="line">linkedList.add(s3);</span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span>+linkedList.size());</span><br><span class="line">System.out.println(linkedList.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * linkedList.remove(new Student(&quot;唐&quot;, 21));</span></span><br><span class="line"><span class="comment"> * System.out.println(linkedList.toString());</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//3.遍历</span></span><br><span class="line"><span class="comment">//3.1 使用for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;linkedList.size();++i) &#123;</span><br><span class="line">System.out.println(linkedList.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 使用增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object object:linkedList) &#123;</span><br><span class="line">Student student=(Student) object;</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.3 使用迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span>linkedList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) iterator.next();</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.4 使用列表迭代器（略）</span></span><br><span class="line"><span class="comment">//4. 判断</span></span><br><span class="line">System.out.println(linkedList.contains(s1));</span><br><span class="line">System.out.println(linkedList.isEmpty());</span><br><span class="line">System.out.println(linkedList.indexOf(s3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a><strong>LinkedList源码分析</strong></h3><p>LinkedList首先有三个属性：</p><ul><li>链表大小：<code>transient int size = 0;</code></li><li>（指向）第一个结点/头结点：<code>transient Node&lt;E&gt; first;</code></li><li>（指向）最后一个结点/尾结点：<code>transient Node&lt;E&gt; last;</code></li></ul><p>关于Node类型我们再进入到类里看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先item存放的是实际数据；next指向下一个结点而prev指向上一个结点。</p><p>Node带参构造方法的三个参数分别是前一个结点、存储的数据、后一个结点，调用这个构造方法时将它们赋值给当前对象。</p><p>LinkedList是如何添加元素的呢？先看看add方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到linkLast方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYvoid <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设刚开始new了一个LinkedList对象，first和last属性都为空，调用add进入到linkLast方法。</p><p>首先创建一个Node变量 l 将last（此时为空）赋给它，然后new一个newNode变量存储数据，并且它的前驱指向l，后继指向null；再把last指向newNode。如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/ae12bb2d7845cbb64a36735b03690d89.png" alt="img"></p><p>如果满足if条件，说明这是添加的第一个结点，将first指向newNode：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b63e4bdd2f9ab42fcd889ac4641870ab.png" alt="img"></p><p>至此，LinkedList对象的第一个数据添加完毕。假设需要再添加一个数据，我们可以再来走一遍，过程同上不再赘述，图示如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b6f7a151d5812d87ae71c2780fe03e05.png" alt="img"></p><hr><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList和LinkedList区别</strong></h3><ul><li>ArrayList：必须开辟连续空间，查询快，增删慢。</li><li>LinkedList：无需开辟连续空间，查询慢，增删快。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/012adef307ddd114e6947ebc7e39c18b.png" alt="img"></p><hr><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a><strong>泛型概述</strong></h2><ul><li>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。</li><li>常见形式有泛型类、泛型接口、泛型方法。</li><li>语法：<ul><li>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</li></ul></li><li>好处：<ul><li>提高代码的重用性。</li><li>防止类型转换异常，提高代码的安全性。</li></ul></li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类</span></span><br><span class="line"><span class="comment"> * 语法：类名&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myGeneric</span>&lt;T&gt;&#123;</span><br><span class="line"><span class="comment">//1.创建泛型变量</span></span><br><span class="line"><span class="comment">//不能使用new来创建，因为泛型是不确定的类型，也可能拥有私密的构造方法。</span></span><br><span class="line">T t;</span><br><span class="line"><span class="comment">//2.泛型作为方法的参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型作为方法的返回值</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1.泛型只能使用引用类型</span></span><br><span class="line"><span class="comment"> * 2.不同泛型类型的对象不能相互赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testGeneric</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//使用泛型类创建对象</span></span><br><span class="line">myGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> <span class="title class_">myGeneric</span>&lt;String&gt;();</span><br><span class="line">myGeneric1.t=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">myGeneric1.show(<span class="string">&quot;he&quot;</span>);</span><br><span class="line"></span><br><span class="line">myGeneric&lt;Integer&gt; myGeneric2=<span class="keyword">new</span> <span class="title class_">myGeneric</span>&lt;Integer&gt;();</span><br><span class="line">myGeneric2.t=<span class="number">10</span>;</span><br><span class="line">myGeneric2.show(<span class="number">20</span>);</span><br><span class="line">Integer integer=myGeneric2.getT();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a><strong>泛型接口</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口</span></span><br><span class="line"><span class="comment"> * 语法：接口名&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 注意：不能创建泛型静态常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//创建常量</span></span><br><span class="line">String nameString=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    </span><br><span class="line">T <span class="title function_">server</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现接口时确定泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt;&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">server</span><span class="params">(String t)</span> &#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line"><span class="keyword">return</span> t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">//测试</span></span><br><span class="line">MyInterfaceImpl myInterfaceImpl=<span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>();</span><br><span class="line">myInterfaceImpl.server(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//xxx</span></span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现接口时不确定泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt;&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">server</span><span class="params">(T t)</span> &#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">//测试</span></span><br><span class="line">MyInterfaceImpl2&lt;Integer&gt; myInterfaceImpl2=<span class="keyword">new</span> <span class="title class_">MyInterfaceImpl2</span>&lt;Integer&gt;();</span><br><span class="line">myInterfaceImpl2.server(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//2000</span></span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><strong>泛型方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法</span></span><br><span class="line"><span class="comment"> * 语法：&lt;T&gt; 返回类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;泛型方法&quot;</span>+t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">//测试</span></span><br><span class="line">MyGenericMethod myGenericMethod=<span class="keyword">new</span> <span class="title class_">MyGenericMethod</span>();</span><br><span class="line">myGenericMethod.show(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">myGenericMethod.show(<span class="number">200</span>);</span><br><span class="line">myGenericMethod.show(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a><strong>泛型集合</strong></h3><ul><li><p>概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p></li><li><p>特点：</p><ul><li>编译时即可检查，而非运行时抛出异常。</li><li>访问时，不必类型转换（拆箱）。</li><li>不同泛型指尖引用不能相互赋值，泛型不存在多态。</li></ul></li></ul><p>之前我们在创建LinkedList类型对象的时候并没有使用泛型，但是进到它的源码中会发现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;<span class="comment">//略&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Set集合概述"><a href="#Set集合概述" class="headerlink" title="Set集合概述"></a><strong>Set集合概述</strong></h2><h3 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a><strong>Set子接口</strong></h3><ul><li><strong>特点</strong>：无序、无下标、元素不可重复。</li><li><strong>方法</strong>：全部继承自Collection中的方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Set接口的使用</span></span><br><span class="line"><span class="comment"> * 特点：1.无序，没有下标；2.重复</span></span><br><span class="line"><span class="comment"> * 1.添加数据</span></span><br><span class="line"><span class="comment"> * 2.删除数据</span></span><br><span class="line"><span class="comment"> * 3.遍历【重点】</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//1.添加数据</span></span><br><span class="line">set.add(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数据个数：&quot;</span>+set.size());</span><br><span class="line">System.out.println(set.toString());<span class="comment">//无序输出</span></span><br><span class="line"><span class="comment">//2.删除数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set.remove(&quot;tang&quot;); System.out.println(set.toString());</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//3.遍历【重点】</span></span><br><span class="line"><span class="comment">//3.1 使用增强for</span></span><br><span class="line"><span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 使用迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(set.contains(<span class="string">&quot;tang&quot;</span>));</span><br><span class="line">System.out.println(set.isEmpty());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set实现类"><a href="#Set实现类" class="headerlink" title="Set实现类"></a><strong>Set实现类</strong></h2><h3 id="HashSet【重点】"><a href="#HashSet【重点】" class="headerlink" title="HashSet【重点】"></a><strong>HashSet【重点】</strong></h3><ul><li>基于HashCode计算元素存放位置。</li><li>当存入元素的哈希码相同时，会调用equals进行确认，如结果为true，则拒绝后者存入。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Peerson [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet集合的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：哈希表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">HashSet&lt;Person&gt; hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);</span><br><span class="line">Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Person p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">hashSet.add(p1);</span><br><span class="line">hashSet.add(p2);</span><br><span class="line">hashSet.add(p3);</span><br><span class="line">        <span class="comment">//重复，添加失败</span></span><br><span class="line">        hashSet.add(p3);</span><br><span class="line">        <span class="comment">//直接new一个相同属性的对象，依然会被添加，不难理解。</span></span><br><span class="line">        <span class="comment">//假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>));</span><br><span class="line">System.out.println(hashSet.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">hashSet.remove(p2);</span><br><span class="line"><span class="comment">//3.遍历</span></span><br><span class="line"><span class="comment">//3.1 增强for</span></span><br><span class="line"><span class="keyword">for</span> (Person person : hashSet) &#123;</span><br><span class="line">System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 迭代器</span></span><br><span class="line">Iterator&lt;Person&gt; iterator=hashSet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(hashSet.isEmpty());</span><br><span class="line">        <span class="comment">//直接new一个相同属性的对象结果输出是false，不难理解。</span></span><br><span class="line">        <span class="comment">//注：假如相同属性便认为是同一个对象，该怎么做？</span></span><br><span class="line">System.out.println(hashSet.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：hashSet存储过程：</p><ol><li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li><li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li></ol><p>存储过程实际上就是重复依据，要实现“注”里的问题，可以重写hashCode和equals代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    result = prime * result + age;</span><br><span class="line">    result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">if</span> (age != other.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashCode方法里为什么要使用31这个数字大概有两个原因：</p><ol><li>31是一个质数，这样的数字在计算时可以尽量减少散列冲突。</li><li>可以提高执行效率，因为31*i=(i&lt;&lt;5)-i，31乘以一个数可以转换成移位操作，这样能快一点；但是也有网上一些人对这两点提出质疑。</li></ol><hr><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h3><ul><li>基于排序顺序实现不重复。</li><li>实现了SortedSet接口，对集合元素自动排序。</li><li>元素对象的类型必须实现Comparable接口，指定排序规则。</li><li>通过CompareTo方法确定是否为重复元素。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用TreeSet保存数据</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> * 要求：元素类必须实现Comparable接口，compareTo方法返回0，认为是重复元素 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">TreeSet&lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Person&gt;();</span><br><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);</span><br><span class="line">Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Person p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">persons.add(p1);</span><br><span class="line">persons.add(p2);</span><br><span class="line">persons.add(p3);</span><br><span class="line"><span class="comment">//注：直接添加会报类型转换错误，需要实现Comparable接口</span></span><br><span class="line">System.out.println(persons.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">persons.remove(p1);</span><br><span class="line">persons.remove(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>));</span><br><span class="line">System.out.println(persons.toString());</span><br><span class="line"><span class="comment">//3.遍历（略）</span></span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(persons.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Comparable接口的源码，发现只有一个compareTo抽象方法，在人类中实现它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="comment">//1.先按姓名比</span></span><br><span class="line"><span class="comment">//2.再按年龄比</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line"><span class="type">int</span> n1=<span class="built_in">this</span>.getName().compareTo(o.getName());</span><br><span class="line"><span class="type">int</span> n2=<span class="built_in">this</span>.age-o.getAge();</span><br><span class="line"><span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet的使用</span></span><br><span class="line"><span class="comment"> * Comparator：实现定制比较（比较器）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">TreeSet&lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line"><span class="comment">// 先按年龄比较</span></span><br><span class="line"><span class="comment">// 再按姓名比较</span></span><br><span class="line"><span class="type">int</span> n1=o1.getAge()-o2.getAge();</span><br><span class="line"><span class="type">int</span> n2=o1.getName().compareTo(o2.getName());</span><br><span class="line"><span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);</span><br><span class="line">Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">Person p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>);</span><br><span class="line">persons.add(p1);</span><br><span class="line">persons.add(p2);</span><br><span class="line">persons.add(p3);</span><br><span class="line">System.out.println(persons.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来做一个小案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要求：使用TreeSet集合实现字符串按照长度进行排序</span></span><br><span class="line"><span class="comment"> * helloworld tangrui hechengyang wangzixu yuguoming</span></span><br><span class="line"><span class="comment"> * Comparator接口实现定制比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//先比较字符串长度</span></span><br><span class="line"><span class="comment">//再比较字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line"><span class="type">int</span> n1=o1.length()-o2.length();</span><br><span class="line"><span class="type">int</span> n2=o1.compareTo(o2);</span><br><span class="line"><span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeSet.add(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;tangrui&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;hechenyang&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;yuguoming&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;wangzixu&quot;</span>);</span><br><span class="line">System.out.println(treeSet.toString());</span><br><span class="line">        <span class="comment">//输出[tangrui, wangzixu, yuguoming, hechenyang, helloworld]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map集合概述"><a href="#Map集合概述" class="headerlink" title="Map集合概述"></a><strong>Map集合概述</strong></h2><h3 id="Map体系集合"><a href="#Map体系集合" class="headerlink" title="Map体系集合"></a><strong>Map体系集合</strong></h3><ul><li><p>Map接口的特点：</p><ol><li><p>用于存储任意键值对(Key-Value)。    </p></li><li><p>键：无序、无下标、不允许重复（唯一）。</p></li><li><p>值：无序、无下标、允许重复。</p></li></ol></li><li><p>特点：存储一对数据（Key-Value），无序、无下标，键不可重复。</p></li><li><p>方法：</p><ul><li><p>V put(K key,V value)//将对象存入到集合中，关联键值。key重复则覆盖原值。</p></li><li><p>Object get(Object key)//根据键获取相应的值。</p></li><li><p>Set<K>//返回所有的key</p></li><li><p>Collection<V> values()//返回包含所有值的Collection集合。</p></li><li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt;//键值匹配的set集合</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map接口的使用</span></span><br><span class="line"><span class="comment"> * 特点：1.存储键值对 2.键不能重复，值可以重复 3.无序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>);</span><br><span class="line">map.put(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">&quot;fan&quot;</span>, <span class="number">23</span>);</span><br><span class="line">System.out.println(map.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">map.remove(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">System.out.println(map.toString());</span><br><span class="line"><span class="comment">//3.遍历</span></span><br><span class="line"><span class="comment">//3.1 使用keySet();</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">System.out.println(key+<span class="string">&quot; &quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 使用entrySet();效率较高</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Map集合的实现类"><a href="#Map集合的实现类" class="headerlink" title="Map集合的实现类"></a><strong>Map集合的实现类</strong></h3><h3 id="HashMap【重点】"><a href="#HashMap【重点】" class="headerlink" title="HashMap【重点】"></a><strong>HashMap【重点】</strong></h3><ul><li>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 学生类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>();</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HashMap的使用</span></span><br><span class="line"><span class="comment">   * 存储结构：哈希表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  HashMap&lt;Student, String&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student, String&gt;();</span><br><span class="line">  Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tang&quot;</span>, <span class="number">36</span>);</span><br><span class="line">  Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">101</span>);</span><br><span class="line">  Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">//1.添加元素</span></span><br><span class="line">  hashMap.put(s1, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">  hashMap.put(s2, <span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">  hashMap.put(s3, <span class="string">&quot;郑州&quot;</span>);</span><br><span class="line">  <span class="comment">//添加失败，但会更新值</span></span><br><span class="line">  hashMap.put(s3,<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">  <span class="comment">//添加成功，不过两个属性一模一样；</span></span><br><span class="line">  <span class="comment">//注：假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">  hashMap.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>),<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">  System.out.println(hashMap.toString());</span><br><span class="line">  <span class="comment">//2.删除元素</span></span><br><span class="line">  hashMap.remove(s3);</span><br><span class="line">  System.out.println(hashMap.toString());</span><br><span class="line">  <span class="comment">//3.遍历</span></span><br><span class="line">  <span class="comment">//3.1 使用keySet()遍历</span></span><br><span class="line">  <span class="keyword">for</span> (Student key : hashMap.keySet()) &#123;</span><br><span class="line">  System.out.println(key+<span class="string">&quot; &quot;</span>+hashMap.get(key));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.2 使用entrySet()遍历</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Student, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.判断</span></span><br><span class="line">  <span class="comment">//注：同上</span></span><br><span class="line">  System.out.println(hashMap.containsKey(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>)));</span><br><span class="line">  System.out.println(hashMap.containsValue(<span class="string">&quot;成都&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      result = prime * result + id;</span><br><span class="line">      result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">other</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">      <span class="keyword">if</span> (id != other.id)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><ul><li><p>默认初始化容量：static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</p><ul><li>数组最大容量：static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</li></ul></li><li><p>默认加载因子：static final float DEFAULT_LOAD_FACTOR = 0.75f;</p></li><li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：static final int TREEIFY_THRESHOLD = 8;</p></li><li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：static final int UNTREEIFY_THRESHOLD = 6;</p></li><li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：static final int MIN_TREEIFY_CAPACITY = 64;</p></li><li><p>HashMap存储的数组：transient Node&lt;K,V&gt;[] table;</p></li><li><p>HashMap存储的元素个数：transient int size;</p></li></ul><blockquote><ul><li>默认加载因子是什么？<ul><li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素超过了100*0.75=75，那么就会进行扩容。</li></ul></li><li>链表调整为红黑树的链表长度阈值是什么？<ul><li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li></ul></li><li>红黑树调整为链表的链表长度阈值是什么？<ul><li>当红黑树的元素个数小于该阈值时就会转换成链表。</li></ul></li><li>链表调整为红黑树的数组最小阈值是什么？<ul><li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li></ul></li></ul></blockquote><p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYstatic <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p><p>当我们往对象里添加元素时调用put方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                    <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//略</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75=12时，就会进行扩容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>扩容的代码如下（部分）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> newCap;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//略&#125;</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p><p><em>注</em>：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</p><hr><h2 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h2><p>了解完HashMap之后，再回过头来看之前的HashSet源码，为什么放在后面写你们看一下源码就知道了（部分）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">          map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看见HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul><li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p></li><li><p>初始容量11，加载因子0.75。</p></li><li><p>这个集合在开发过程中已经不用了，稍微了解即可。</p></li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li><li>它继承了Hashtable的方法，与流关系密切，此处不详解。</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>实现了SortedMap接口（是Map的子接口），可以对key自动排序。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">TreeMap&lt;Student, Integer&gt; treeMap=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Student, Integer&gt;();</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tang&quot;</span>, <span class="number">36</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">101</span>);</span><br><span class="line">Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">treeMap.put(s1, <span class="number">21</span>);</span><br><span class="line">treeMap.put(s2, <span class="number">22</span>);</span><br><span class="line">treeMap.put(s3, <span class="number">21</span>);</span><br><span class="line"><span class="comment">//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span></span><br><span class="line">System.out.println(treeMap.toString());</span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line">treeMap.remove(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>));</span><br><span class="line">System.out.println(treeMap.toString());</span><br><span class="line"><span class="comment">//3.遍历</span></span><br><span class="line"><span class="comment">//3.1 使用keySet()</span></span><br><span class="line"><span class="keyword">for</span> (Student key : treeMap.keySet()) &#123;</span><br><span class="line">System.out.println(key+<span class="string">&quot; &quot;</span>+treeMap.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 使用entrySet()</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判断</span></span><br><span class="line">System.out.println(treeMap.containsKey(s1));</span><br><span class="line">System.out.println(treeMap.isEmpty());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在学生类中实现Comparable接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.id-o.id;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还可以使用比较器来定制比较：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYTreeMap&lt;Student, Integer&gt; treeMap2=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Student, Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a><strong>TreeSet源码</strong></h2><p>和HashSet类似，放在TreeMap之后讲便一目了然（部分）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p><hr><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><ul><li><p>概念：集合工具类，定义了除了存取以外的集合常用方法。</p></li><li><p>方法：</p><ul><li>public static void reverse(List&lt;?&gt; list)//反转集合中元素的顺序</li><li>public static void shuffle(List&lt;?&gt; list)//随机重置集合元素的顺序</li><li>public static void sort(List<T> list)//升序排序（元素类型必须实现Comparable接口）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Collections工具类的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">30</span>);</span><br><span class="line">list.add(<span class="number">90</span>);</span><br><span class="line">list.add(<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort排序</span></span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//binarySearch二分查找</span></span><br><span class="line"><span class="type">int</span> i=Collections.binarySearch(list, <span class="number">10</span>);</span><br><span class="line">System.out.println(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy复制</span></span><br><span class="line">List&lt;Integer&gt; list2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;<span class="number">5</span>;++i1) &#123;</span><br><span class="line">list2.add(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法要求目标元素容量大于等于源目标</span></span><br><span class="line">Collections.copy(list2, list);</span><br><span class="line">System.out.println(list2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//reserve反转</span></span><br><span class="line">Collections.reverse(list2);</span><br><span class="line">System.out.println(list2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//shuffle 打乱</span></span><br><span class="line">Collections.shuffle(list2);</span><br><span class="line">System.out.println(list2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//补充：list转成数组</span></span><br><span class="line">Integer[] arr=list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr.length);</span><br><span class="line"><span class="comment">//补充：数组转成集合 </span></span><br><span class="line">String[] nameStrings= &#123;<span class="string">&quot;tang&quot;</span>,<span class="string">&quot;he&quot;</span>,<span class="string">&quot;yu&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//受限集合，不能添加和删除</span></span><br><span class="line">List&lt;String&gt; list3=Arrays.asList(nameStrings);</span><br><span class="line">System.out.println(list3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：基本类型转成集合时需要修改为包装类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="IO简介"><a href="#IO简介" class="headerlink" title="IO简介"></a>IO简介</h2><h3 id="流Stream"><a href="#流Stream" class="headerlink" title="流Stream"></a>流<a href="https://so.csdn.net/so/search?q=Stream&spm=1001.2101.3001.7020">Stream</a></h3><p>在学习IO流之前,我们首先需要学习的概念就是Stream流<br>为了方便理解,我们可以把数据的读写操作抽象成数据在”管道”中流动,但需注意:<br>1.流只能单方向流动<br>2.输入流用来读取 → in<br>3.输出流用来写出 → out<br>4.数据只能从头到尾顺序的读写一次<br>所以以程序的角度来思考,In/out 相对于程序而言的输入(读取)/输出(写出)的过程.<br><img src="https://img-blog.csdnimg.cn/20210517222902925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="IO流的继承结构"><a href="#IO流的继承结构" class="headerlink" title="IO流的继承结构"></a>IO流的继承结构</h3><p>在java中,根据处理的数据单位不同,可以把流分为<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E6%B5%81&spm=1001.2101.3001.7020">字节流</a>和字符流<br>字节流 : 针对<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>文件<br><a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81&spm=1001.2101.3001.7020">字符流</a> : 针对文本文件<br>再结合对应类型的输入和输出方向,常用的流有:</p><blockquote><p>File<br>字节流:针对二进制文件<br>InputStream<br>FileInputStream<br>BufferedInputStream<br>ObjectInputStream<br>OutputStream<br>FileOutputStream<br>BufferedOutputStream<br>ObjectOutputStream<br>字符流:针对文本文件<br>Reader<br>FileReader<br>BufferedReader<br>InputStreamReader<br>Writer<br>FileWriter<br>BufferedWriter<br>OutputStreamWriter<br>PrintWriter一行行写出</p></blockquote><h3 id="File文件类"><a href="#File文件类" class="headerlink" title="File文件类"></a>File文件类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>封装一个磁盘路径字符串,对这个路径可以执行一次操作<br>可以封装文件路径、文件夹路径、不存在的路径</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>File(String pathname)通过将给定路径名字符串转换为抽象路径名来创建一个新的File实例<br>new File(“d:/abc/a.txt”);<br>new File(“d:/abc”,”a.txt”);</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://img-blog.csdnimg.cn/20210616175436943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="练习：测试常用方法"><a href="#练习：测试常用方法" class="headerlink" title="练习：测试常用方法"></a>练习：测试常用方法</h4><p>创建包: cn.tedu.file</p><p>创建类: TestFile.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试文件类File*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建File类对象</span></span><br><span class="line">        <span class="comment">/*1.ready目录与1.txt需要自己手动创建</span></span><br><span class="line"><span class="comment">        * 2.File需要导包：import java.io.File;</span></span><br><span class="line"><span class="comment">        * 3.路径是String类型，必须写正确，不然找不到文件</span></span><br><span class="line"><span class="comment">        * 4.完整的文件名包含两部分：文件名+后缀名*/</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1测试File中的常用方法</span></span><br><span class="line">        System.out.println(file.length());<span class="comment">//3，获取文件的字节量</span></span><br><span class="line">        System.out.println(file.exists());<span class="comment">//true,判断文件是否存在</span></span><br><span class="line">        System.out.println(file.isFile());<span class="comment">//true,判断是否为文件</span></span><br><span class="line">        System.out.println(file.isDirectory());<span class="comment">//false，判断是否为文件夹</span></span><br><span class="line">        System.out.println(file.getName());<span class="comment">//1.txt获取文件名</span></span><br><span class="line">        System.out.println(file.getParent());<span class="comment">//E:\ready 获取父级路径</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());<span class="comment">//E:\ready\1.txt 获取带盘符的完整路径：绝对路径</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.2 测试创建与删除</span></span><br><span class="line">        <span class="comment">/*new 只会帮你在内存中创建一个File类型的对象</span></span><br><span class="line"><span class="comment">        * 并不会帮你在磁盘中创建一个真实存在的2.txt文件*/</span></span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建一个之前不存在的文件2.txt,如果创建成功，会返回true</span></span><br><span class="line">        <span class="comment">/*如果指定创建文件的路径不对，会抛出异常：java.io.Exception</span></span><br><span class="line"><span class="comment">        * 所以需要提前处理这个问题，我们暂时选择在main()上抛出</span></span><br><span class="line"><span class="comment">        * 这个IO异常是目前我们遇到的强制要求必须预先处理的异常</span></span><br><span class="line"><span class="comment">        * 如果不处理，方法的调用会报错，通不过编译*/</span></span><br><span class="line">        System.out.println(file.createNewFile());<span class="comment">//创建之前不存在的文件</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\m&quot;</span>);</span><br><span class="line">        System.out.println(file.mkdir());<span class="comment">//创建之前不存在的单层文件夹</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\a\\b\\c&quot;</span>);</span><br><span class="line">        System.out.println(file.mkdirs());<span class="comment">//创建之前不存在的多层文件夹</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(file.delete());<span class="comment">//c被删除，删除空文件夹或者文件</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\a&quot;</span>);</span><br><span class="line">        System.out.println(file.delete());<span class="comment">//false,a文件夹不是空的，里面有内容</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>);</span><br><span class="line">        System.out.println(file.delete());<span class="comment">//2.txt被删除，可以删除文件</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.3测试展示文件列表</span></span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready&quot;</span>);</span><br><span class="line">        String[] list = file.list();<span class="comment">/*不常用*/</span></span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">        <span class="comment">//这句话会报错，因为这是一个String[],所以数组中每个元素都是String类型的</span></span><br><span class="line">        <span class="comment">//那么只能用String类中的方法，而isDirectory()是File类中的方法</span></span><br><span class="line">        <span class="comment">//System.out.println(list[0].isDirectory());</span></span><br><span class="line">    </span><br><span class="line">        File[] fs = file.listFiles();<span class="comment">/*常用*/</span></span><br><span class="line">        System.out.println(Arrays.toString(fs));</span><br><span class="line">        System.out.println(fs[<span class="number">0</span>].isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节流读取"><a href="#字节流读取" class="headerlink" title="字节流读取"></a>字节流读取</h3><p>字节流是由字节组成的,字符流是由字符组成的.<br>Java里字符由两个字节组成.字节流是基本流，主要用在处理二进制数据。<br>所以字节流是比较常用的，可以可以处理多种不同种类的文件，比如文本文档/音频/视频等等</p><h4 id="InputStream抽象类"><a href="#InputStream抽象类" class="headerlink" title="InputStream抽象类"></a>InputStream抽象类</h4><p>此抽象类是表示字节输入流的所有类的超类/抽象类,不可创建对象哦</p><blockquote><p>常用方法：<br>abstract int read() 从输入流中读取数据的下一个字节<br>int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中<br>int read(byte[] b, int off, int len) 将输入流中最多 len 个数据字节读入 byte 数组,off表示存时的偏移量<br>void close() 关闭此输入流并释放与该流关联的所有系统资源</p></blockquote><h4 id="FileInputStream子类"><a href="#FileInputStream子类" class="headerlink" title="FileInputStream子类"></a>FileInputStream子类</h4><p>直接插在文件上，直接读取文件数据</p><blockquote><p>创建对象<br>FileInputStream(File file)—直接传文件对象<br>通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定FileInputStream(String pathname)—传路径<br>通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定</p></blockquote><h4 id="BufferedInputStream子类"><a href="#BufferedInputStream子类" class="headerlink" title="BufferedInputStream子类"></a>BufferedInputStream子类</h4><p>BufferedInputStream 为另一个输入流添加一些功能，在创建BufferedInputStream 时，会创建一个内部缓冲区数组(默认8k大小)。在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。</p><blockquote><p>创建对象<br>BufferedInputStream(InputStream in)<br>创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</p></blockquote><h4 id="字节流读取案例"><a href="#字节流读取案例" class="headerlink" title="字节流读取案例"></a>字节流读取案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">练习：字节流读取案例</span><br><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestIn.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于练习字节输入流*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//method();//字节流的读取</span></span><br><span class="line">        method2();<span class="comment">//高效字节流的读取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本方法用于测试高效字节流的读取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个在本方法中都生效的局部变量in,注意手动初始化，值为null</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建高效字节输入流对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            InputStream in = new BufferedInputStream(</span></span><br><span class="line"><span class="comment">//                    new FileInputStream(new File(&quot;E:\\ready\\1.txt&quot;)));</span></span><br><span class="line">              in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span></span><br><span class="line">                      (<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.使用流进行读取</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b= in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流操作写在finally&#123;&#125;中</span></span><br><span class="line">            <span class="comment">//3.流用完以后一定要关闭！！！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本方法用于测试字节流的读取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个在本方法都生效的局部变量注意手动初始化</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建字节输入流对象用于读取</span></span><br><span class="line">        <span class="comment">//InputStream in = new InputStream();//报错原因：抽象类不可实例化</span></span><br><span class="line">        <span class="comment">//InputStream in = new FileInputStream(new File(&quot;E:\\ready\\1.txt&quot;));</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.开始读取</span></span><br><span class="line">        <span class="comment">/*read()每次调用都会读取一个字节，如果读到了数据的末尾，返回-1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line">            <span class="comment">//需求：需要循环读取文件中的所有内容，直至读完</span></span><br><span class="line">            <span class="comment">//定义变量，记录读到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span>((b=in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();<span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="comment">/*try-catch结构中的第三个部分：finally&#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这部分不论是否捕获到异常，是一定会被执行到的代码，常用于关流*/</span></span><br><span class="line">ally &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//3.释放资源，流资源用完必须释放！！！</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流读取"><a href="#字符流读取" class="headerlink" title="字符流读取"></a>字符流读取</h3><p>常用于处理纯文本数据,读写容易出现乱码的现象,在读写时,最好指定编码集为UTF-8</p><h4 id="Reader抽象类"><a href="#Reader抽象类" class="headerlink" title="Reader抽象类"></a>Reader抽象类</h4><p>用于读取字符流的抽象类。</p><blockquote><p>常用方法：<br>int read() 读取单个字符<br>int read(char[] cbuf) 将字符读入数组<br>abstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分<br>int read(CharBuffer target) 试图将字符读入指定的字符缓冲区<br>abstract void close() 关闭该流并释放与之关联的所有资源</p></blockquote><h4 id="FileReader子类"><a href="#FileReader子类" class="headerlink" title="FileReader子类"></a>FileReader子类</h4><p>用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。</p><blockquote><p>创建对象<br>FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader<br>FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader</p></blockquote><h4 id="BufferedReader子类"><a href="#BufferedReader子类" class="headerlink" title="BufferedReader子类"></a>BufferedReader子类</h4><p>从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。<br>可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。</p><blockquote><p>创建对象<br>BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流</p></blockquote><h4 id="练习：字符流读取案例"><a href="#练习：字符流读取案例" class="headerlink" title="练习：字符流读取案例"></a>练习：字符流读取案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestIn2.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试字符流的读取*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIn2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//method();//测试普通字符输入流</span></span><br><span class="line">        method2();<span class="comment">//测试高效字符输入流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试高效字符输入流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个在本方法都生效的局部变量，手动初始化值null</span></span><br><span class="line">        Reader in=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.创建高效字符读取流对象</span></span><br><span class="line">            <span class="comment">//in = new BufferedReader(new FileReader(new File(&quot;E:\\ready\\1.txt&quot;)));</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.使用流对象</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.关闭流对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试普通字符输入流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.1创建一个在本方法中都生效的局部变量，注意初始化值null</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.2创建字符输入流对象，注意需要捕获异常</span></span><br><span class="line">            <span class="comment">//Reader in = new Reader();//报错原因：抽象父级不可实例化</span></span><br><span class="line">            <span class="comment">//in = new FileReader(new File(&quot;E:\\ready\\1.txt&quot;));</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.使用流对象</span></span><br><span class="line">            <span class="comment">//System.out.println(in.read());</span></span><br><span class="line">            <span class="comment">//需求：循环读取文件中的所有内容，只要不是-1，就说明还有数据，继续读取</span></span><br><span class="line">            <span class="comment">//3.1定义变量，记录读取到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span>((b = in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//3.关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节流写出"><a href="#字节流写出" class="headerlink" title="字节流写出"></a>字节流写出</h3><h4 id="OutputStream抽象类"><a href="#OutputStream抽象类" class="headerlink" title="OutputStream抽象类"></a>OutputStream抽象类</h4><p>此抽象类是表示输出字节流的所有类的超类.输出流接受输出字节并将这些字节发送到某个接收器.</p><blockquote><p>常用方法:<br>Void close() 关闭此输出流并释放与此流相关的所有系统资源<br>Void flush() 刷新此输出流并强制写出所有缓冲的输出字节<br>Void write(byte[ ] b) 将b.length个字节从指定的byte数组写入此输出流<br>Void write(byte[ ] b,int off ,int len) 将指定byte数组中从偏移量off开始的len个字节写入输出流<br>Abstract void write(int b) 将指定的字节写入此输出流</p></blockquote><h4 id="FileOutputStream-子类"><a href="#FileOutputStream-子类" class="headerlink" title="FileOutputStream 子类"></a>FileOutputStream 子类</h4><p>直接插在文件上,直接写出文件数据</p><blockquote><p>构造方法(创建对象):<br>FileOutputStream(String name)<br>创建一个向具有指定名称的文件中写入数据的文件输出流<br>FileOutStream(File file)<br>创建一个向指定File对象表示的文件中写入数据的文件输出流<br>FileOutStream(File file,boolean append)—如果第二个参数为true,表示追加,不覆盖<br>创建一个向指定File对象表示的文件中写入数据的文件输出流,后面的参数是指是否覆盖原文件内容</p></blockquote><h4 id="BufferedOutputstream-子类"><a href="#BufferedOutputstream-子类" class="headerlink" title="BufferedOutputstream 子类"></a>BufferedOutputstream 子类</h4><p>该类实现缓冲的输出流,通过设置这种输出流,应用程序就可以将各个字节写入底层输出流中,而不必每次针对字节写出调用底层系统</p><blockquote><p>构造方法(创建对象):<br>BufferedOutputStream(OutputStream out)<br>创建一个新的缓冲输出流,用以将数据写入指定的底层输出流</p></blockquote><h4 id="练习-字节输出流测试"><a href="#练习-字节输出流测试" class="headerlink" title="练习: 字节输出流测试:"></a>练习: 字节输出流测试:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestOut.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试字节输出流*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method();<span class="comment">//用于测试普通字节输出流</span></span><br><span class="line">        <span class="comment">//method2();//用于测试高效字节输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试高效字节输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法都生效的局部变量，注意手动初始化</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//2.创建高效字节输出流对象</span></span><br><span class="line"><span class="comment">//          out = new BufferedOutputStream(new FileOutputStream(new File(&quot;E:\\ready\\2.txt&quot;)));</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//3.使用流对象--进行写出操作</span></span><br><span class="line">            out.write(<span class="number">97</span>);</span><br><span class="line">            out.write(<span class="number">97</span>);</span><br><span class="line">            out.write(<span class="number">97</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流操作要放在finally&#123;&#125;中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.关流</span></span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试普通字节输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法中都生效的局部变量，注意手动初始化null</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.创建try-catch-finally结构，因为IO操作可能会产生异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.创建普通字节输出流对象</span></span><br><span class="line">            <span class="comment">//out = new FileOutputStream(new File(&quot;E:\\ready\\2.txt&quot;));</span></span><br><span class="line">            <span class="comment">//out = new FileOutputStream(&quot;E:\\ready\\2.txt&quot;);</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.使用流对象--进行写出操作</span></span><br><span class="line">            out.write(<span class="number">99</span>);<span class="comment">//对应ASCII码表中的a</span></span><br><span class="line">            out.write(<span class="number">99</span>);<span class="comment">//对应ASCII码表中的b</span></span><br><span class="line">            out.write(<span class="number">99</span>);<span class="comment">//对应ASCII码表中的c</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//如果想要代码一定会执行，需要写在finally中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//5.关流操作</span></span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流写出"><a href="#字符流写出" class="headerlink" title="字符流写出"></a>字符流写出</h3><h4 id="Writer-抽象类"><a href="#Writer-抽象类" class="headerlink" title="Writer 抽象类"></a>Writer 抽象类</h4><p>写入字符流的抽象类</p><blockquote><p>常用方法:<br>Abstract void close() 关闭此流,但要先刷新它<br>Void write(char[ ] cbuf) 写入字符数组<br>Void write(int c) 写入单个字符<br>Void write(String str) 写入字符串<br>Void write(String str,int off,int len) 写入字符串的某一部分<br>Abstract void write(char[] cbuf,int off,int len)写入字符数组的某一部分</p></blockquote><h4 id="FileWriter-子类"><a href="#FileWriter-子类" class="headerlink" title="FileWriter 子类"></a>FileWriter 子类</h4><p>用来写入字符文件的便捷类,此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的.如果需要自己自定义这些值,可以先在FileOutputStream上构造一个OutputStreamWriter.</p><blockquote><p>构造方法(创建对象):<br>FileWriter(String filename)<br>根据给定的文件名构造一个FileWriter对象<br>FileWriter(String filename,boolean append)<br>根据给定的文件名以及指示是否附加写入数据的boolean值来构造FileWriter</p></blockquote><h4 id="BufferedWriter子类"><a href="#BufferedWriter子类" class="headerlink" title="BufferedWriter子类"></a>BufferedWriter子类</h4><p>将文本写入字符输出流,缓冲各个字符,从而提供单个字符,数组和字符串的高效写入.可以指定缓冲区的大小,或者接受默认的大小,在大多数情况下,默认值就足够大了</p><blockquote><p>构造方法(创建对象):<br>BufferedWriter(Writer out)<br>创建一个使用默认大小输出缓冲区的缓冲字符输出流</p></blockquote><h4 id="练习-字符输出流测试"><a href="#练习-字符输出流测试" class="headerlink" title="练习: 字符输出流测试:"></a>练习: 字符输出流测试:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestOut2.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试字符输出流*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOut2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//method();//用于测试普通字符输出流</span></span><br><span class="line">        method2();<span class="comment">//用于测试高效字符输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试高效字符输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法都生效的局部变量，值为null,注意手动初始化！！！</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于程序可能会抛出异常，所以需要写一个try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//存放可能会抛出异常的代码</span></span><br><span class="line">            <span class="comment">//3.创建普通字符输出流对象</span></span><br><span class="line">            <span class="comment">//out = new BufferedWriter(new FileWriter(new File(&quot;E:\\ready\\2.txt&quot;)));</span></span><br><span class="line">            <span class="comment">//out = new BufferedWriter(new FileWriter(&quot;E:\\ready\\2.txt&quot;));</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">            <span class="comment">//4.使用流对象</span></span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;<span class="comment">//匹配并捕获异常</span></span><br><span class="line">            e.printStackTrace();<span class="comment">//如果捕获到异常就打印错误信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//一定会被执行到的代码块，常用于关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试普通字符输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法都生效的局部变量，值为null,注意手动初始化！！！</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于程序可能会抛出异常，所以需要写一个try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//存放可能会抛出异常的代码</span></span><br><span class="line">            <span class="comment">//3.创建普通字符输出流对象</span></span><br><span class="line">            <span class="comment">//out = new FileWriter(new File(&quot;E:\\ready\\2.txt&quot;));</span></span><br><span class="line">            <span class="comment">//out = new FileWriter(&quot;E:\\ready\\2.txt&quot;);</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.使用流对象</span></span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;<span class="comment">//匹配并捕获异常</span></span><br><span class="line">            e.printStackTrace();<span class="comment">//如果捕获到异常就打印错误信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//一定会被执行到的代码块，常用于关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>通过学习以上的几种流,我们也可以拓展尝试做下文件的复制:<br>创建包: cn.tedu.file<br>创建类: TestCopyFile.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于练习文件复制综合案例*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCopyFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.提示并接收用户输入的两个路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入源文件路径&quot;</span>);<span class="comment">//--被复制的那个文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入新文件路径：&quot;</span>);<span class="comment">//--复制好的新文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用创建好的自定义方法完成文件复制</span></span><br><span class="line">        <span class="comment">//ZFCopy(f,t);//用字符流完成文件的复制案例</span></span><br><span class="line">        ZJCopy(f,t);<span class="comment">//用字节流完成文件的复制案例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用字节流完成文件复制案例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZJCopy</span><span class="params">(String f, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义在整个方法都生效的局部变量，注意手动初始化，引用类型默认值为null</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于代码可能会发生异常，所以需要编写try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.1创建高效字节输入流对象--FIS的参数是用户传入的源文件路径f</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f));</span><br><span class="line">            <span class="comment">//3.2创建高效字节输出流对象--FOS的参数是用户传入的新文件路径t</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(t));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.利用创建好的流对象完成业务</span></span><br><span class="line">            <span class="comment">//4.1定义变量用来保存读到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="comment">//4.2循环读取源文件中的数据，只要不是-1，说明还有数据循环继续</span></span><br><span class="line">            <span class="keyword">while</span>((b = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//4.3将读到的数据写入到新文件中</span></span><br><span class="line">                out.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜您！文件复制成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很抱歉！文件复制失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用字符流完成文件复制案例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZFCopy</span><span class="params">(String f, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义在整个方法中都生效的局部变量，注意手动初始化，默认值为null</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于代码可能会发生异常，所以需要编写try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.1创建高效字符输入流对象</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(f));</span><br><span class="line">            <span class="comment">//3.2创建高效字符输出流对象</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(t));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.拿到流对象以后，就可以使用流对象来完成业务了</span></span><br><span class="line">            <span class="comment">//4.1定义变量用来保存读到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="comment">//4.2循环读取源文件，直到返回值为-1，说明没有数据了，再结束循环</span></span><br><span class="line">            <span class="keyword">while</span> ((b=in.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//4.3将本轮循环中读到的数据写入到新文件中</span></span><br><span class="line">                out.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜您！文件复制成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很抱歉！文件复制失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*关流是有顺序的：如果有多个流，最后创建的流最先关闭</span></span><br><span class="line"><span class="comment">            * 多条关流语句需要各自try-catch*/</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-IO的继承结构"><a href="#总结-IO的继承结构" class="headerlink" title="总结:IO的继承结构"></a>总结:IO的继承结构</h3><p>主流分类</p><ol><li>按照方向进行分类:输入流 输出流(相对于程序而言,从程序写数据到文件中是输出)</li><li>按照传输类型进行分类:字节流 字符流</li><li>组合: 字节输入流 字节输出流 字符输入流 字符输出流</li></ol><p>学习方法:在抽象父类中学习通用的方法,在子类中学习如何创建对象</p><h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流:"></a>字节输入流:</h4><p><code>InputStream 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileInputStream 子类,操作文件的字节输入流,普通类</span><br><span class="line">--BufferedInputStream 子类,缓冲字节输入流,普通类</span><br></pre></td></tr></table></figure><h4 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h4><p><code>Reader 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileReader,子类,操作文件的字符输入流,普通类</span><br><span class="line">--BufferedReader,子类,缓冲字符输入流,普通类</span><br></pre></td></tr></table></figure><h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流:"></a>字节输出流:</h4><p><code>OutputStream 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileOutputStream 子类,操作文件的字节输出流,普通类</span><br><span class="line">--BufferedOutputStream 子类,缓冲字节输出流,普通类</span><br></pre></td></tr></table></figure><h4 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h4><p><code>Writer 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileWriter,子类,操作文件的字符输出流,普通类</span><br><span class="line">--BufferedWriter,子类,缓冲字符输出流,普通类</span><br></pre></td></tr></table></figure><hr><h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><h3 id="反射机制有什么用？"><a href="#反射机制有什么用？" class="headerlink" title="反射机制有什么用？"></a><a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%B0%84&spm=1001.2101.3001.7020">反射</a>机制有什么用？</h3><p>通过java语言中的反射机制可以操作字节码文件（可以读和修改<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>文件。）<br>通过反射机制可以操作代码片段。（class文件。）</p><h3 id="反射机制的相关类在哪个包下？"><a href="#反射机制的相关类在哪个包下？" class="headerlink" title="反射机制的相关类在哪个包下？"></a>反射机制的相关类在哪个包下？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.*;</span><br></pre></td></tr></table></figure><h3 id="反射机制相关的重要的类有哪些？"><a href="#反射机制相关的重要的类有哪些？" class="headerlink" title="反射机制相关的重要的类有哪些？"></a>反射机制相关的重要的类有哪些？</h3><table><thead><tr><th align="left">类</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td align="left">java.lang.Class</td><td>代表整个字节码。代表一个类型，代表整个类。</td></tr><tr><td align="left">java.lang.reflect.Method</td><td>代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td align="left">java.lang.reflect.Constructor</td><td>代表字节码中的构造方法字节码。代表类中的构造方法。</td></tr><tr><td align="left">ava.lang.reflect.Field</td><td>代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><p><strong>注</strong>：<strong>必须先获得Class才能获取Method、Constructor、Field</strong>。</p><p><strong>eg.</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Class:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="comment">// Field</span></span><br><span class="line"><span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取Class的三方式"><a href="#获取Class的三方式" class="headerlink" title="获取Class的三方式"></a>获取Class的三方式</h3><p>要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？</p><table><thead><tr><th align="center"><strong>方式</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">Class.forName(“完整类名带包名”)</td><td>静态方法</td></tr><tr><td align="center">对象.getClass()</td><td></td></tr><tr><td align="center">任何类型.class</td><td></td></tr></tbody></table><p>注：以上三种方式返回值都是<strong>Class类型</strong>。</p><h3 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象.newInstance()</span><br></pre></td></tr></table></figure><p><strong>注</strong>：newInstance()方法内部实际上调用了<strong>无参数构造方法</strong>，必须保证无参构造存在才可以。<br>否则会抛出<code>java.lang.InstantiationException</code>异常。</p><p><strong>eg.</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 下面这段代码是以反射机制的方式创建对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射机制，获取Class，通过Class来实例化对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.User&quot;</span>);</span><br><span class="line">        <span class="comment">// newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。</span></span><br><span class="line">        <span class="comment">// 重点是：newInstance()调用的是无参构造，必须保证无参构造是存在的！</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC重点-Class-forName导致类加载"><a href="#JDBC重点-Class-forName导致类加载" class="headerlink" title="JDBC重点(Class.forName导致类加载)"></a>JDBC重点(Class.forName导致类加载)</h3><p>如果你只是希望一个类的<strong>静态代码块</strong>执行，其它代码一律不执行，可以使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;完整类名&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个方法的执行会导致<strong>类加载</strong>，类加载时，静态代码块执行。</p><h3 id="反射Filed【反射-反编译一个类的属性】"><a href="#反射Filed【反射-反编译一个类的属性】" class="headerlink" title="反射Filed【反射/反编译一个类的属性】"></a>反射Filed【反射/反编译一个类的属性】</h3><h4 id="Class类方法"><a href="#Class类方法" class="headerlink" title="Class类方法"></a>Class类方法</h4><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="center"><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">public T <strong>newInstance</strong>()</td><td align="center">创建对象</td></tr><tr><td align="center">public String <strong>getName</strong>()</td><td align="center">返回完整类名带包名</td></tr><tr><td align="center">public String <strong>getSimpleName</strong>()</td><td align="center">返回类名</td></tr><tr><td align="center">public Field[] <strong>getFields</strong>()</td><td align="center">返回类中public修饰的属性</td></tr><tr><td align="center">public Field[] <strong>getDeclaredFields</strong>()</td><td align="center">返回类中所有的属性</td></tr><tr><td align="center">public Field <strong>getDeclaredField</strong>(String name)</td><td align="center">根据属性名name获取指定的属性</td></tr><tr><td align="center">public native int <strong>getModifiers</strong>()</td><td align="center">获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td align="center">public Method[] <strong>getDeclaredMethods</strong>()</td><td align="center">返回类中所有的实例方法</td></tr><tr><td align="center">public Method <strong>getDeclaredMethod</strong>(String name, Class&lt;?&gt;… parameterTypes)</td><td align="center">根据方法名name和方法形参获取指定方法</td></tr><tr><td align="center">public Constructor&lt;?&gt;[] <strong>getDeclaredConstructors</strong>()</td><td align="center">返回类中所有的构造方法</td></tr><tr><td align="center">public Constructor <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;… parameterTypes)</td><td align="center">根据方法形参获取指定的构造方法</td></tr><tr><td align="center">-—</td><td align="center">-—</td></tr><tr><td align="center">public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</td><td align="center">回调用类的父类</td></tr><tr><td align="center">public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</td><td align="center">返回调用类实现的接口集合</td></tr></tbody></table><h4 id="Field类方法"><a href="#Field类方法" class="headerlink" title="Field类方法"></a>Field类方法</h4><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="center"><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">public String <strong>getName</strong>()</td><td align="center">返回属性名</td></tr><tr><td align="center">public int <strong>getModifiers</strong>()</td><td align="center">获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td align="center">public Class&lt;?&gt; <strong>getType</strong>()</td><td align="center">以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td align="center">public void <strong>set</strong>(Object obj, Object value)</td><td align="center">设置属性值</td></tr><tr><td align="center">public Object <strong>get</strong>(Object obj)</td><td align="center">读取属性值</td></tr></tbody></table><h4 id="eg-反编译一个类的属性Field"><a href="#eg-反编译一个类的属性Field" class="headerlink" title="eg.反编译一个类的属性Field"></a>eg.反编译一个类的属性Field</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射机制，反编译一个类的属性Field（了解一下）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Student&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers()) + <span class="string">&quot; class &quot;</span> + studentClass.getSimpleName() + <span class="string">&quot; &#123;\n&quot;</span>);<span class="comment">// Class类的getName方法</span></span><br><span class="line">        <span class="comment">//获取所有的属性</span></span><br><span class="line">        Field[] fields = studentClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号</span></span><br><span class="line">            <span class="comment">// 用Modifier类的toString转换成字符串</span></span><br><span class="line">            s.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">            <span class="keyword">if</span> (f.getModifiers() != <span class="number">0</span>) s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getType().getSimpleName());<span class="comment">// 获取属性的类型</span></span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getName());<span class="comment">// 获取属性的名字</span></span><br><span class="line">            s.append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给属性赋值三要素"><a href="#给属性赋值三要素" class="headerlink" title="给属性赋值三要素"></a>给属性赋值三要素</h3><p><strong>eg.</strong> 给s对象的no属性赋值1111</p><ul><li>要素1：<strong>对象</strong> s</li><li>要素2：no <strong>属性</strong></li><li>要素3：1111 <strong>值</strong></li></ul><h3 id="读属性值两个要素"><a href="#读属性值两个要素" class="headerlink" title="读属性值两个要素"></a>读属性值两个要素</h3><p><strong>eg.</strong> 获取s对象的no属性的值</p><ul><li>要素1：<strong>对象</strong> s</li><li>要素2：no<strong>属性</strong></li></ul><hr><p><strong>注：</strong> Field类中set()、get()使用注意事项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">属性.set(对象, 值);</span><br><span class="line"></span><br><span class="line">属性.get(对象);</span><br></pre></td></tr></table></figure><h4 id="eg-★通过反射机制访问一个java对象的属性"><a href="#eg-★通过反射机制访问一个java对象的属性" class="headerlink" title="eg.★通过反射机制访问一个java对象的属性"></a>eg.★通过反射机制访问一个java对象的属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">必须掌握：</span></span><br><span class="line"><span class="comment">    怎么通过反射机制访问一个java对象的属性？</span></span><br><span class="line"><span class="comment">        给属性赋值set</span></span><br><span class="line"><span class="comment">        获取属性的值get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest07</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//不使用反射机制给属性赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">/**给属性赋值三要素：给s对象的no属性赋值1111</span></span><br><span class="line"><span class="comment">         * 要素1：对象s</span></span><br><span class="line"><span class="comment">         * 要素2：no属性</span></span><br><span class="line"><span class="comment">         * 要素3：1111</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        student.no = <span class="number">1111</span>;</span><br><span class="line">        <span class="comment">/**读属性值两个要素：获取s对象的no属性的值。</span></span><br><span class="line"><span class="comment">         * 要素1：对象s</span></span><br><span class="line"><span class="comment">         * 要素2：no属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(student.no);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制给属性赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Student&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance();<span class="comment">// obj就是Student对象。（底层调用无参数构造方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取no属性（根据属性的名称来获取Field）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">// 给obj对象(Student对象)的no属性赋值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            虽然使用了反射机制，但是三要素还是缺一不可：</span></span><br><span class="line"><span class="comment">                要素1：obj对象</span></span><br><span class="line"><span class="comment">                要素2：no属性</span></span><br><span class="line"><span class="comment">                要素3：22222值</span></span><br><span class="line"><span class="comment">            注意：反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        noField.set(obj, <span class="number">22222</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        <span class="comment">// 两个要素：获取obj对象的no属性的值。</span></span><br><span class="line">        System.out.println(noField.get(obj));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="set-可以访问私有属性嘛？"><a href="#set-可以访问私有属性嘛？" class="headerlink" title="set()可以访问私有属性嘛？"></a>set()可以访问私有属性嘛？</h3><p>不可以，需要打破封装，才可以。</p><h4 id="Fidle方法："><a href="#Fidle方法：" class="headerlink" title="Fidle方法："></a><strong>Fidle方法：</strong></h4><table><thead><tr><th align="center"><strong>方法</strong></th><th align="center"><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">public void <strong>setAccessible</strong>(boolean flag)</td><td align="center">默认false，设置为true为打破封装</td></tr></tbody></table><p><strong>eg.</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以访问私有的属性吗？</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）</span></span><br><span class="line"><span class="comment">// 这样设置完之后，在外部也是可以访问private的。</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 给name属性赋值</span></span><br><span class="line">nameField.set(obj, <span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line"><span class="comment">// 获取name属性的值</span></span><br><span class="line">System.out.println(nameField.get(obj));</span><br></pre></td></tr></table></figure><h3 id="反射Method【反射-反编译一个类的方法】"><a href="#反射Method【反射-反编译一个类的方法】" class="headerlink" title="反射Method【反射/反编译一个类的方法】"></a>反射Method【反射/反编译一个类的方法】</h3><h4 id="Method类方法"><a href="#Method类方法" class="headerlink" title="Method类方法"></a>Method类方法</h4><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="center"><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">public String <strong>getName</strong>()</td><td align="center">返回方法名</td></tr><tr><td align="center">public int <strong>getModifiers</strong>()</td><td align="center">获取方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td align="center">public Class&lt;?&gt; <strong>getReturnType</strong>()</td><td align="center">以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td align="center">public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td><td align="center">返回方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td align="center">public Object <strong>invoke</strong>(Object obj, Object… args)</td><td align="center">调用方法</td></tr></tbody></table><h4 id="eg-反编译一个类的方法Method"><a href="#eg-反编译一个类的方法Method" class="headerlink" title="eg.反编译一个类的方法Method"></a>eg.反编译一个类的方法Method</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">了解一下，不需要掌握（反编译一个类的方法。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest09</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s.append(Modifier.toString(userServiceClass.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(userServiceClass.getSimpleName());</span><br><span class="line">        s.append(<span class="string">&quot; &#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的Method（包括私有的！）</span></span><br><span class="line">        Method[] methods = userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取修饰符列表</span></span><br><span class="line">            s.append(Modifier.toString(m.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 获取方法的返回值类型</span></span><br><span class="line">            s.append(m.getReturnType().getSimpleName());</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 获取方法名</span></span><br><span class="line">            s.append(m.getName());</span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">// 方法的修饰符列表（一个方法的参数可能会有多个。）</span></span><br><span class="line">            Class[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                s.append(parameterTypes[i].getSimpleName());</span><br><span class="line">                <span class="keyword">if</span> (i != parameterTypes.length - <span class="number">1</span>) s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;) &#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方法四要素"><a href="#调用方法四要素" class="headerlink" title="调用方法四要素"></a>调用方法四要素</h4><p><strong>eg.</strong> 调用对象userService的login方法</p><ul><li>要素1：<strong>对象</strong> userService</li><li>要素2：login <strong>方法名</strong></li><li>要素3：<strong>实参列表</strong></li><li>要素4：<strong>返回值</strong></li></ul><hr><p><strong>注：</strong> Method类中invoke()使用注意事项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法.invoke(对象, 实参);</span><br></pre></td></tr></table></figure><hr><h4 id="eg-★通过反射机制调用一个对象的方法"><a href="#eg-★通过反射机制调用一个对象的方法" class="headerlink" title="eg.★通过反射机制调用一个对象的方法"></a>eg.★通过反射机制调用一个对象的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重点：必须掌握，通过反射机制怎么调用一个对象的方法？</span></span><br><span class="line"><span class="comment">    五颗星*****</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射机制，让代码很具有通用性，可变化的内容都是写到配置文件当中，</span></span><br><span class="line"><span class="comment">    将来修改配置文件之后，创建的对象不一样了，调用的方法也不同了，</span></span><br><span class="line"><span class="comment">    但是java代码不需要做任何改动。这就是反射机制的魅力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest10</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 不使用反射机制，怎么调用方法</span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            要素分析：</span></span><br><span class="line"><span class="comment">                要素1：对象userService</span></span><br><span class="line"><span class="comment">                要素2：login方法名</span></span><br><span class="line"><span class="comment">                要素3：实参列表</span></span><br><span class="line"><span class="comment">                要素4：返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>) ? <span class="string">&quot;登入成功！&quot;</span> : <span class="string">&quot;登入失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制调用方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">        <span class="comment">// 获取Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod(<span class="string">&quot;login&quot;</span>, String.class, String.class);</span><br><span class="line"><span class="comment">//        Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;);//注：没有形参就不传</span></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">// 调用方法有几个要素？ 也需要4要素。</span></span><br><span class="line">        <span class="comment">// 反射机制中最最最最最重要的一个方法，必须记住。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            四要素：</span></span><br><span class="line"><span class="comment">            loginMethod方法</span></span><br><span class="line"><span class="comment">            obj对象</span></span><br><span class="line"><span class="comment">            &quot;admin&quot;,&quot;123&quot; 实参</span></span><br><span class="line"><span class="comment">            retValue 返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resValues</span> <span class="operator">=</span> loginMethod.invoke(obj, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>);<span class="comment">//注：方法返回值是void 结果是null</span></span><br><span class="line">        System.out.println(resValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射Constructor【反射-反编译一个类的构造方法】"><a href="#反射Constructor【反射-反编译一个类的构造方法】" class="headerlink" title="反射Constructor【反射/反编译一个类的构造方法】"></a>反射Constructor【反射/反编译一个类的构造方法】</h3><h3 id="Constructor类方法"><a href="#Constructor类方法" class="headerlink" title="Constructor类方法"></a>Constructor类方法</h3><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="center"><strong>备注</strong></th></tr></thead><tbody><tr><td align="center">public String <strong>getName</strong>()</td><td align="center">返回构造方法名</td></tr><tr><td align="center">public int <strong>getModifiers</strong>()</td><td align="center">获取构造方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td align="center">public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td><td align="center">返回构造方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td align="center">public T <strong>newInstance</strong>(Object … initargs)</td><td align="center">创建对象【参数为创建对象的数据】</td></tr></tbody></table><h4 id="eg-反编译一个类的构造方法Constructor"><a href="#eg-反编译一个类的构造方法Constructor" class="headerlink" title="eg.反编译一个类的构造方法Constructor"></a>eg.反编译一个类的构造方法Constructor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反编译一个类的Constructor构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest11</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public class UserService &#123;</span></span><br><span class="line">        s.append(Modifier.toString(vipClass.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(vipClass.getSimpleName());</span><br><span class="line">        s.append(<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = vipClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors)&#123;</span><br><span class="line">            <span class="comment">//public Vip(int no, String name, String birth, boolean sex) &#123;</span></span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString(c.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//            s.append(c.getName());//包名+类名</span></span><br><span class="line">            s.append(vipClass.getSimpleName());<span class="comment">//类名</span></span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class[] parameterTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                s.append(parameterTypes[i].getSimpleName());</span><br><span class="line">                <span class="keyword">if</span> (i != parameterTypes.length - <span class="number">1</span> ) s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射机制创建对象两步骤"><a href="#反射机制创建对象两步骤" class="headerlink" title="反射机制创建对象两步骤"></a>反射机制创建对象两步骤</h3><ol><li>先获取到这个有参数的构造方法【用ClassgetDeclaredConstructor()方法获取】</li><li>调用构造方法new对象【用Constructor类的newInstance()方法new对象】</li></ol><h4 id="eg-通过反射机制调用构造方法实例化java对象"><a href="#eg-通过反射机制调用构造方法实例化java对象" class="headerlink" title="eg.通过反射机制调用构造方法实例化java对象"></a>eg.通过反射机制调用构造方法实例化java对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比上一个例子(ReflectTest11)重要一些！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通过反射机制调用构造方法实例化java对象。（这个不是重点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest12</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//不适用反射创建对象</span></span><br><span class="line">        <span class="type">Vip</span> <span class="variable">vip1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>();</span><br><span class="line">        <span class="type">Vip</span> <span class="variable">vip2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>(<span class="number">123</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;2001-10-19&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制创建对象（以前）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用无参数构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> vipClass.newInstance();<span class="comment">//Class类的newInstance方法</span></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制创建对象（现在）</span></span><br><span class="line">        <span class="comment">// 调用有参数的构造方法怎么办？</span></span><br><span class="line">        <span class="comment">// 第一步：先获取到这个有参数的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> vipClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class, String.class, <span class="type">boolean</span>.class);</span><br><span class="line">        <span class="comment">// 第二步：调用构造方法new对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> c1.newInstance(<span class="number">321</span>, <span class="string">&quot;lsi&quot;</span>, <span class="string">&quot;1999-10-11&quot;</span>, <span class="literal">true</span>);<span class="comment">//Constructor类的newInstance方法</span></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取无参数构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> vipClass.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj3</span> <span class="operator">=</span> c2.newInstance();</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 如果需要调用无参构造方法，getDeclaredConstructor()方法形参为空即可【和Class类的newInstance()方法一样的效果】！</p><h3 id="★获取一个类的父类以及实现的接口"><a href="#★获取一个类的父类以及实现的接口" class="headerlink" title="★获取一个类的父类以及实现的接口"></a>★获取一个类的父类以及实现的接口</h3><p>两个方法【Class类中的】</p><ol><li>public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</li><li>public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重点：给你一个类，怎么获取这个类的父类，已经实现了哪些接口？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest13</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// String举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取String的父类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> vipClass.getSuperclass();</span><br><span class="line">        <span class="comment">// 获取String类实现的所有接口（一个类可以实现多个接口。）</span></span><br><span class="line">        Class[] interfaces = vipClass.getInterfaces();</span><br><span class="line">        System.out.println(superclass.getName());</span><br><span class="line">        <span class="keyword">for</span> (Class i : interfaces) &#123;</span><br><span class="line">            System.out.println(i.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>属性最重要的是<strong>名字</strong></li><li>实例方法最重要的是<strong>名字</strong>和<strong>形参列表</strong></li><li>构造方法最重要的是<strong>形参列表</strong></li></ol><hr><h2 id="Java网络通信"><a href="#Java网络通信" class="headerlink" title="Java网络通信"></a>Java网络通信</h2><p>由于<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&spm=1001.2101.3001.7020">数据链路层</a>编程和通信与设备紧密关联，网络层编程和操作系统紧密关联。Java网络编程从传输层开始，并根据编程使用协议的层次分为高层次网络编程（基于应用层）和低层次网络编程（基于传输层）。<br>基于URL使用高层次<a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">网络编程</a>，基于传输层使用低层次网络编程。</p><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>物理层（Physical Layer）：局部局域网上传送数据框（frame），它负责管理电脑通信设备和网络媒体之间的互通，通过物理电气接口实现互联设备间的比特形式的信息传输<br>数据链路层（Data Link Layer）：负责网络寻址、错误侦测和改错，是网络相邻节点设备间二进制信息传输的数据通道，负责数据通道的建立和拆除。<br>网络层（Network Layer）：决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组，解决跨越多个链路的甚至不同网络设备之间的通信问题，是一种端到端的通信<br>传输层（Transport Layer）：把传输表头（TH）加至数据以形成数据包，解决处于不同网络设备间的通信传输、通信管理，对上层需要通信的数据信息分解为标准的数据单元，这些数据单元到达终端后能对这些数据单元进行重新排序和整合。<br>会话层（Session Layer）：负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接，为用户交互信息而按特点规律建立的连接，提供会话地址和会话管理服务<br>表示层（Presentation Layer）：将会话层得到的数据转化为应用层可以理解的表达形式，或则将数应用层数据转化为会话层可以传输的形式<br>应用层（Application Layer）：提供为应用软件而设的界面，以设置与另一应用软件之间的通信</p><h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><p>TCP与UDP都是传输层的协议</p><p>TCP (Transmission Control Protocol)——传输控制协议</p><p>UDP (User Data Protocol)——用户数据报协议</p><p>TCP UDP<br>传输数据可靠性 TCP是一个可靠的协议，它能确保接收方完全正确地获取发送方所发送的全部数据。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方，也不能保证接收方一定能收到。<br>通讯方式 进行数据传输之前必然要建立连接，发送方与接收方在该连接之上传递数据。 发送方和接收方未建立连接，每个数据报中都给出了完整的地址信息。<br>传输数据量 一旦连接建立起来，双方的socket就可以按统一的格式传输大量的数据。 传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。<br>特点 TCP传输量大，可靠性强。 UDP操作简单，传输效率高。<br>Java支持 ServerSocket、Socket DatagramSocket、DatagramPacket</p><h3 id="为什么称TCP为面向连接的可靠协议"><a href="#为什么称TCP为面向连接的可靠协议" class="headerlink" title="为什么称TCP为面向连接的可靠协议"></a>为什么称TCP为面向连接的可靠协议</h3><p>TCP协议的连接过程为：设主机A与主机B建立连接，主机A先发送一个特殊的“连接请求消息段”给B，B接收到消息后就分配相应的资源（接收缓存和发送缓存）给这个TCP连接，然后给A发送一个“允许连接消息段”，A收到这个消息段后也分配相应资源，然后给B发送“确认消息段”，这是就建立起了TCP连接，可以相互传输数据。A与B之间的连接要连续交换3次消息（三次握手法），保证了连接传输的可靠性。<br>UDP完全依赖IP协议，是无连接的协议，每个数据报都是独立的信息，可能以任何可能的路径传向目的地，传输的可靠性不能被保证。</p><h3 id="基于TCP-Socket-的多客户-服务器通信"><a href="#基于TCP-Socket-的多客户-服务器通信" class="headerlink" title="基于TCP Socket 的多客户/服务器通信"></a>基于TCP Socket 的多客户/服务器通信</h3><p>Socket编程时，目的地址和端口号需要在创建Socket对象时指出<br>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//向本机的4700端口发出客户请求</span></span><br><span class="line">            Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">4700</span>);</span><br><span class="line">            <span class="comment">//由系统标准输入设备构造BufferedReader对象</span></span><br><span class="line">            BufferedReader sin=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="comment">//由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line">            PrintWriter os=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line">            BufferedReader is=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            String readline;</span><br><span class="line">            readline=sin.readLine(); <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            <span class="keyword">while</span>(!readline.equals(<span class="string">&quot;bye&quot;</span>))&#123;<span class="comment">//若从标准输入读入的字符串为 &quot;bye&quot;则停止循环</span></span><br><span class="line">                <span class="comment">//将从系统标准输入读入的字符串输出到Server</span></span><br><span class="line">                os.println(readline);</span><br><span class="line">                os.flush();<span class="comment">//刷新输出流，使Server马上收到该字符串</span></span><br><span class="line">                <span class="comment">//在系统标准输出上打印读入的字符串</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:&quot;</span>+readline);</span><br><span class="line">                <span class="comment">//从Server读入一字符串，并打印到标准输出上</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:&quot;</span>+is.readLine());</span><br><span class="line">                readline=sin.readLine(); <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            &#125; <span class="comment">//继续循环</span></span><br><span class="line">            os.close(); <span class="comment">//关闭Socket输出流</span></span><br><span class="line">            is.close(); <span class="comment">//关闭Socket输入流</span></span><br><span class="line">            socket.close(); <span class="comment">//关闭Socket</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error&quot;</span>+e); <span class="comment">//出错，则打印出错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiTalkServer</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> clientnum=<span class="number">0</span>; <span class="comment">//静态成员变量，记录当前客户的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocket serverSocket=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> listening=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建一个ServerSocket在端口4700监听客户请求</span></span><br><span class="line">            serverSocket=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">4700</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not listen on port:4700.&quot;</span>);</span><br><span class="line">            <span class="comment">//出错，打印出错信息</span></span><br><span class="line">            System.exit(-<span class="number">1</span>); <span class="comment">//退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(listening)&#123; <span class="comment">//循环监听</span></span><br><span class="line">            <span class="comment">//监听到客户请求，根据得到的Socket对象和客户计数创建服务线程，并启动之</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerThread</span>(serverSocket.accept(),clientnum).start();</span><br><span class="line">            clientnum++; <span class="comment">//增加客户计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close(); <span class="comment">//关闭ServerSocket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Socket socket=<span class="literal">null</span>; <span class="comment">//保存与本线程相关的Socket对象</span></span><br><span class="line">    <span class="type">int</span> clientnum; <span class="comment">//保存本进程的客户计数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket socket,<span class="type">int</span> num)</span> &#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.socket=socket; <span class="comment">//初始化socket变量</span></span><br><span class="line">        clientnum=num+<span class="number">1</span>; <span class="comment">//初始化clientnum变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//线程主体</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">//由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line">            BufferedReader is=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            <span class="comment">//由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line">            PrintWriter os=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//由系统标准输入设备构造BufferedReader对象</span></span><br><span class="line">            BufferedReader sin=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="comment">//在标准输出上打印从客户端读入的字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Client:&quot;</span>+ clientnum +is.readLine());</span><br><span class="line">            <span class="comment">//从标准输入读入一字符串</span></span><br><span class="line">            line=sin.readLine();</span><br><span class="line">            <span class="keyword">while</span>(!line.equals(<span class="string">&quot;bye&quot;</span>))&#123;<span class="comment">//如果该字符串为 &quot;bye&quot;，则停止循环</span></span><br><span class="line">                os.println(line);<span class="comment">//向客户端输出该字符串</span></span><br><span class="line">                os.flush();<span class="comment">//刷新输出流，使Client马上收到该字符串</span></span><br><span class="line">                <span class="comment">//在系统标准输出上打印该字符串</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:&quot;</span>+line);</span><br><span class="line">                <span class="comment">//从Client读入一字符串，并打印到标准输出上</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:&quot;</span>+ clientnum +is.readLine());</span><br><span class="line">                line=sin.readLine();<span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            &#125;<span class="comment">//继续循环</span></span><br><span class="line">            os.close(); <span class="comment">//关闭Socket输出流</span></span><br><span class="line">            is.close(); <span class="comment">//关闭Socket输入流</span></span><br><span class="line">            socket.close(); <span class="comment">//关闭Socket</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error:&quot;</span>+e);<span class="comment">//出错，打印出错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于UDP-数据报的多客户-服务器通信"><a href="#基于UDP-数据报的多客户-服务器通信" class="headerlink" title="基于UDP 数据报的多客户/服务器通信"></a>基于UDP 数据报的多客户/服务器通信</h3><p>使用数据报时目的地址和端口需要在创建DatagramPacket对象时，在构造方法中指出<br>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuoteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果启动时没有给出Server的名字，那么输出错误信息并退出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Usage:java QuoteClient &lt;hostname&gt;&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">// 建立数据报套接字</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">256</span>]; <span class="comment">// 建立缓冲区</span></span><br><span class="line">        <span class="comment">// 由命令行给出的第一个参数默认为Server的域名，通过它得到Server的IP信息</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 创建DatagramPacket对象</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address, <span class="number">4445</span>);</span><br><span class="line">        socket.send(packet); <span class="comment">// 发送</span></span><br><span class="line">        <span class="comment">// 创建新的DatagramPacket对象，用来接收数据报</span></span><br><span class="line">        packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        socket.receive(packet); <span class="comment">// 接收</span></span><br><span class="line">        <span class="comment">// 根据接收的字节数组生成相应的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">received</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData());</span><br><span class="line">        <span class="comment">// 输出生成的字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Quote of the Moment:&quot;</span> + received);</span><br><span class="line">        socket.close(); <span class="comment">// 关闭数据套接字</span></span><br><span class="line">        DatagramSocket socket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//创建数据报套接字</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">sin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String readLine;</span><br><span class="line">        InetAddress address=InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//Server的IP信息</span></span><br><span class="line">        <span class="keyword">while</span>(!(readLine = sin.readLine()).equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = readLine.getBytes();</span><br><span class="line">            <span class="comment">//创建DatagramPacket对象</span></span><br><span class="line">            DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address, <span class="number">4445</span>);</span><br><span class="line">            socket.send(packet); <span class="comment">//发送</span></span><br><span class="line">            buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">256</span>];</span><br><span class="line">            <span class="comment">//创建新的DatagramPacket对象，用来接收数据报</span></span><br><span class="line">            packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line">            socket.receive(packet); <span class="comment">//接收</span></span><br><span class="line">            buf = packet.getData();</span><br><span class="line">            <span class="comment">//根据接收到的字节数组生成相应的字符串</span></span><br><span class="line">            String received=<span class="keyword">new</span> <span class="title class_">String</span>(buf);</span><br><span class="line">            <span class="comment">//打印生成的字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Quote of the Sever: &quot;</span>+received );</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close(); <span class="comment">//关闭套接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class QuoteServer &#123;</span><br><span class="line">    public static void main(String args[])throws java.io.IOException&#123;</span><br><span class="line">        new QuoteServerThread().start();// 启动一个QuoteServerThread线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuoteServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span><span class="comment">// 服务器线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// DatagramSocket</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// Reader</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">moreQuotes</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">// 标志变量。是否继续操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuoteServerThread</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;QuoteServerThread&quot;</span>);<span class="comment">// QuoteServerThread</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuoteServerThread</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">//</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">4445</span>);<span class="comment">// 创建数据报套接字端口4445</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="comment">// 线程主体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (moreQuotes) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">256</span>]; <span class="comment">// 创建缓冲区</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">                <span class="comment">// 由缓冲区构建DatagramPacket对象</span></span><br><span class="line">                socket.receive(packet); <span class="comment">// 接收数据报</span></span><br><span class="line">                <span class="comment">// 输出客户端发送的内容</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()));</span><br><span class="line">                <span class="comment">// 从屏幕获取输入内容，作为发送给客户端的内容</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">dString</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">                <span class="comment">// 如果是bey，则向客户端发完消息后退出</span></span><br><span class="line">                <span class="keyword">if</span> (dString.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                    moreQuotes = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf = dString.getBytes();<span class="comment">// 把String转换成字节数组，以便传送</span></span><br><span class="line">                <span class="comment">// 从Client端传来的Packet中得到Client地址</span></span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> packet.getAddress();</span><br><span class="line">                <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> packet.getPort(); <span class="comment">// 端口号</span></span><br><span class="line">                <span class="comment">// 根据客户端信息构建DatagramPacket</span></span><br><span class="line">                packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address, port);</span><br><span class="line">                socket.send(packet); <span class="comment">// 发送数据报</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 异常处理</span></span><br><span class="line">                e.printStackTrace(); <span class="comment">// 输出异常栈信息</span></span><br><span class="line">                moreQuotes = <span class="literal">false</span>; <span class="comment">// 标志变量置false，以结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close(); <span class="comment">// 关闭数据报套接字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用URLConnetction对象编程"><a href="#利用URLConnetction对象编程" class="headerlink" title="利用URLConnetction对象编程"></a>利用URLConnetction对象编程</h3><p>利用URLConnetction对象编程返回网站首页，并将首页内容存放到文件中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        URL url=  <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.luogu.com.cn/&quot;</span>);</span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">con</span> <span class="operator">=</span> url.openConnection(); <span class="comment">//构建字符流</span></span><br><span class="line">        BufferedReader is=  <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(con.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>)); </span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/luogu.html&quot;</span>); <span class="comment">// 指定路径的文件，会自动新建</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = is.readLine()) != <span class="literal">null</span> ) &#123;</span><br><span class="line">            line = line + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            fos.write(line.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预科&quot;&gt;&lt;a href=&quot;#预科&quot; class=&quot;headerlink&quot; title=&quot;预科&quot;&gt;&lt;/a&gt;预科&lt;/h2&gt;&lt;h3 id=&quot;什么是计算机&quot;&gt;&lt;a href=&quot;#什么是计算机&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机&quot;&gt;&lt;/a&gt;什么是计算机&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;名称：Computer，全称电子计算机，俗称电脑。&lt;/li&gt;
&lt;li&gt;定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。&lt;/li&gt;
&lt;li&gt;组成：由硬件和软件组成。&lt;/li&gt;
&lt;li&gt;形式：常见显示有台式计算机、笔记本计算机、大型计算机等。&lt;/li&gt;
&lt;li&gt;应用：科学计算、数据处理、自动控制、计算机辅助设计、人工智能、网络等领域。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;硬件及冯诺依曼结构&quot;&gt;&lt;a href=&quot;#硬件及冯诺依曼结构&quot; class=&quot;headerlink&quot; title=&quot;硬件及冯诺依曼结构&quot;&gt;&lt;/a&gt;硬件及冯诺依曼结构&lt;/h3&gt;&lt;h4 id=&quot;计算机硬件&quot;&gt;&lt;a href=&quot;#计算机硬件&quot; class=&quot;headerlink&quot; title=&quot;计算机硬件&quot;&gt;&lt;/a&gt;计算机硬件&lt;/h4&gt;&lt;p&gt;组成：cpu，主板，内存，电源，主机箱，硬盘，显卡，键盘、鼠标，显示器。&lt;/p&gt;
&lt;h4 id=&quot;冯诺依曼结构&quot;&gt;&lt;a href=&quot;#冯诺依曼结构&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼结构&quot;&gt;&lt;/a&gt;冯诺依曼结构&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210427081055529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;软件及软件开发&quot;&gt;&lt;a href=&quot;#软件及软件开发&quot; class=&quot;headerlink&quot; title=&quot;软件及软件开发&quot;&gt;&lt;/a&gt;软件及软件开发&lt;/h4&gt;&lt;h4 id=&quot;计算机软件&quot;&gt;&lt;a href=&quot;#计算机软件&quot; class=&quot;headerlink&quot; title=&quot;计算机软件&quot;&gt;&lt;/a&gt;计算机软件&lt;/h4&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    <category term="笔记整合" scheme="http://example.com/categories/java/%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://example.com/ff05b5bf.html"/>
    <id>http://example.com/ff05b5bf.html</id>
    <published>2022-06-23T03:38:55.000Z</published>
    <updated>2022-06-24T13:18:59.518Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.15</span>;</span><br><span class="line">  -webkit-text-size-adjust: <span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: .<span class="number">67em</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: visible</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace, monospace;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">abbr</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline dotted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span>,</span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">kbd</span>,</span><br><span class="line"><span class="selector-tag">samp</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace, monospace;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">small &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub,</span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">75%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: -.<span class="number">25em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: -.<span class="number">5em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line">optgroup,</span><br><span class="line">select,</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: inherit;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.15</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: visible</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line">select &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=button]</span>,</span><br><span class="line"><span class="selector-attr">[type=reset]</span>,</span><br><span class="line"><span class="selector-attr">[type=submit]</span>,</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  -webkit-appearance: button</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=button]</span>::-moz-focus-inner,</span><br><span class="line">[type=reset]::-moz-focus-inner,</span><br><span class="line">[type=submit]::-moz-focus-inner,</span><br><span class="line">button::-moz-focus-inner &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=button]</span>:-moz-focusring,</span><br><span class="line">[type=reset]:-moz-focusring,</span><br><span class="line">[type=submit]:-moz-focusring,</span><br><span class="line">button:-moz-focusring &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> dotted ButtonText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fieldset</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">35em</span> .<span class="number">75em</span> .<span class="number">625em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">legend</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: normal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">progress &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=checkbox]</span>,</span><br><span class="line"><span class="selector-attr">[type=radio]</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=number]</span>::-webkit-inner-spin-button,</span><br><span class="line">[type=number]::-webkit-outer-spin-button &#123;</span><br><span class="line">  <span class="attribute">height</span>: auto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=search]</span> &#123;</span><br><span class="line">  -webkit-appearance: textfield;</span><br><span class="line">  <span class="attribute">outline-offset</span>: -<span class="number">2px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=search]</span>::-webkit-search-decoration &#123;</span><br><span class="line">  -webkit-appearance: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-file-upload-button &#123;</span><br><span class="line">  -webkit-appearance: button;</span><br><span class="line">  <span class="attribute">font</span>: inherit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">details</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">summary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: list-item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &#123;</span><br><span class="line">  <span class="attribute">display</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[hidden]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">啊是大开始的卢卡斯就打水漂japlksjdoiajdoajsjaspdjalkdqpijdqoipjdipqjdpqwdpqwipdqwpdqwpdqwpdjqidjqipwodqpwodjqpowjdoj大起大落是肯定赔钱我看大家千万判定其为【权威的、</span><br><span class="line">打扑克轻微的轻微的空气炮我肯定去【我看到【期望的结果翻了翻皮卡丘的期望【ds</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;html&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;line-height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -webkit-text-size-adjust: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;body&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;main&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;h1&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2em&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: .&lt;span class=&quot;number&quot;&gt;67em&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hr &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;box-sizing&lt;/span&gt;: content-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: visible&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pre &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-family&lt;/span&gt;: monospace, monospace;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1em&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;background-color&lt;/span&gt;: transparent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;abbr&lt;/span&gt;&lt;span class=&quot;selector-attr&quot;&gt;[title]&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;text-decoration&lt;/span&gt;: underline;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;text-decoration&lt;/span&gt;: underline dotted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;strong&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-weight&lt;/span&gt;: bolder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;code&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;kbd&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;samp&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-family&lt;/span&gt;: monospace, monospace;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1em&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;small &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;80%&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;sup&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;75%&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;line-height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;: relative;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;vertical-align&lt;/span&gt;: baseline&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;bottom&lt;/span&gt;: -.&lt;span class=&quot;number&quot;&gt;25em&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;sup&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;top&lt;/span&gt;: -.&lt;span class=&quot;number&quot;&gt;5em&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;img&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;border-style&lt;/span&gt;: none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;button&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;input&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;optgroup,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;textarea&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-family&lt;/span&gt;: inherit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;line-height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;button&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;input&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: visible&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;button&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;text-transform&lt;/span&gt;: none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=button]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=reset]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=submit]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;button&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -webkit-appearance: button&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=button]&lt;/span&gt;::-moz-focus-inner,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[type=reset]::-moz-focus-inner,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[type=submit]::-moz-focus-inner,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;button::-moz-focus-inner &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;border-style&lt;/span&gt;: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;padding&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=button]&lt;/span&gt;:-moz-focusring,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[type=reset]:-moz-focusring,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[type=submit]:-moz-focusring,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;button:-moz-focusring &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;outline&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; dotted ButtonText&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;fieldset&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;padding&lt;/span&gt;: .&lt;span class=&quot;number&quot;&gt;35em&lt;/span&gt; .&lt;span class=&quot;number&quot;&gt;75em&lt;/span&gt; .&lt;span class=&quot;number&quot;&gt;625em&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;legend&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;box-sizing&lt;/span&gt;: border-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: inherit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;max-width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;padding&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;white-space&lt;/span&gt;: normal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;progress &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;vertical-align&lt;/span&gt;: baseline&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;textarea&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: auto&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=checkbox]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=radio]&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;box-sizing&lt;/span&gt;: border-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;padding&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=number]&lt;/span&gt;::-webkit-inner-spin-button,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[type=number]::-webkit-outer-spin-button &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: auto&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=search]&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -webkit-appearance: textfield;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;outline-offset&lt;/span&gt;: -&lt;span class=&quot;number&quot;&gt;2px&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[type=search]&lt;/span&gt;::-webkit-search-decoration &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -webkit-appearance: none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;::-webkit-file-upload-button &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -webkit-appearance: button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;font&lt;/span&gt;: inherit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;details&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;summary&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: list-item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[hidden]&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: none&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;啊是大开始的卢卡斯就打水漂japlksjdoiajdoajsjaspdjalkdqpijdqoipjdipqjdpqwdpqwipdqwpdqwpdqwpdjqidjqipwodqpwodjqpowjdoj大起大落是肯定赔钱我看大家千万判定其为【权威的、&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;打扑克轻微的轻微的空气炮我肯定去【我看到【期望的结果翻了翻皮卡丘的期望【ds&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

</summary>
    
    
    
    <category term="记录" scheme="http://example.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="记录" scheme="http://example.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/4a17b156.html"/>
    <id>http://example.com/4a17b156.html</id>
    <published>2022-06-23T03:38:55.000Z</published>
    <updated>2022-06-24T02:11:49.932Z</updated>
    
    <content type="html"><![CDATA[<p>当我们学习一门编程语言时，都是从“Hello, World!”开始。所有程序员在其职业生涯中，都至少接触过一个经典的“Hello, World!” 程序。通常程序员会使用多种编程语言，多的甚至实现了十几种。</p><hr><h3 id="C语言-Hello-World！"><a href="#C语言-Hello-World！" class="headerlink" title="C语言: Hello,World！"></a><strong>C语言</strong>: Hello,World！</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="C-语言-Hello-World！"><a href="#C-语言-Hello-World！" class="headerlink" title="C++语言: Hello,World！"></a><strong>C++语言</strong>: Hello,World！</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Python语言-Hello-World！"><a href="#Python语言-Hello-World！" class="headerlink" title="Python语言: Hello,World！"></a><strong>Python语言</strong>: Hello,World！</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="Java语言-Hello-World！"><a href="#Java语言-Hello-World！" class="headerlink" title="Java语言: Hello,World！"></a>Java语言: Hello,World！</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="JavaScript语言-Hello-World！"><a href="#JavaScript语言-Hello-World！" class="headerlink" title="JavaScript语言: Hello,World！"></a>JavaScript<strong>语言</strong>: Hello,World！</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="PHP语言-Hello-World！"><a href="#PHP语言-Hello-World！" class="headerlink" title="PHP语言: Hello,World！"></a>PHP语言: Hello,World！</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="C-语言-Hello-World！-1"><a href="#C-语言-Hello-World！-1" class="headerlink" title="C#语言: Hello,World！"></a>C#<strong>语言</strong>: Hello,World！</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Groovy语言-Hello-World！"><a href="#Groovy语言-Hello-World！" class="headerlink" title="Groovy语言: Hello,World！"></a>Groovy语言: Hello,World！</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">println <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Scala语言-Hello-World！"><a href="#Scala语言-Hello-World！" class="headerlink" title="Scala语言: Hello,World！"></a>Scala语言: Hello,World！</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">      println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Windows-PowerShell语言-Hello-World！"><a href="#Windows-PowerShell语言-Hello-World！" class="headerlink" title="Windows PowerShell语言: Hello,World！"></a>Windows PowerShell语言: Hello,World！</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Go语言-Hello-World！"><a href="#Go语言-Hello-World！" class="headerlink" title="Go语言: Hello,World！"></a>Go语言: Hello,World！</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Rust语言-Hello-World！"><a href="#Rust语言-Hello-World！" class="headerlink" title="Rust语言: Hello,World！"></a>Rust语言: Hello,World！</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Dart语言-Hello-World！"><a href="#Dart语言-Hello-World！" class="headerlink" title="Dart语言: Hello,World！"></a>Dart语言: Hello,World！</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Kotlin语言-Hello-World！"><a href="#Kotlin语言-Hello-World！" class="headerlink" title="**Kotlin语言: Hello,World！"></a>**<strong>Kotlin</strong>语言: Hello,World！</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="TypeScript语言-Hello-World！"><a href="#TypeScript语言-Hello-World！" class="headerlink" title="*TypeScript语言: Hello,World！"></a>*<em><strong>TypeScript</strong></em><strong>语言</strong>: Hello,World！</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="Swift语言-Hello-World！"><a href="#Swift语言-Hello-World！" class="headerlink" title="Swift语言: Hello,World！"></a><strong><strong>Swift</strong></strong><strong>语言</strong>: Hello,World！</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><hr><p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们学习一门编程语言时，都是从“Hello, World!”开始。所有程序员在其职业生涯中，都至少接触过一个经典的“Hello, World!” 程序。通常程序员会使用多种编程语言，多的甚至实现了十几种。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;C语言-Hello-World！&quot;&gt;&lt;a href=&quot;#C语言-Hello-World！&quot; class=&quot;headerlink&quot; title=&quot;C语言: Hello,World！&quot;&gt;&lt;/a&gt;&lt;strong&gt;C语言&lt;/strong&gt;: Hello,World！&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World!\n&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h3 id=&quot;C-语言-Hello-World！&quot;&gt;&lt;a href=&quot;#C-语言-Hello-World！&quot; class=&quot;headerlink&quot; title=&quot;C++语言: Hello,World！&quot;&gt;&lt;/a&gt;&lt;strong&gt;C++语言&lt;/strong&gt;: Hello,World！&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h3 id=&quot;Python语言-Hello-World！&quot;&gt;&lt;a href=&quot;#Python语言-Hello-World！&quot; class=&quot;headerlink&quot; title=&quot;Python语言: Hello,World！&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python语言&lt;/strong&gt;: Hello,World！&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
