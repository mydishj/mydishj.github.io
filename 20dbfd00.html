<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 | CPPLUSE</title><meta name="keywords" content="Java"><meta name="author" content="PSPLUSE"><meta name="copyright" content="PSPLUSE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="预科什么是计算机 名称：Computer，全称电子计算机，俗称电脑。 定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。 组成：由硬件和软件组成。 形式：常见显示有台式计算机、笔记本计算机、大型计算机等。 应用：科学计算、数据处理、自动控制、计算机辅助设计、人工智能、网络等领域。  硬件及冯诺依曼结构计算机硬件组成：cpu，主板，内存，电源，主机箱，硬盘，显卡，键盘、鼠标，显示器">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/20dbfd00.html">
<meta property="og:site_name" content="CPPLUSE">
<meta property="og:description" content="预科什么是计算机 名称：Computer，全称电子计算机，俗称电脑。 定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。 组成：由硬件和软件组成。 形式：常见显示有台式计算机、笔记本计算机、大型计算机等。 应用：科学计算、数据处理、自动控制、计算机辅助设计、人工智能、网络等领域。  硬件及冯诺依曼结构计算机硬件组成：cpu，主板，内存，电源，主机箱，硬盘，显卡，键盘、鼠标，显示器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/0p/wallhaven-0pj8op.jpg">
<meta property="article:published_time" content="2022-06-24T02:13:57.000Z">
<meta property="article:modified_time" content="2022-06-24T07:18:34.439Z">
<meta property="article:author" content="PSPLUSE">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/0p/wallhaven-0pj8op.jpg"><link rel="shortcut icon" href="/img/9.jpg"><link rel="canonical" href="http://example.com/20dbfd00"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: PSPLUSE","link":"链接: ","source":"来源: CPPLUSE","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-06-24 15:18:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/shadow.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="CPPLUSE" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 摸鱼专区</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/nm/wallhaven-nmp8k9.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CPPLUSE</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 摸鱼专区</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-24T02:13:57.000Z" title="发表于 2022-06-24 10:13:57">2022-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-24T07:18:34.439Z" title="更新于 2022-06-24 15:18:34">2022-06-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88/">笔记整合</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>122分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="预科"><a href="#预科" class="headerlink" title="预科"></a>预科</h2><h3 id="什么是计算机"><a href="#什么是计算机" class="headerlink" title="什么是计算机"></a>什么是计算机</h3><ol>
<li>名称：Computer，全称电子计算机，俗称电脑。</li>
<li>定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。</li>
<li>组成：由硬件和软件组成。</li>
<li>形式：常见显示有台式计算机、笔记本计算机、大型计算机等。</li>
<li>应用：科学计算、数据处理、自动控制、计算机辅助设计、人工智能、网络等领域。</li>
</ol>
<h3 id="硬件及冯诺依曼结构"><a href="#硬件及冯诺依曼结构" class="headerlink" title="硬件及冯诺依曼结构"></a>硬件及冯诺依曼结构</h3><h4 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h4><p>组成：cpu，主板，内存，电源，主机箱，硬盘，显卡，键盘、鼠标，显示器。</p>
<h4 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081055529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h4 id="软件及软件开发"><a href="#软件及软件开发" class="headerlink" title="软件及软件开发"></a>软件及软件开发</h4><h4 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h4><h4 id="Windows常用快捷键"><a href="#Windows常用快捷键" class="headerlink" title="Windows常用快捷键"></a>Windows常用快捷键</h4><p>Alt+f4关闭窗口 Shift+Delete永久删除 ctrl+w自动保存</p>
<p>死机：任务管理器结束进程</p>
<h4 id="基本的Dos命令"><a href="#基本的Dos命令" class="headerlink" title="基本的Dos命令"></a>基本的Dos命令</h4><p>打开CMD的方式</p>
<ol>
<li>开始+系统+命令提示符</li>
<li>win键+R+输入cmd (推荐使用)</li>
<li>在任意的文件夹下，按住Shift键+鼠标右击，打开命令行窗口</li>
<li>在资源管理器地址栏路径前面加 “cmd ”</li>
<li>管理员运行方式：命令提示符右键以管理员身份运行（最高权限运行）</li>
</ol>
<p>常用的Dos命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 盘符切换 E:</span><br><span class="line"># 查看当前目录下所有文件 dir</span><br><span class="line"># 切换目录 cd /d E:\idea</span><br><span class="line"># 返回上一级目录 cd ..</span><br><span class="line"># 进入同级目录下的下一级目录 cd <span class="title function_">tmp</span><span class="params">(该目录下的文件名)</span></span><br><span class="line"># 清屏 cls (clear screen)</span><br><span class="line"># 退出终端 exit</span><br><span class="line"># 查看电脑当前IP地址 ipconfig</span><br><span class="line"></span><br><span class="line"># 打开计算器 calc</span><br><span class="line"># 打开画图 mspaint</span><br><span class="line"># 新建记事本 notepad</span><br><span class="line"></span><br><span class="line"># 在当前目录新建文件夹 md <span class="title function_">test</span><span class="params">(文件夹名)</span></span><br><span class="line"># 新建文件 cd&gt; a.txt(文件名)</span><br><span class="line"># 删除文件 del a.txt(文件名)</span><br><span class="line"># 删除目录 rd <span class="title function_">test</span><span class="params">(目录名)</span></span><br><span class="line"></span><br><span class="line"># ping命令(复制链接进入Dos直接单击鼠标右键粘贴)</span><br><span class="line">	ping www.baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="计算机语言发展史"><a href="#计算机语言发展史" class="headerlink" title="计算机语言发展史"></a>计算机语言发展史</h4><ul>
<li>第一代语言：机器语言</li>
<li>第二代语言：汇编语言</li>
<li>第三代语言：高级语言</li>
</ul>
<h4 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h4><p>C、C++、Java、C#、Python、PHP、JavaScript …</p>
<p>大体上分为：<strong>面向过程</strong>与<strong>面向对象</strong>两大类</p>
<p>C语言是典型的<strong>面向过程</strong>的语言，C++，Java是典型的<strong>面向对象</strong>的语言</p>
<hr>
<h2 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h2><h3 id="Java帝国的诞生"><a href="#Java帝国的诞生" class="headerlink" title="Java帝国的诞生"></a>Java帝国的诞生</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081209316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h4 id="Java特性与优势"><a href="#Java特性与优势" class="headerlink" title="Java特性与优势"></a>Java特性与优势</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081218160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>简单性</li>
<li>面对对象</li>
<li>可移植性</li>
<li>高性能</li>
<li>分布式</li>
<li>多态性</li>
<li>多线程</li>
<li>安全性</li>
<li>健壮性</li>
</ul>
<h4 id="Java三大版本"><a href="#Java三大版本" class="headerlink" title="Java三大版本"></a>Java三大版本</h4><ul>
<li>Write Once，Run Anywhere</li>
<li>JavaSE: 标准版 (桌面程序，控制台开发…)</li>
<li>JavaME: 嵌入式开发 (手机，小家电…)，已经凉了</li>
<li>JavaEE: E企业级开发 (Web端，服务端开发…)，JavaSE为基础</li>
</ul>
<h4 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h4><ul>
<li>JDK：Java Development Kit (Java开发者工具，包括 JRE，JVM)</li>
<li>JRE：Java Runtime Environment (Java运行时环境)</li>
<li>JVM：Java Virtual Machine (Java虚拟机，跨平台核心)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081317290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h4 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h4><h5 id="卸载JDk"><a href="#卸载JDk" class="headerlink" title="卸载JDk"></a>卸载JDk</h5><ol>
<li>删除Java安装目录</li>
<li>删除环境变量JAVA_HOME</li>
<li>删除path下关于JAVA的目录</li>
<li>Java -version</li>
</ol>
<h5 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h5><ol>
<li>百度搜索JDK8，找到下载地址</li>
<li>同意协议，下载电脑对应的版本，如64位操作系统下载 jdk-8u281-windows-x64.exe</li>
<li>双击安装JDK</li>
<li>记住安装路径</li>
<li>配置环境变量<ol>
<li>我的电脑-》属性-》系统高级设置-》环境变量</li>
<li>系统变量 新建–&gt; JAVA_HOME 输入对应的jdk安装路径</li>
<li>path变量–&gt;% JAVA_HOME%\bin</li>
</ol>
</li>
<li>测试是否成功 cmd–&gt;Java -version</li>
</ol>
<hr>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>单行注释 &#x2F;&#x2F;</li>
<li>多行注释 &#x2F;* *&#x2F;</li>
<li>文档注释 &#x2F;** *&#x2F;</li>
</ol>
<h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><ul>
<li>Java 所有的组成部分都需要名字。类名、变量名、方法名都被称为标识符</li>
</ul>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2021042708142877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h4 id="标识符注意点"><a href="#标识符注意点" class="headerlink" title="标识符注意点"></a>标识符注意点</h4><ul>
<li>所有标识符都应该以 字母、$(美元符)、_(下划线) 开头</li>
<li>首字母之后可以是 字母、$、_ 或数字任何字符组合</li>
<li>关键字不能作为变量名或方法名</li>
<li>标识符大小写敏感</li>
<li>可以用中文命名，但不建议使用，即使用拼音命名也Low</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>强类型语言</p>
<ul>
<li>要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</li>
</ul>
</li>
<li><p>弱类型语言：JavaScript，Python</p>
</li>
<li><p>Java的数据类型分为两大类</p>
<ul>
<li>基本类型（primitive type），有8大基本类型，此外都是引用类型</li>
<li>引用类型（reference type）</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081748164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//最常用，只要别超过21亿（2^31-1）</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//-128~127</span></span><br><span class="line"><span class="type">short</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">30L</span>; <span class="comment">//long类型数字后面要加个L(尽量用大写，小写l容易与1搞混)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小数：浮点数</span></span><br><span class="line"><span class="type">float</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">50.1F</span>; <span class="comment">//float类型数字后面要加个F</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">3.141592653589793238</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;国&#x27;</span>;</span><br><span class="line"><span class="comment">//字符串, String不是关键字，是类</span></span><br><span class="line"><span class="comment">//String namea = &quot;薛之谦&quot;;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//布尔值：是非</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h4><ul>
<li>位(bit)：是计算机内部数据存储的最小单位，11001100是一个八位二进制数</li>
<li>字节(byte, B)：是计算机中 数据处理 的基本单位，习惯上用大写B表示</li>
<li>1B(byte) &#x3D; 8bit，1字节等于8位</li>
<li>字符：指计算机中使用的字母，数字，字和符号<ul>
<li>1bit表示1位</li>
<li>1Byte表示一个字节 1B&#x3D;8b</li>
<li>1024B &#x3D; 1KB, 1024KB &#x3D; 1M, 1024M &#x3D; 1G</li>
</ul>
</li>
</ul>
<h4 id="扩展及面试题"><a href="#扩展及面试题" class="headerlink" title="扩展及面试题"></a>扩展及面试题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数扩展： 二进制0b		八进制0		十进制		十六进制0x</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>; <span class="comment">//八进制 8</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制 16</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点数扩展：</span></span><br><span class="line"><span class="comment">//面试题：银行业务字母怎么表示钱? BigDecimal(数学工具类)</span></span><br><span class="line"><span class="comment">//float double是有问题的，最好避免使用浮点数进行比较</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.1f</span>; 	<span class="comment">//0.1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span>/<span class="number">10</span>;  <span class="comment">//0.1</span></span><br><span class="line">System.out.println(f==d); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//浮点数 位有限，舍入误差，大约</span></span><br><span class="line"><span class="comment">//最好避免使用浮点数进行比较</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">23131313131f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> f1+<span class="number">1</span>;</span><br><span class="line">System.out.println(f1==f2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符扩展：所有字符本质还是数字</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(c1);		<span class="comment">//a</span></span><br><span class="line">System.out.println((<span class="type">int</span>)c1);<span class="comment">//强制类型转换,97</span></span><br><span class="line">System.out.println(c2);		<span class="comment">//中</span></span><br><span class="line">System.out.println((<span class="type">int</span>)c2);<span class="comment">//强制类型转换,20013</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编码 Unicode表（97=a,65=A）2字节 0-65536</span></span><br><span class="line"><span class="comment">//U000~UFFFF 十六进制（u0061=a,相当于十进制的97）</span></span><br><span class="line">System.out.println(<span class="string">&#x27;\u0061&#x27;</span>);  <span class="comment">//a &#x27;\&#x27;是转义字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//布尔值扩展</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="literal">true</span>)&#123;&#125; <span class="comment">//新手</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;&#125;	<span class="comment">//老手这样写 Less is More(代码要精简易读)</span></span><br></pre></td></tr></table></figure>



<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</li>
<li>容量高–&gt;低：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081848182.png"></p>
<ul>
<li>运算中，不同类型的数据先转化位同一类型，再进行运算。<ul>
<li>强制转换，（类型）变量名，容量由高到低</li>
<li>自动转换，容量由低到高</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强制转换 （类型）变量名 高--低</span></span><br><span class="line"><span class="comment">//自动转换 低--高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i; <span class="comment">//强制转换 内存溢出 -128~127</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span>i; <span class="comment">//自动转换</span></span><br><span class="line"></span><br><span class="line">System.out.println(i); <span class="comment">//128</span></span><br><span class="line">System.out.println(b); <span class="comment">//-128</span></span><br><span class="line">System.out.println(d); <span class="comment">//128.0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   注意点：</span></span><br><span class="line"><span class="comment">   1.不能对布尔值进行转换</span></span><br><span class="line"><span class="comment">   2.不能把对象类型转换为不相干的类型</span></span><br><span class="line"><span class="comment">   3.在把高容器转换到低容量的时候，强制转换</span></span><br><span class="line"><span class="comment">   4.可能存在内存溢出，或者精度问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println((<span class="type">int</span>)<span class="number">23.7</span>); <span class="comment">//23 丢失精度</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c+<span class="number">1</span>;</span><br><span class="line">System.out.println(n); <span class="comment">//98</span></span><br><span class="line">System.out.println((<span class="type">char</span>)n); <span class="comment">//b</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当操作数比较大时，注意溢出问题</span></span><br><span class="line"><span class="comment">//JDK7新特性，数字之间可以用下划线分割</span></span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>; <span class="comment">//10亿，下划线不会被打印出来</span></span><br><span class="line">System.out.println(money); <span class="comment">//1000000000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">years</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> money*years;  <span class="comment">//数据大，溢出</span></span><br><span class="line">System.out.println(total); <span class="comment">//-1474836480</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">total2</span> <span class="operator">=</span> money*years; <span class="comment">//默认是int，转换前就有溢出问题</span></span><br><span class="line">System.out.println(total2); <span class="comment">//-1474836480</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">total3</span> <span class="operator">=</span> money*(<span class="type">long</span>)years; <span class="comment">//先把一个数转Long</span></span><br><span class="line">System.out.println(total3); <span class="comment">//20000000000</span></span><br></pre></td></tr></table></figure>

<h3 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h3><ul>
<li>变量是什么：就是可以变化的量</li>
<li>Java是一种强类型语言，每个变量都必须声明其类型</li>
<li>Java变量是程序中最基本的存储单元，要素包括变量名，变量类型和作用域</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型 变量名 = 值;</span></span><br><span class="line">type varName [=value][&#123;,varName[=value]&#125;];</span><br><span class="line"><span class="comment">//可以使用逗号隔开同多个类型的变量，但不建议在一行定义多个变量</span></span><br></pre></td></tr></table></figure>



<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul>
<li>类变量（static）</li>
<li>实例变量</li>
<li>局部变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> 	<span class="variable">allClicks</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//类变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>; <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>; <span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常量：初始化后不能再改变的值，不会变动的值。</span><br><span class="line">可以理解为一种特殊的变量，其值被设定后，在程序运行过程不允许被更改。</span><br><span class="line"><span class="comment">//常量一般用大写字符</span></span><br><span class="line"><span class="keyword">final</span> 常量名=值;</span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰符 不存在先后顺序，static可以写final后面</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> doube PI=<span class="number">3.14</span>; <span class="comment">//类变量，该类下的全局范围</span></span><br></pre></td></tr></table></figure>

<h4 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h4><ul>
<li>所有变量、方法、类名：见名知意</li>
<li>类成员变量：首字母小写+驼峰原则：lastName</li>
<li>局部变量：首字母小写+驼峰原则</li>
<li>常量：大写字母和下划线：MAX_VALUE</li>
<li>类名：首字母大写+驼峰原则：Man，GoodMan</li>
<li>方法名：首字母小写+驼峰原则：run()，fastRun()</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427081956511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">System.out.println(a/b); <span class="comment">//0</span></span><br><span class="line">System.out.println((<span class="type">double</span>)a/b); <span class="comment">//0.5</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> c=<span class="number">12300000000</span>;</span><br><span class="line">System.out.println(a+b); <span class="comment">//int</span></span><br><span class="line">System.out.println(a+c); <span class="comment">//long 自动转换式子中容量大的数据类型</span></span><br></pre></td></tr></table></figure>

<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ++自增 --自减 单目运算符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++; <span class="comment">//b=a,a=a+1 先赋值 即b=3 a=4</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a; <span class="comment">//a=a+1,c=a 先自增 即a=5 c=5</span></span><br><span class="line"></span><br><span class="line">System.out.println(a); <span class="comment">//5</span></span><br><span class="line">System.out.println(b); <span class="comment">//3</span></span><br><span class="line">System.out.println(c); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//幂运算 2^3 2*2*2=8</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// (底数，指数)double型</span></span><br><span class="line">System.out.println(pow); <span class="comment">//8.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展：笔试题 i=5 s=(i++)+(++i)+(i--)+(--i) s=?</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> s=(i++)+(++i)+(i--)+(--i);</span><br><span class="line">System.out.println(s); <span class="comment">//24</span></span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&amp;&amp; 逻辑与运算：两个变量都为真，结果为<span class="literal">true</span></span><br><span class="line">|| 逻辑与运算：两个变量有一个为真，结果为<span class="literal">true</span></span><br><span class="line">! 取反，真变为假，假变为真</span><br><span class="line"><span class="comment">// 与(snd) 或(or) 非(取反)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a&amp;&amp;b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a||b); <span class="comment">// true</span></span><br><span class="line">System.out.println(!(a&amp;&amp;b)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c=<span class="number">5</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> (c&lt;<span class="number">5</span>)&amp;&amp;(c++&lt;<span class="number">5</span>); <span class="comment">//第一个值为false，后面就不进行判定了</span></span><br><span class="line">System.out.println(d); <span class="comment">//false</span></span><br><span class="line">System.out.println(c); <span class="comment">//5 c++未执行</span></span><br></pre></td></tr></table></figure>



<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A = 0011 1100</span></span><br><span class="line"><span class="comment">    B = 0000 1101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    A&amp;B 0000 1101 按位与</span></span><br><span class="line"><span class="comment">    A|B 0011 1101 按位或</span></span><br><span class="line"><span class="comment">    A^B 0011 0001 异或</span></span><br><span class="line"><span class="comment">    ~B  1111 0010 非</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    面试题：2*8 怎么算最快？ 2&lt;&lt;3</span></span><br><span class="line"><span class="comment">    &lt;&lt;左移  *2 效率极高！！</span></span><br><span class="line"><span class="comment">    &gt;&gt;右移  /2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">3</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">a+=b; <span class="comment">// a = a+b</span></span><br><span class="line">a-=b; <span class="comment">// a = a-b</span></span><br><span class="line"></span><br><span class="line">System.out.println(a); <span class="comment">//10</span></span><br><span class="line"><span class="comment">//字符串连接符 + ，转化为String类型,然后拼接    注意！！</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+a+b); <span class="comment">//1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">&quot;&quot;</span>); <span class="comment">//30 先进行运算，再转为String拼接</span></span><br><span class="line">System.out.println(a+b+<span class="string">&quot;str&quot;</span>); <span class="comment">//30str</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x ? y : z</span></span><br><span class="line"><span class="comment">//如果x为真，则结果为y,否则为z</span></span><br><span class="line"><span class="comment">//if(x) y; else z;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> score&lt;<span class="number">60</span>?<span class="string">&quot;及格&quot;</span>:<span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">System.out.println(type); <span class="comment">//及格</span></span><br></pre></td></tr></table></figure>



<h4 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h4><ul>
<li>为了更好地组织类，Java提供了包机制，由于区分类名的命名空间</li>
<li>包的语法格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg2[.pkg3...]];</span><br></pre></td></tr></table></figure>

<p>-<br>  一般利用公司域名倒置作为包名；com.kuangstudy.www</p>
<ul>
<li>为了能够使用一个包的成员，需要在Java程序中导入该包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2...].(className|*); <span class="comment">//通配符* 导入包下所有的类</span></span><br></pre></td></tr></table></figure>

<p>-<br>  参考：阿里巴巴Java开发手册</p>
<h3 id="JavaDoc生成文档"><a href="#JavaDoc生成文档" class="headerlink" title="JavaDoc生成文档"></a>JavaDoc生成文档</h3><ul>
<li><p>javadoc命令是用来生成自己API文档的</p>
</li>
<li><p>参数信息</p>
<ul>
<li><p>@author 作者名</p>
</li>
<li><p>@version 版本号</p>
</li>
<li><p>@since 指明最早用的jdk版本</p>
</li>
<li><p>@param 参数名</p>
</li>
<li><p>@return 返回值情况</p>
</li>
<li><p>@throws 异常抛出情况</p>
</li>
</ul>
</li>
<li><p>API文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- <span class="doctag">@author</span> Kuangshen</span></span><br><span class="line"><span class="comment">- <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">- <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">String name;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  - <span class="doctag">@author</span> kuangshen</span></span><br><span class="line"><span class="comment">  - <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">  - <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  - <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>打开某个类所在文件夹下的cmd命令行</li>
<li>输入：javadoc -encoding UTF-8 -charset UTF-8 Doc(类名).java</li>
<li>会自动生成该类有关的API文档，查看文件夹发现多了一些文件</li>
<li>打开 index.html（首页）查看文档注释</li>
</ol>
<hr>
<h2 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h2><h3 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h3><ul>
<li>之前我们学的基本语法并没有实现程序和人的交互，Java给我们提供了一个工具类，可以获取用户的输入java.util.Scanner是Java5的新特征，我们通过Scanner类来获取用户的输入。</li>
<li>基本语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<p>-<br>  通过Scanner类的 next()与 nextLine()方法获取用户的字符串，读取前一般用hasNext()与hasNextLine()判断是否还有输入的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个扫描器对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;使用next方式接收&quot;</span>);</span><br><span class="line"><span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line"><span class="keyword">if</span>(scanner.hasNext())&#123;  <span class="comment">//使用hasNextLie()会接收一行 &quot;hello word&quot;</span></span><br><span class="line">    <span class="comment">//使用next方式接收</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next(); </span><br><span class="line">    System.out.println(<span class="string">&quot;输入的内容为：&quot;</span>+str);</span><br><span class="line">    <span class="comment">//input: hello word</span></span><br><span class="line">    <span class="comment">//输入的内容为：hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//凡是属于IO流的类如果不关闭会一直占用资源</span></span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure>



<h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><ol>
<li>一定要读取到有效字符才可以结束输入</li>
<li>对输入有效字符之前遇到的空白，next()方法会将其去掉</li>
<li>只有输入有效字符后才将其后面输入的空白作为结束符</li>
<li>next()不能得到带有空格的字符串</li>
</ol>
<h4 id="nextLine"><a href="#nextLine" class="headerlink" title="nextLine()"></a>nextLine()</h4><ol>
<li>以Enter作为结束符，即返回输入回车之前所有的字符</li>
<li>nextLine()可以获取空白</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从键盘接收数据</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;输入的内容为：&quot;</span>+str);</span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextInt())&#123;</span><br><span class="line">    <span class="type">int</span> i=scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;输入的整数为：&quot;</span>+i);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入的不是整数数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ul>
<li>Java的基本结构就是顺序结构，除非特别指明，否则就按语句一条一条执行。</li>
<li>顺序结构是最简单的算法结构。</li>
<li>语句语句之间是按从上到下执行的，它是由若干个依次执行的处理步骤组成的，它是如何一种算法都离不开的一种基本算法结构。</li>
</ul>
<h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul>
<li>if单选择结构 if( )</li>
<li>if双选择结构 if( ){ }else{ }</li>
<li>if多选择结构 if( ){ }else if{ }else{}</li>
<li>嵌套的if结构 if( ){ if( ) }</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">60</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">80</span>) System.out.println(<span class="string">&quot;且优秀&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;缺考&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch多选择结构"><a href="#switch多选择结构" class="headerlink" title="switch多选择结构"></a>switch多选择结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>; <span class="comment">//JDK新特性 可以是字符串(字符本质还是数字)</span></span><br><span class="line"><span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//可选，跳出当前结构</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;合格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//默认，以上值没匹配到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDEA反编译之后.class文件与源代码对比</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082240517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>循环</span><br><span class="line"><span class="comment">//计算1+2+3+...+100</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum); <span class="comment">//5050</span></span><br></pre></td></tr></table></figure>

<p>-<br>  do…while循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先执行后判断，至少执行一次</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;<span class="number">100</span>) <span class="comment">//跟上面效果一样</span></span><br></pre></td></tr></table></figure>

<p>-<br>  for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//（初始化;条件判断;迭代）</span><br><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">for(; ; )&#123;...&#125; //死循环</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习1：输出1-1000能被5整除的数，每行输出3个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>); <span class="comment">//输出完不换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i%(<span class="number">3</span>*<span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2：输出九九乘法表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        System.out.print(j+<span class="string">&quot;*&quot;</span>+i+<span class="string">&quot;=&quot;</span>+i*j+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;; <span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x:numbers)&#123;</span><br><span class="line">    System.out.println(x); <span class="comment">//遍历数组的元素 10 20 30 40 50</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h3><ul>
<li>break可用在任何循环的主体部分，由于强行退出循环，也可以用在switch语句。</li>
<li>continue用于循环语句中，终止某次循环过程，跳过剩余语句，之间进行下一次循环条件判断。</li>
<li>标签：后面跟一个冒号的标识符 label:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印101-150之间所有的质数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">outer:<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">101</span>;i&lt;=<span class="number">150</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span> outer; <span class="comment">//不建议使用标签</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制练习"><a href="#流程控制练习" class="headerlink" title="流程控制练习"></a>流程控制练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印等腰空心三角形</span></span><br><span class="line"><span class="comment">/*  例如：输入为4时</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">         * *</span></span><br><span class="line"><span class="comment">        *   *</span></span><br><span class="line"><span class="comment">       * * * *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//n为三角形高</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*n-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=n)&#123; <span class="comment">//若不为最后一行</span></span><br><span class="line">            <span class="keyword">if</span>(i+j==n+<span class="number">1</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>); <span class="comment">//三角形左腰边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+j==n+<span class="number">2</span>*i-<span class="number">1</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>); <span class="comment">//三角形右腰边</span></span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j%<span class="number">2</span>!=<span class="number">0</span>)&#123;  <span class="comment">//最后一行，底边</span></span><br><span class="line">            System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h2><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><ul>
<li>Java的方法类似与其他语言的函数，是一段用来完成特定功能的代码片段。</li>
<li>方法包含一个方法头和一个方法体。<ul>
<li>修饰符：可选，定义了方法的访问类型，告诉编译器如何调用该方法。</li>
<li>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法没有返回值，则returnValueType为关键字void。</li>
<li>方法名：是方法的实际名称，方法名与参数表共同构成方法签名。</li>
<li>参数类型：像一个占位符。方法被调用时，传递值给参数，该值称为实参或变量。参数列表是指方法的参数类型、顺序和参数个数。参数是可选的，方法可以不包含任何参数。<ul>
<li>形式参数：在方法被调用时用于接收外界输入的数据。</li>
<li>实参：调用方法时实际传给方法的数据。</li>
</ul>
</li>
</ul>
</li>
<li>方法体：方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名,...）&#123;</span><br><span class="line">   方法体...</span><br><span class="line">   <span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><ul>
<li>调用方法：对象名.方法名(实参列表)。</li>
<li>Java支持两种调用方法的方式，根据方法是否返回值来选择。</li>
<li>当方法返回一个值的时候，方法调用通常被当成一个值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">larger</span> <span class="operator">=</span> max(<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果方法返回值是void，方法调用一定是一条语句。</li>
<li>扩展：值传递和引用传递 ( Java都是值传递)。</li>
<li>调用其他类的方法，除非是static静态方法，不然必须实例化这个类(new)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> Demo01.add(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 通过类名直接调用静态方法</span></span><br><span class="line">        System.out.println(add); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static静态方法，否则就要new实例化来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递 &amp;引用传递"></a>值传递 &amp;引用传递</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082403886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082454225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul>
<li><p>重载是在一个类中，有相同的方法名，参数列表不同的方法。</p>
</li>
<li><p>方法重载的规则：</p>
<ul>
<li>方法名称必须相同</li>
<li>参数列表必须不同（个数、参数类型、或排序不同）</li>
<li>返回类型可以相同也可以不相同</li>
<li>仅仅返回类型不同不足以成为方法的重载</li>
</ul>
</li>
<li><p>实现理论</p>
<ul>
<li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li>
</ul>
</li>
</ul>
<h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><ul>
<li>有时候你希望运行一个程序时候传递给它消息，这要靠传递命令行参数给main()函数实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//args.length 数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;args[&quot;</span>+i+<span class="string">&quot;]: &quot;</span>+args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到当前类的文件夹，打开cmd.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E5%9F%BA%E7%A1%80.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70-165603926880022.png"></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>Jdk1.5开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号 (…)。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">int</span>... num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有值传入&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; result)&#123;</span><br><span class="line">            result = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值是：&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    printMax(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//最大值是：4</span></span><br><span class="line">    printMax(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;); <span class="comment">//最大值是：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li><p>递归就是：A方法调用A方法，自己调用自己！</p>
</li>
<li><p>递归策略只需少量的代码可描述解题过程中多次重复计算，大大减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p>
</li>
<li><p>递归结构</p>
<ul>
<li>递归头：什么时候不调用自身方法，没有头 将陷入死循环。</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阶乘 n! n*(n-1)*...*2*1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*f(n-<span class="number">1</span>); <span class="comment">//递归：调用自身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">5</span>)); <span class="comment">//5!= 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ul>
<li>数组是相同类型数据的有序集合</li>
<li>数组描述的是相同类型的若干数据，按照一定先后次序排序组合而成</li>
<li>其中，每一个数据称作一个数组元素，每个数组元素可以通过下标访问它们</li>
</ul>
<h3 id="数组的声明创建"><a href="#数组的声明创建" class="headerlink" title="数组的声明创建"></a>数组的声明创建</h3><ul>
<li>首先必须声明数组变量，才能在程序中使用数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar; <span class="comment">//首选</span></span><br><span class="line">dataType arrayRefVar[]; <span class="comment">//效果相同,但不是首选</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言使用new操作符来创建数组，语法如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize]; <span class="comment">//int[] nums=new int[10]</span></span><br></pre></td></tr></table></figure>

<p>-<br>  数组的元素是通过索引访问的，数组索引从0开始</p>
<ul>
<li>获取数组长度：arrays.length</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums; <span class="comment">//1.声明一个数组</span></span><br><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//2.创建一个数组</span></span><br><span class="line"><span class="comment">//3.给数组元素赋值</span></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">nums[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">nums[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123; <span class="comment">//打印数组所有元素</span></span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082623150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082639964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<hr>
<h3 id="数组的三种初始化"><a href="#数组的三种初始化" class="headerlink" title="数组的三种初始化"></a>数组的三种初始化</h3><ul>
<li>静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态初始化：创建+赋值</span></span><br><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans=&#123;<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="number">2</span>,<span class="number">2</span>)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含默认初始化</span></span><br><span class="line"><span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">//默认值为0</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>-<br>  默认初始化</p>
<ul>
<li>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</li>
</ul>
<h3 id="数组的基本特点"><a href="#数组的基本特点" class="headerlink" title="数组的基本特点"></a>数组的基本特点</h3><ol>
<li><p>其长度是确定的，数组一旦被创建，它的大小就是不可改变的。</p>
</li>
<li><p>其元素必须是相同类型，不允许出现混合类型。</p>
</li>
<li><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</p>
</li>
<li><p>数组变量属于引用类型，数组也可以看作对象，其中每个元素相当于该对象的成员变量。</p>
</li>
<li><p>数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，</p>
</li>
<li><p>数组本身是在堆中的。</p>
</li>
</ol>
<h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082726194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><ul>
<li>For-Each循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//打印全部的数组元素 JDK1.5 没有下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> array : arrays) &#123;</span><br><span class="line">    System.out.println(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-<br>  数组作方法入参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-<br>  数组作返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverse(<span class="type">int</span>[] arrays)&#123;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arrays.length];</span><br><span class="line">    <span class="comment">//反转的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">        result[i] = arrays[arrays.length-i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul>
<li>多维数组可以看成数组的数组，比如二维数组就是一个特殊的数组，其每一个元素都是一个一维数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>]; <span class="comment">//二维数组,三行两列</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082746289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//打印二维数组所有元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123; <span class="comment">//arrays.length=3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">        System.out.print(array[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ul>
<li>数组的工具类java.util.Arrays</li>
<li>由于数组对象本身并没有什么方法可以供我们使用，但API提供了一个工具类Arrays供我们使用。</li>
<li>Array类中的方法都是static修饰的静态方法，使用时直接使用类名进行调用，可以不用对象调用。</li>
<li>常用功能<ul>
<li>给数组赋值：fill方法。</li>
<li>排序：sort方法，升序。</li>
<li>比较数组：equals方法比较数组中元素值是否相等。</li>
<li>查找数组元素：binarySearch对排序好的数组进行二分查找法操作。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9000</span>,<span class="number">32145</span>,<span class="number">451</span>,<span class="number">21</span>&#125;;</span><br><span class="line">System.out.println(a); <span class="comment">// [I@28d93b30 (hashcode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.toString 打印数组元素</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">//[1, 2, 3, 4, 9000, 32145, 451, 21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法查找某值 返回下标</span></span><br><span class="line">System.out.println(Arrays.binarySearch(a, <span class="number">9000</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">Arrays.fill(a,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>); <span class="comment">//数组[a[2]~a[4])之间填充0</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">//[1, 2, 0, 0, 9000, 32145, 451, 21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//升序排序</span></span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>冒泡排序是八大排序最出名的排序算法。</li>
<li>代码：两层循环，外层冒泡轮数，里层依次比较。</li>
<li>当我们看到嵌套循环，应该立马就可以得出这个算法的时间复杂度为O(n2)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="comment">//1.比较数组中两个相邻的元素，如果第一个数大于第二个数，交换它们位置</span></span><br><span class="line"><span class="comment">//2.每一次比较，都会产生一个最大或最小的数字(升序为最大数)</span></span><br><span class="line"><span class="comment">//3.下一轮则可以少一次排序</span></span><br><span class="line"><span class="comment">//4.依次循环，直到结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//外层循环，次数length-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//内层循环：如果第一个数大于第二个数，交换它们位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp=array[j];</span><br><span class="line">                array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a=&#123;<span class="number">8</span>,<span class="number">1</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">19</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] sort = sort(a);</span><br><span class="line">    System.out.println(Arrays.toString(sort)); <span class="comment">//[-2, 1, 8, 19, 35, 47]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>思考：如何优化？</li>
</ul>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427082948815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083015623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个二维数组 11*11  0：没有棋子，1：黑棋  2：白棋</span></span><br><span class="line"><span class="type">int</span>[][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">array1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">array1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//输出原始的数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;原始的数组：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] array : array1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为稀疏数组保存</span></span><br><span class="line"><span class="comment">//1.有效值的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//有效值总数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建一个稀疏数组</span></span><br><span class="line"><span class="type">int</span>[][] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.遍历二维数组，将有效值存放到稀疏数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array1[i].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            array2[count][<span class="number">0</span>] = i;</span><br><span class="line">            array2[count][<span class="number">1</span>] = j;</span><br><span class="line">            array2[count][<span class="number">2</span>] = array1[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.输出稀疏数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array2[i].length; j++) &#123;</span><br><span class="line">        System.out.print(array2[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">输出原始的数组</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	1	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	2	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">0	0	0	0	0	0	0	0	0	0	0	</span></span><br><span class="line"><span class="comment">稀疏数组</span></span><br><span class="line"><span class="comment">11	11	2	</span></span><br><span class="line"><span class="comment">1	2	1	</span></span><br><span class="line"><span class="comment">2	3	2	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="初识面向对象"><a href="#初识面向对象" class="headerlink" title="初识面向对象"></a>初识面向对象</h3><h4 id="面向过程-amp-面向对象"><a href="#面向过程-amp-面向对象" class="headerlink" title="面向过程&amp;面向对象"></a>面向过程&amp;面向对象</h4><ul>
<li>面向过程思想<ul>
<li>步骤清晰简单，第一步做什么，第二部做什么…</li>
<li>面向过程适合处理一些较为简单的问题</li>
</ul>
</li>
<li>面向对象思想<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
</li>
<li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</li>
</ul>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><ul>
<li>面向对象编程（Object-Oriented Programming, OOP）</li>
<li>本质：以类的方式组织代码，以对象的组织(封装)数据。</li>
<li>抽象</li>
<li>三大特性<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
<li>从认识论的角度考虑是先有对象后有类。对象是具体的事物，类是对象的抽象。</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><ul>
<li>类是一种抽象的数据类型，它是对某一类事物整体描述&#x2F;定义，但并不能代表某一个具体的事物。<ul>
<li>动物、植物、手机、电脑…</li>
<li>Person类、Pet类、Cat类等，都是用来描述&#x2F;定义某一具体的事物应该具备的特点和行为。</li>
</ul>
</li>
<li>对象是抽象概念的具体实例，如张三是人的一个具体实例、张三家里的狗旺财就是狗的一个具体实例。</li>
</ul>
<h3 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h3><ul>
<li>使用new来创建对象。</li>
<li>使用new关键字创建的时候，除了分配内存之外，还会给创建好的对象进行默认的初始化，以及对类中构造器的调用。</li>
<li>类中的构造器也被称为构造方法，创建对象时必须要调用。有以下特点：</li>
<li>必须和类的名字相同</li>
<li>没有返回类型，也不能写void</li>
<li>一个类即使什么都不写，也会存在一个默认的构造方法</li>
</ul>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//一个类即使什么都不写，也会存在一个默认的无参构造方法</span></span><br><span class="line">    <span class="comment">//显示地定义构造器</span></span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//作用：1. 使用new关键字，本质是在调用构造器</span></span><br><span class="line">    <span class="comment">//2. 用来初始化对象的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125; <span class="comment">//无参构造</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有参构造 3.一旦定义了有参构造，无参就必须显示定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Alt+insert 快捷键插入构造方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内存分析-1"><a href="#内存分析-1" class="headerlink" title="内存分析"></a>内存分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个宠物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//默认 null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age; 	<span class="comment">//默认 0</span></span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;叫了一声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用类，创建调用对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>();</span><br><span class="line">    </span><br><span class="line">        dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">        dog.age = <span class="number">3</span>;</span><br><span class="line">        dog.shout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象通过引用类型来操作：栈 - - -&gt;堆</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083120326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083125469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p>封装</p>
<ul>
<li><p>该露的露，该藏的藏</p>
<ul>
<li>我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据细节由自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li>
</ul>
</li>
<li><p>封装（数据的隐藏）</p>
<ul>
<li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，称为信息隐藏。</li>
</ul>
</li>
<li><p>作用</p>
<ol>
<li><p>提高程序的安全性，保护数据</p>
</li>
<li><p>隐藏代码的实现细节</p>
</li>
<li><p>统一接口</p>
</li>
<li><p>系统可维护性增加了</p>
</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083157156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>继承的本质是对某一批类的抽象，从而实现对世界更好地建模。</p>
</li>
<li><p>extends的意思是”扩展“。子类是父类的扩展，使用关键字extends来表示。</p>
</li>
<li><p>Java中类只有单继承，没有多继承！一个类只能继承一个父类。</p>
</li>
<li><p>继承是类与类之间的一种关系，此外还有依赖、组合、聚合等。</p>
</li>
<li><p>继承关系的两个类，一个为子类（派生类），一个为<strong>父类（基类）</strong>子类继承父类。</p>
</li>
<li><p>子类和父类之间，从意义上讲应该具有”is a“的关系。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类(子类)继承 人类(父类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123; <span class="comment">/*Person extends Object*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类继承了父类，就会拥有父类的全部方法，而private私有属性及方法无法继承。</li>
<li>在Java中，所有类，都默认直接或间接继承Object类 (Ctrl+H 可以查看类关系)</li>
<li>被final修饰的类，无法被继承（断子绝孙）。</li>
</ul>
<h3 id="super-amp-this"><a href="#super-amp-this" class="headerlink" title="super &amp; this"></a>super &amp; this</h3><ol>
<li>super()调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或构造方法中</li>
<li>**super()和this()**不能同时调用构造方法，因为this也必须写在第一行</li>
</ol>
<ul>
<li>super与this的区别：super代表父类对象的引用，只能在继承条件下使用；this调用自身对象，没有继承也可以使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">//隐藏代码，默认调用了父类的无参构造，要写只能写第一行</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083247265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083318162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><ul>
<li><p>重写：子类的方法必须与父类方法必须一致，方法体不同。</p>
</li>
<li><p>重写是方法的重写，与属性无关</p>
</li>
<li><p>重写方法只与非静态方法有关，与静态方法无关（静态方法不能被重写）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123; <span class="comment">//继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方法的调用之和左边定义的类型有关</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.test(); <span class="comment">//打印 A==&gt;test()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类的引用指向了子类，但静态方法没有被重写</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        b.test(); <span class="comment">//打印 B==&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改A.java, B.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//非静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写了B的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类的引用指向了子类</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//子类重写了父类的方法，执行子类的方法</span></span><br><span class="line">b.test(); <span class="comment">//打印变成了 A==&gt;test()</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">静态方法是类的方法，非静态方法是对象的方法</span></span><br><span class="line"><span class="comment">有static时，b调用了B类的方法，因为b是b类定义的</span></span><br><span class="line"><span class="comment">没有static时，b调用的是对象的方法，而b是A类new出来的对象，调用A的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态方法属于类，非静态方法属于对象</p>
</li>
<li><p>注意点：</p>
<ol>
<li><p>方法名、参数列表必须相同</p>
</li>
<li><p>修饰符范围可以扩大，不能缩小（public&gt;protect&gt;private）</p>
</li>
<li><p>抛出的异常 范围可以被缩小，不能扩大</p>
</li>
<li><p>被**static(属于类，不属于实例)，final(常量方法)，private(私有)**修饰的方法不能重写</p>
</li>
</ol>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>动态编译：类型</p>
</li>
<li><p>即同一方法可以根据发送对象的不同而采用不同的行为方式</p>
</li>
<li><p>一个对象的实际类型是确定的，但可以指向对象的引用可以有很多</p>
</li>
<li><p>多态存在条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类方法</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2021042708335834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<ul>
<li><p>注意点：</p>
<ul>
<li><p>多态是方法的多态，没有属性的多态</p>
</li>
<li><p>父类和子类，有联系 类型转换异常: ClassCastException</p>
</li>
<li><p>存在条件：继承关系，方法需要重写，父类引用指向子类对象！</p>
</li>
</ul>
</li>
</ul>
<h3 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h3><ul>
<li>instanceof 引用类型比较，判断一个对象是什么类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object &gt; String</span></span><br><span class="line">    <span class="comment">// Objest &gt; Person &gt; Student</span></span><br><span class="line">    <span class="comment">// Objest &gt; Person &gt; Teacher</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="comment">// X instanceof Y，X引用指向的对象是不是Y的子类</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Student); <span class="comment">//true</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Teacher); <span class="comment">//false</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> Object); <span class="comment">//true</span></span><br><span class="line">    System.out.println(object <span class="keyword">instanceof</span> String); <span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型之间的转化：父-子（高-低）,低可以转换为高</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Syudent</span>(); <span class="comment">//只能用Person方法（重写了用子类重写过的方法）</span></span><br><span class="line">    (Syudent)obj.go(); <span class="comment">//强转之后可以用Student方法(Student-&gt;go())</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型转换</strong></p>
<ol>
<li>父类引用指向子类的对象</li>
<li>把子类转换为父类，向上转型，会丢失自己原来的一些方法</li>
<li>把父类转换为子类，向下转型，强制转换，才调用子类方法</li>
<li>方便方法的调用(转型)，减少重复的代码，简洁。</li>
</ol>
<p><strong>Static</strong></p>
<ul>
<li>静态变量可以直接用类名访问，也称类变量。</li>
<li>静态变量(或方法)对于类，所有对象（实例）所共享。</li>
<li>静态区代码 加载类时一起被初始化，最早执行且只执行一次（第一次new）。</li>
<li>Math-&gt;随机数:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种随机数，不用导包</span></span><br><span class="line">        System.out.println(Math.random()); <span class="comment">//0.7562202902634543</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第二种随机数，静态导入包</span></span><br><span class="line">        System.out.println(random()); <span class="comment">//0.5391606223844663</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>抽象类(abstract)</p>
<ul>
<li>abstract修饰的类就是抽象类，修饰的方法就是抽象方法。</li>
<li>抽象类中可以没有抽象方法，但有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类不能使用new来创建对象，它是用来让子类继承的。</li>
<li>抽象方法只有方法的声明，没有实现，让其子类实现。</li>
<li>子类继承抽象类，必须实现抽象类的所有方法，否则该子类也要声明为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract 抽象类 类只能单继承（接口可以多继承）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Action</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//约束~有人帮我们实现~</span></span><br><span class="line">    <span class="comment">//抽象方法只有方法名，没有方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.不能new抽象类，只能靠子类去实现它，仅作为一个约束</span></span><br><span class="line">    <span class="comment">//2.抽象方法只能出现在抽象类中，抽象类可以有普通方法</span></span><br><span class="line">    <span class="comment">//3.抽象类有构造器，可以派生子类</span></span><br><span class="line">    <span class="comment">//4.抽象类的意义：约束，提高开发效率。但是类只能单继承，所以有局限 用的不多</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范(抽象方法)都有</li>
<li>接口：只有规范，没有方法实现，专业的约束！约束与实现分离：面向接口编程~</li>
<li>接口就是规范，定义的是一组规则，”你是什么…必须做什么…”的思想。</li>
<li>接口的本质是约束，就像人间法律一样，制定好大家都遵守。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interface接口,接口都要有继承类</span></span><br><span class="line"><span class="comment">//实现类（implements 可以继承多个接口）</span></span><br><span class="line"><span class="comment">//多继承，利用接口实现多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//定义的属性都是常量,默认修饰 public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">99</span>; <span class="comment">//一般不用</span></span><br><span class="line">    <span class="comment">//所有的定义的方法都是抽象的 默认public abstract</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点</p>
<ul>
<li>接口没有构造方法，不能被实例化</li>
<li>实现类必须要重写接口中的方法</li>
<li>实现类（implements） 可以实现多个接口</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li>内部类就是在一个类的内部再定义一个类，比如A类中定义了一个B类，那么B就是A的内部类，而A相对B来说就是外部类</li>
</ul>
<ol>
<li>成员内部类：可以操作外部类的私有属性及方法</li>
<li>静态内部类：static修饰，不能访问外部类私有属性</li>
<li>局部内部类：外部类的方法里定义的类</li>
<li>匿名内部类：没有名字初始化类</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083429180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>软件程序在运行过程中，经常可能遇到异常问题，异常英文(Exception)，意思是例外，这些例外情况需要我们写程序做出合理的处理，而不至于让程序崩溃。</p>
</li>
<li><p>异常指程序运行中出现的不期而至的各种状况：文件找不到，网络连接错误，非法参数等。</p>
</li>
<li><p>异常发生在程序运行期间，它影响了正常的执行流程。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083507444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><ul>
<li>检查型异常：最具代表性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如用户要打开一个不存在的文件时引发的异常，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常：是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时忽略。</li>
<li>错误Error：错误不是异常，而是脱离程序员控制的问题。错误在代码经常被忽略。例如当栈溢出，一个异常就发生了，它们在编译也检查不到。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083535592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083557330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2021042708360855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p>异常处理机制</p>
<ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理关键字：try、catch、finally、throw、throws</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//try监控区域</span></span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123; <span class="comment">//catch 捕获异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;程序出现异常，变量b不能为0&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123; <span class="comment">//一定会执行，处理善后工作，如关闭资源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123; <span class="comment">//抛出异常一般在方法中使用</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(); <span class="comment">//主动抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ctrl+Alt+T 快捷键插入 try-catch</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083645704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2021042708372149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083725235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210427083739287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZsbG93X3dpbmQ=,size_16,color_FFFFFF,t_70"></p>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a>集合介绍</h3><ul>
<li><strong>概念</strong>：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</li>
<li><strong>集合和数组的区别</strong>：</li>
</ul>
<ol>
<li>数组长度固定，集合长度不固定。</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li>
</ol>
<ul>
<li><strong>位置</strong>： java.util.*;</li>
</ul>
<h3 id="Collection体系集合"><a href="#Collection体系集合" class="headerlink" title="Collection体系集合"></a><strong>Collection体系集合</strong></h3><hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/ec57a697f1c31f2334d78d607d964db7.png"></p>
<h3 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a><strong>Collection父接口</strong></h3><hr>
<ul>
<li><p>特点：代表一组任意类型的对象，无序、无下标、不能重复。</p>
</li>
<li><p>Collection集合的方法：</p>
<ul>
<li>boolean add(Object obj) &#x2F;&#x2F;添加一个对象。</li>
<li>boolean addAll(Collection c) &#x2F;&#x2F;讲一个集合中的所有对象添加到此集合中。</li>
<li>void clear() &#x2F;&#x2F;清空此集合中的所有对象。</li>
<li>boolean contains(Object o) &#x2F;&#x2F;检查此集合中是否包含o对象。</li>
<li>boolean equals(Object o) &#x2F;&#x2F;比较此集合是否与指定对象相等。</li>
<li>boolean isEmpty() &#x2F;&#x2F;判断此集合是否为空。</li>
<li>boolean remove(Object o) &#x2F;&#x2F;在此集合中移除o对象。</li>
<li>int size() &#x2F;&#x2F;返回此集合中的元素个数。</li>
<li>Object[] toArray() &#x2F;&#x2F;姜此集合转换成数组。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection接口的使用（一）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        Collection collection=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();        </span><br><span class="line"><span class="comment">//      * 1.添加元素</span></span><br><span class="line">        Collection.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        Collection.add(<span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">        Collection.add(<span class="string">&quot;榴莲&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span>+collection.size());</span><br><span class="line">        System.out.println(collection);</span><br><span class="line"><span class="comment">//      * 2.删除元素</span></span><br><span class="line">        collection.remove(<span class="string">&quot;榴莲&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除之后：&quot;</span>+collection.size());</span><br><span class="line"><span class="comment">//      * 3.遍历元素</span></span><br><span class="line">        <span class="comment">//3.1 使用增强for </span></span><br><span class="line">        <span class="keyword">for</span>(Object object : collection)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 使用迭代器（迭代器专门用来遍历集合的一种方式）</span></span><br><span class="line">        <span class="comment">//hasnext();判断是否有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除当前元素</span></span><br><span class="line">        Iterator iterator=collection.Itertor();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasnext())&#123;</span><br><span class="line">            String object=(String)iterator.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="comment">//删除操作</span></span><br><span class="line">            <span class="comment">//collection.remove(s);引发错误：并发修改异常</span></span><br><span class="line">            <span class="comment">//iterator.remove();应使用迭代器的方法</span></span><br><span class="line"><span class="comment">//      * 4.判断</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;西瓜&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(collection.isEmpty());<span class="comment">//false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection接口的使用（二）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Collection collection=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">		Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">19</span>);</span><br><span class="line">		<span class="comment">//1.添加数据</span></span><br><span class="line">		collection.add(s1);</span><br><span class="line">		collection.add(s2);</span><br><span class="line">		collection.add(s3);</span><br><span class="line">		<span class="comment">//collection.add(s3);可重复添加相同对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+collection.size());</span><br><span class="line">		System.out.println(collection.toString());</span><br><span class="line">		<span class="comment">//2.删除数据</span></span><br><span class="line">		collection.remove(s1);</span><br><span class="line">		System.out.println(<span class="string">&quot;删除之后：&quot;</span>+collection.size());</span><br><span class="line">		<span class="comment">//3.遍历数据</span></span><br><span class="line">		<span class="comment">//3.1 增强for</span></span><br><span class="line">		<span class="keyword">for</span>(Object object:collection) &#123;</span><br><span class="line">			Student student=(Student) object;</span><br><span class="line">			System.out.println(student.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2迭代器</span></span><br><span class="line">		<span class="comment">//迭代过程中不能使用collection的删除方法</span></span><br><span class="line">		Iterator iterator=collection.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			Student student=(Student) iterator.next();</span><br><span class="line">			System.out.println(student.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断和上一块代码类似。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a><strong>Collection子接口</strong></h3><hr>
<h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h4><ul>
<li><p>特点：有序、有下标、元素可以重复。</p>
</li>
<li><p>方法：</p>
<ul>
<li>void add(int index,Object o) &#x2F;&#x2F;在index位置插入对象o。</li>
<li>boolean addAll(index,Collection c) &#x2F;&#x2F;将一个集合中的元素添加到此集合中的index位置。</li>
<li>Object get(int index) &#x2F;&#x2F;返回集合中指定位置的元素。</li>
<li>List subList(int fromIndex,int toIndex) &#x2F;&#x2F;返回fromIndex和toIndex之间的集合元素。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List子接口的使用（一）</span></span><br><span class="line"><span class="comment"> * 特点：1.有序有下标 2.可以重复</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> * 5.获取位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		list.add(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">		list.add(<span class="number">0</span>,<span class="string">&quot;yu&quot;</span>);<span class="comment">//插入操作</span></span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+list.size());</span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		list.remove(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//list.remove(&quot;yu&quot;);结果同上</span></span><br><span class="line">		System.out.println(<span class="string">&quot;删除之后：&quot;</span>+list.size());</span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">		<span class="comment">//3.遍历元素</span></span><br><span class="line">		<span class="comment">//3.1 使用for遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();++i) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2 使用增强for</span></span><br><span class="line">		<span class="keyword">for</span>(Object object:list) &#123;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.3 使用迭代器</span></span><br><span class="line">		Iterator iterator=list.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.4使用列表迭代器，listIterator可以双向遍历，添加、删除及修改元素。</span></span><br><span class="line">		ListIterator listIterator=list.listIterator();</span><br><span class="line">		<span class="comment">//从前往后</span></span><br><span class="line">		<span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(listIterator.next());		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从后往前（此时“遍历指针”已经指向末尾）</span></span><br><span class="line">		<span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">			System.out.println(listIterator.previous());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(list.isEmpty());</span><br><span class="line">		System.out.println(list.contains(<span class="string">&quot;tang&quot;</span>));</span><br><span class="line">		<span class="comment">//5.获取位置</span></span><br><span class="line">		System.out.println(list.indexOf(<span class="string">&quot;tang&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List子接口的使用（二）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> * 5.获取位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		<span class="comment">//1.添加数字数据（自动装箱）</span></span><br><span class="line">		list.add(<span class="number">20</span>);</span><br><span class="line">		list.add(<span class="number">30</span>);</span><br><span class="line">		list.add(<span class="number">40</span>);</span><br><span class="line">		list.add(<span class="number">50</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+list.size());</span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		list.remove(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//list.remove(20);很明显数组越界错误，改成如下</span></span><br><span class="line">		<span class="comment">//list.remove(Object(20));</span></span><br><span class="line">		<span class="comment">//list.remove(new Integer(20));</span></span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+list.size());</span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">		<span class="comment">//3-5不再演示，与之前类似</span></span><br><span class="line">		<span class="comment">//6.补充方法subList，返回子集合，含头不含尾</span></span><br><span class="line">		List list2=list.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		System.out.println(list2.toString());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a><strong>List实现类</strong></h3><h4 id="ArrayList-重点"><a href="#ArrayList-重点" class="headerlink" title="ArrayList[重点]"></a><strong>ArrayList[重点]</strong></h4><ul>
<li>数组结构实现，查询块、增删慢；</li>
<li>JDK1.2版本，运行效率快、线程不安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：数组；</span></span><br><span class="line"><span class="comment"> * 特点：查找遍历速度快，增删慢。</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历元素</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> * 5.查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayList arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;唐&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;何&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;余&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		arrayList.add(s1);</span><br><span class="line">		arrayList.add(s2);</span><br><span class="line">		arrayList.add(s3);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+arrayList.size());</span><br><span class="line">		System.out.println(arrayList.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		arrayList.remove(s1);</span><br><span class="line">		<span class="comment">//arrayList.remove(new Student(&quot;唐&quot;, 21));</span></span><br><span class="line">		<span class="comment">//注：这样可以删除吗（不可以）？显然这是两个不同的对象。</span></span><br><span class="line">		<span class="comment">//假如两个对象属性相同便认为其是同一对象，那么如何修改代码？</span></span><br><span class="line">		<span class="comment">//3.遍历元素</span></span><br><span class="line">		<span class="comment">//3.1使用迭代器</span></span><br><span class="line">		Iterator iterator=arrayList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2使用列表迭代器</span></span><br><span class="line">		ListIterator listIterator=arrayList.listIterator();</span><br><span class="line">		<span class="comment">//从前往后遍历</span></span><br><span class="line">		<span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(listIterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从后往前遍历</span></span><br><span class="line">		<span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">			System.out.println(listIterator.previous());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(arrayList.isEmpty());</span><br><span class="line">		<span class="comment">//System.out.println(arrayList.contains(new Student(&quot;何&quot;, 22)));</span></span><br><span class="line">		<span class="comment">//注：与上文相同的问题。</span></span><br><span class="line">		<span class="comment">//5.查找</span></span><br><span class="line">		System.out.println(arrayList.indexOf(s1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：Object里的equals(this&#x3D;&#x3D;obj)用地址和当前对象比较，如果想实现代码中的问题，可以在学生类中重写equals方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	<span class="comment">//1.是否为同一对象</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>==obj) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.判断是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (obj==<span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.判断是否是Student类型</span></span><br><span class="line">	<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">		Student student=(Student) obj;</span><br><span class="line">		<span class="comment">//4.比较属性</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.name.equals(student.getName())&amp;&amp;<span class="built_in">this</span>.age==student.age) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不满足，返回false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a><strong>ArrayList源码分析</strong></h3><ul>
<li>默认容量大小：<code>private static final int DEFAULT_CAPACITY = 10;</code></li>
<li>存放元素的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>：<code>transient Object[] elementData;</code></li>
<li>实际元素个数：<code>private int size;</code></li>
<li>创建对象时调用的无参构造函数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">//这是一个空的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码说明当你没有向集合中添加任何元素时，集合容量为0。那么默认的10个容量怎么来的呢？</p>
<p>这就得看看add方法的源码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设你new了一个数组，当前容量为0，size当然也为0。这时调用add方法进入到<code>ensureCapacityInternal(size + 1);</code>该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的参数minCapacity传入的值为size+1也就是 1，接着我们再进入到<code>calculateCapacity(elementData, minCapacity)</code>里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文说过，elementData就是存放元素的数组，当前容量为0，if条件成立，返回默认容量<code>DEFAULT_CAPACITY</code>也就是10。这个值作为参数又传入<code>ensureExplicitCapacity()</code>方法中，进入该方法查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先不要管modCount这个变量。</p>
<p>因为elementData数组长度为0，所以if条件成立，调用grow方法，<strong>重要的部分来了</strong>，我们再次进入到grow方法的源码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法先声明了一个oldCapacity变量将数组长度赋给它，其值为0；又声明了一个newCapacity变量其值为oldCapacity+一个增量，可以发现这个增量是和原数组长度有关的量，当然在这里也为0。第一个if条件满足，newCapacity的值为10（这就是默认的容量，不理解的话再看看前面）。第二个if条件不成立，也可以不用注意，因为MAX_ARRAY_SIZE的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>这个值太大了以至于第二个if条件没有了解的必要。</p>
<p>最后一句话就是为elementData数组赋予了新的长度，<code>Arrays.copyOf()</code>方法返回的数组是新的数组对象，原数组对象不会改变，该拷贝不会影响原来的数组。<code>copyOf()</code>的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。</p>
<p>这时候再回到add的方法中，接着就向下执行<code>elementData[size++] = e;</code>到这里为止关于ArrayList就讲解得差不多了，当数组长度为10的时候你们可以试着过一下源码，查一下每次的增量是多少（答案是每次扩容为原来的1.5倍）。</p>
<hr>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h3><ul>
<li>数组结构实现，查询快、增删慢；</li>
<li>JDK1.0版本，运行效率慢、线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector的演示使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *1.添加数据</span></span><br><span class="line"><span class="comment"> *2.删除数据</span></span><br><span class="line"><span class="comment"> *3.遍历</span></span><br><span class="line"><span class="comment"> *4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Vector vector=<span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//1.添加数据</span></span><br><span class="line">		vector.add(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">		vector.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">		vector.add(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+vector.size());</span><br><span class="line">		<span class="comment">//2.删除数据</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * vector.remove(0); vector.remove(&quot;tang&quot;);</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//3.遍历</span></span><br><span class="line">		<span class="comment">//使用枚举器</span></span><br><span class="line">		Enumeration enumeration=vector.elements();</span><br><span class="line">		<span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) enumeration.nextElement();</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(vector.isEmpty());</span><br><span class="line">		System.out.println(vector.contains(<span class="string">&quot;he&quot;</span>));</span><br><span class="line">		<span class="comment">//5. Vector其他方法</span></span><br><span class="line">		<span class="comment">//firstElement()  lastElement()  ElementAt();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h3><ul>
<li>链表结构实现，增删快，查询慢。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList的用法</span></span><br><span class="line"><span class="comment"> * 存储结构：双向链表</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		LinkedList linkedList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;唐&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;何&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;余&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		linkedList.add(s1);</span><br><span class="line">		linkedList.add(s2);</span><br><span class="line">		linkedList.add(s3);</span><br><span class="line">		linkedList.add(s3);</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span>+linkedList.size());</span><br><span class="line">		System.out.println(linkedList.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * linkedList.remove(new Student(&quot;唐&quot;, 21));</span></span><br><span class="line"><span class="comment">		 * System.out.println(linkedList.toString());</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//3.遍历</span></span><br><span class="line">		<span class="comment">//3.1 使用for</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;linkedList.size();++i) &#123;</span><br><span class="line">			System.out.println(linkedList.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2 使用增强for</span></span><br><span class="line">		<span class="keyword">for</span>(Object object:linkedList) &#123;</span><br><span class="line">			Student student=(Student) object;</span><br><span class="line">			System.out.println(student.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.3 使用迭代器</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span>linkedList.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) iterator.next();</span><br><span class="line">			System.out.println(student.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.4 使用列表迭代器（略）</span></span><br><span class="line">		<span class="comment">//4. 判断</span></span><br><span class="line">		System.out.println(linkedList.contains(s1));</span><br><span class="line">		System.out.println(linkedList.isEmpty());</span><br><span class="line">		System.out.println(linkedList.indexOf(s3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a><strong>LinkedList源码分析</strong></h3><p>LinkedList首先有三个属性：</p>
<ul>
<li>链表大小：<code>transient int size = 0;</code></li>
<li>（指向）第一个结点&#x2F;头结点：<code>transient Node&lt;E&gt; first;</code></li>
<li>（指向）最后一个结点&#x2F;尾结点：<code>transient Node&lt;E&gt; last;</code></li>
</ul>
<p>关于Node类型我们再进入到类里看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYprivate <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先item存放的是实际数据；next指向下一个结点而prev指向上一个结点。</p>
<p>Node带参构造方法的三个参数分别是前一个结点、存储的数据、后一个结点，调用这个构造方法时将它们赋值给当前对象。</p>
<p>LinkedList是如何添加元素的呢？先看看add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到linkLast方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYvoid <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设刚开始new了一个LinkedList对象，first和last属性都为空，调用add进入到linkLast方法。</p>
<p>首先创建一个Node变量 l 将last（此时为空）赋给它，然后new一个newNode变量存储数据，并且它的前驱指向l，后继指向null；再把last指向newNode。如下图所示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/ae12bb2d7845cbb64a36735b03690d89.png" alt="img"></p>
<p>如果满足if条件，说明这是添加的第一个结点，将first指向newNode：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/b63e4bdd2f9ab42fcd889ac4641870ab.png" alt="img"></p>
<p>至此，LinkedList对象的第一个数据添加完毕。假设需要再添加一个数据，我们可以再来走一遍，过程同上不再赘述，图示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/b6f7a151d5812d87ae71c2780fe03e05.png" alt="img"></p>
<hr>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList和LinkedList区别</strong></h3><ul>
<li>ArrayList：必须开辟连续空间，查询快，增删慢。</li>
<li>LinkedList：无需开辟连续空间，查询慢，增删快。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/012adef307ddd114e6947ebc7e39c18b.png" alt="img"></p>
<hr>
<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a><strong>泛型概述</strong></h2><ul>
<li>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。</li>
<li>常见形式有泛型类、泛型接口、泛型方法。</li>
<li>语法：<ul>
<li>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</li>
</ul>
</li>
<li>好处：<ul>
<li>提高代码的重用性。</li>
<li>防止类型转换异常，提高代码的安全性。</li>
</ul>
</li>
</ul>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类</span></span><br><span class="line"><span class="comment"> * 语法：类名&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myGeneric</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="comment">//1.创建泛型变量</span></span><br><span class="line">	<span class="comment">//不能使用new来创建，因为泛型是不确定的类型，也可能拥有私密的构造方法。</span></span><br><span class="line">	T t;</span><br><span class="line">	<span class="comment">//2.泛型作为方法的参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//泛型作为方法的返回值</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1.泛型只能使用引用类型</span></span><br><span class="line"><span class="comment"> * 2.不同泛型类型的对象不能相互赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testGeneric</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//使用泛型类创建对象</span></span><br><span class="line">		myGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> <span class="title class_">myGeneric</span>&lt;String&gt;();</span><br><span class="line">		myGeneric1.t=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">		myGeneric1.show(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		myGeneric&lt;Integer&gt; myGeneric2=<span class="keyword">new</span> <span class="title class_">myGeneric</span>&lt;Integer&gt;();</span><br><span class="line">		myGeneric2.t=<span class="number">10</span>;</span><br><span class="line">		myGeneric2.show(<span class="number">20</span>);</span><br><span class="line">		Integer integer=myGeneric2.getT();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a><strong>泛型接口</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口</span></span><br><span class="line"><span class="comment"> * 语法：接口名&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 注意：不能创建泛型静态常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//创建常量</span></span><br><span class="line">	String nameString=<span class="string">&quot;tang&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	T <span class="title function_">server</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现接口时确定泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">server</span><span class="params">(String t)</span> &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		<span class="keyword">return</span> t; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">//测试</span></span><br><span class="line">MyInterfaceImpl myInterfaceImpl=<span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>();</span><br><span class="line">myInterfaceImpl.server(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//xxx</span></span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现接口时不确定泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">server</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">//测试</span></span><br><span class="line">MyInterfaceImpl2&lt;Integer&gt; myInterfaceImpl2=<span class="keyword">new</span> <span class="title class_">MyInterfaceImpl2</span>&lt;Integer&gt;();</span><br><span class="line">myInterfaceImpl2.server(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//2000</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><strong>泛型方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法</span></span><br><span class="line"><span class="comment"> * 语法：&lt;T&gt; 返回类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericMethod</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;泛型方法&quot;</span>+t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">//测试</span></span><br><span class="line">MyGenericMethod myGenericMethod=<span class="keyword">new</span> <span class="title class_">MyGenericMethod</span>();</span><br><span class="line">myGenericMethod.show(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">myGenericMethod.show(<span class="number">200</span>);</span><br><span class="line">myGenericMethod.show(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure>

<h3 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a><strong>泛型集合</strong></h3><ul>
<li><p>概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p>
</li>
<li><p>特点：</p>
<ul>
<li>编译时即可检查，而非运行时抛出异常。</li>
<li>访问时，不必类型转换（拆箱）。</li>
<li>不同泛型指尖引用不能相互赋值，泛型不存在多态。</li>
</ul>
</li>
</ul>
<p>之前我们在创建LinkedList类型对象的时候并没有使用泛型，但是进到它的源码中会发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;<span class="comment">//略&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Set集合概述"><a href="#Set集合概述" class="headerlink" title="Set集合概述"></a><strong>Set集合概述</strong></h2><h3 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a><strong>Set子接口</strong></h3><ul>
<li><strong>特点</strong>：无序、无下标、元素不可重复。</li>
<li><strong>方法</strong>：全部继承自Collection中的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Set接口的使用</span></span><br><span class="line"><span class="comment"> * 特点：1.无序，没有下标；2.重复</span></span><br><span class="line"><span class="comment"> * 1.添加数据</span></span><br><span class="line"><span class="comment"> * 2.删除数据</span></span><br><span class="line"><span class="comment"> * 3.遍历【重点】</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">		<span class="comment">//1.添加数据</span></span><br><span class="line">		set.add(<span class="string">&quot;tang&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;数据个数：&quot;</span>+set.size());</span><br><span class="line">		System.out.println(set.toString());<span class="comment">//无序输出</span></span><br><span class="line">		<span class="comment">//2.删除数据</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * set.remove(&quot;tang&quot;); System.out.println(set.toString());</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//3.遍历【重点】</span></span><br><span class="line">		<span class="comment">//3.1 使用增强for</span></span><br><span class="line">		<span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2 使用迭代器</span></span><br><span class="line">		Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(set.contains(<span class="string">&quot;tang&quot;</span>));</span><br><span class="line">		System.out.println(set.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set实现类"><a href="#Set实现类" class="headerlink" title="Set实现类"></a><strong>Set实现类</strong></h2><h3 id="HashSet【重点】"><a href="#HashSet【重点】" class="headerlink" title="HashSet【重点】"></a><strong>HashSet【重点】</strong></h3><ul>
<li>基于HashCode计算元素存放位置。</li>
<li>当存入元素的哈希码相同时，会调用equals进行确认，如结果为true，则拒绝后者存入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Peerson [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet集合的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：哈希表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment"> * 1.添加元素</span></span><br><span class="line"><span class="comment"> * 2.删除元素</span></span><br><span class="line"><span class="comment"> * 3.遍历</span></span><br><span class="line"><span class="comment"> * 4.判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		HashSet&lt;Person&gt; hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);</span><br><span class="line">		Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		Person p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		hashSet.add(p1);</span><br><span class="line">		hashSet.add(p2);</span><br><span class="line">		hashSet.add(p3);</span><br><span class="line">        <span class="comment">//重复，添加失败</span></span><br><span class="line">        hashSet.add(p3);</span><br><span class="line">        <span class="comment">//直接new一个相同属性的对象，依然会被添加，不难理解。</span></span><br><span class="line">        <span class="comment">//假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>));</span><br><span class="line">		System.out.println(hashSet.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		hashSet.remove(p2);</span><br><span class="line">		<span class="comment">//3.遍历</span></span><br><span class="line">		<span class="comment">//3.1 增强for</span></span><br><span class="line">		<span class="keyword">for</span> (Person person : hashSet) &#123;</span><br><span class="line">			System.out.println(person);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2 迭代器</span></span><br><span class="line">		Iterator&lt;Person&gt; iterator=hashSet.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(hashSet.isEmpty());</span><br><span class="line">        <span class="comment">//直接new一个相同属性的对象结果输出是false，不难理解。</span></span><br><span class="line">        <span class="comment">//注：假如相同属性便认为是同一个对象，该怎么做？</span></span><br><span class="line">		System.out.println(hashSet.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：hashSet存储过程：</p>
<ol>
<li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li>
<li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li>
</ol>
<p>存储过程实际上就是重复依据，要实现“注”里的问题，可以重写hashCode和equals代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    result = prime * result + age;</span><br><span class="line">    result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">if</span> (age != other.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode方法里为什么要使用31这个数字大概有两个原因：</p>
<ol>
<li>31是一个质数，这样的数字在计算时可以尽量减少散列冲突。</li>
<li>可以提高执行效率，因为31*i&#x3D;(i&lt;&lt;5)-i，31乘以一个数可以转换成移位操作，这样能快一点；但是也有网上一些人对这两点提出质疑。</li>
</ol>
<hr>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h3><ul>
<li>基于排序顺序实现不重复。</li>
<li>实现了SortedSet接口，对集合元素自动排序。</li>
<li>元素对象的类型必须实现Comparable接口，指定排序规则。</li>
<li>通过CompareTo方法确定是否为重复元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用TreeSet保存数据</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> * 要求：元素类必须实现Comparable接口，compareTo方法返回0，认为是重复元素 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Person&gt;();</span><br><span class="line">		Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);</span><br><span class="line">		Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		Person p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		persons.add(p1);</span><br><span class="line">		persons.add(p2);</span><br><span class="line">		persons.add(p3);</span><br><span class="line">		<span class="comment">//注：直接添加会报类型转换错误，需要实现Comparable接口</span></span><br><span class="line">		System.out.println(persons.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		persons.remove(p1);</span><br><span class="line">		persons.remove(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>));</span><br><span class="line">		System.out.println(persons.toString());</span><br><span class="line">		<span class="comment">//3.遍历（略）</span></span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(persons.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看Comparable接口的源码，发现只有一个compareTo抽象方法，在人类中实现它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//1.先按姓名比</span></span><br><span class="line">	<span class="comment">//2.再按年龄比</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">		<span class="type">int</span> n1=<span class="built_in">this</span>.getName().compareTo(o.getName());</span><br><span class="line">		<span class="type">int</span> n2=<span class="built_in">this</span>.age-o.getAge();</span><br><span class="line">		<span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet的使用</span></span><br><span class="line"><span class="comment"> * Comparator：实现定制比较（比较器）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">				<span class="comment">// 先按年龄比较</span></span><br><span class="line">				<span class="comment">// 再按姓名比较</span></span><br><span class="line">				<span class="type">int</span> n1=o1.getAge()-o2.getAge();</span><br><span class="line">				<span class="type">int</span> n2=o1.getName().compareTo(o2.getName());</span><br><span class="line">				<span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tang&quot;</span>,<span class="number">21</span>);</span><br><span class="line">		Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		Person p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		persons.add(p1);</span><br><span class="line">		persons.add(p2);</span><br><span class="line">		persons.add(p3);</span><br><span class="line">		System.out.println(persons.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来做一个小案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要求：使用TreeSet集合实现字符串按照长度进行排序</span></span><br><span class="line"><span class="comment"> * helloworld tangrui hechengyang wangzixu yuguoming</span></span><br><span class="line"><span class="comment"> * Comparator接口实现定制比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="comment">//先比较字符串长度</span></span><br><span class="line">			<span class="comment">//再比较字符串</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">				<span class="type">int</span> n1=o1.length()-o2.length();</span><br><span class="line">				<span class="type">int</span> n2=o1.compareTo(o2);</span><br><span class="line">				<span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		treeSet.add(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">		treeSet.add(<span class="string">&quot;tangrui&quot;</span>);</span><br><span class="line">		treeSet.add(<span class="string">&quot;hechenyang&quot;</span>);</span><br><span class="line">		treeSet.add(<span class="string">&quot;yuguoming&quot;</span>);</span><br><span class="line">		treeSet.add(<span class="string">&quot;wangzixu&quot;</span>);</span><br><span class="line">		System.out.println(treeSet.toString());</span><br><span class="line">        <span class="comment">//输出[tangrui, wangzixu, yuguoming, hechenyang, helloworld]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map集合概述"><a href="#Map集合概述" class="headerlink" title="Map集合概述"></a><strong>Map集合概述</strong></h2><h3 id="Map体系集合"><a href="#Map体系集合" class="headerlink" title="Map体系集合"></a><strong>Map体系集合</strong></h3><ul>
<li><p>Map接口的特点：</p>
<ol>
<li><p>用于存储任意键值对(Key-Value)。	</p>
</li>
<li><p>键：无序、无下标、不允许重复（唯一）。</p>
</li>
<li><p>值：无序、无下标、允许重复。</p>
</li>
</ol>
</li>
<li><p>特点：存储一对数据（Key-Value），无序、无下标，键不可重复。</p>
</li>
<li><p>方法：</p>
<ul>
<li><p>V put(K key,V value)&#x2F;&#x2F;将对象存入到集合中，关联键值。key重复则覆盖原值。</p>
</li>
<li><p>Object get(Object key)&#x2F;&#x2F;根据键获取相应的值。</p>
</li>
<li><p>Set<K>&#x2F;&#x2F;返回所有的key</K></p>
</li>
<li><p>Collection<V> values()&#x2F;&#x2F;返回包含所有值的Collection集合。</V></p>
</li>
<li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt;&#x2F;&#x2F;键值匹配的set集合</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map接口的使用</span></span><br><span class="line"><span class="comment"> * 特点：1.存储键值对 2.键不能重复，值可以重复 3.无序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		map.put(<span class="string">&quot;tang&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		map.put(<span class="string">&quot;he&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		map.put(<span class="string">&quot;fan&quot;</span>, <span class="number">23</span>);</span><br><span class="line">		System.out.println(map.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		map.remove(<span class="string">&quot;he&quot;</span>);</span><br><span class="line">		System.out.println(map.toString());</span><br><span class="line">		<span class="comment">//3.遍历</span></span><br><span class="line">		<span class="comment">//3.1 使用keySet();</span></span><br><span class="line">		<span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">			System.out.println(key+<span class="string">&quot; &quot;</span>+map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2 使用entrySet();效率较高</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">			System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Map集合的实现类"><a href="#Map集合的实现类" class="headerlink" title="Map集合的实现类"></a><strong>Map集合的实现类</strong></h3><h3 id="HashMap【重点】"><a href="#HashMap【重点】" class="headerlink" title="HashMap【重点】"></a><strong>HashMap【重点】</strong></h3><ul>
<li>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 学生类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  	<span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">private</span> <span class="type">int</span> id;	</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">  		<span class="built_in">super</span>();</span><br><span class="line">  		<span class="built_in">this</span>.name = name;</span><br><span class="line">  		<span class="built_in">this</span>.id = id;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> name;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  		<span class="built_in">this</span>.name = name;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> id;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">  		<span class="built_in">this</span>.id = id;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HashMap的使用</span></span><br><span class="line"><span class="comment">   * 存储结构：哈希表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  		HashMap&lt;Student, String&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student, String&gt;();</span><br><span class="line">  		Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tang&quot;</span>, <span class="number">36</span>);</span><br><span class="line">  		Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">101</span>);</span><br><span class="line">  		Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  		<span class="comment">//1.添加元素</span></span><br><span class="line">  		hashMap.put(s1, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">  		hashMap.put(s2, <span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">  		hashMap.put(s3, <span class="string">&quot;郑州&quot;</span>);</span><br><span class="line">  		<span class="comment">//添加失败，但会更新值</span></span><br><span class="line">  		hashMap.put(s3,<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">  		<span class="comment">//添加成功，不过两个属性一模一样；</span></span><br><span class="line">  		<span class="comment">//注：假如相同属性便认为是同一个对象，怎么修改？</span></span><br><span class="line">  		hashMap.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>),<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">  		System.out.println(hashMap.toString());</span><br><span class="line">  		<span class="comment">//2.删除元素</span></span><br><span class="line">  		hashMap.remove(s3);</span><br><span class="line">  		System.out.println(hashMap.toString());</span><br><span class="line">  		<span class="comment">//3.遍历</span></span><br><span class="line">  		<span class="comment">//3.1 使用keySet()遍历</span></span><br><span class="line">  		<span class="keyword">for</span> (Student key : hashMap.keySet()) &#123;</span><br><span class="line">  			System.out.println(key+<span class="string">&quot; &quot;</span>+hashMap.get(key));</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//3.2 使用entrySet()遍历</span></span><br><span class="line">  		<span class="keyword">for</span> (Entry&lt;Student, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">  			System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//4.判断</span></span><br><span class="line">  		<span class="comment">//注：同上</span></span><br><span class="line">  		System.out.println(hashMap.containsKey(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>)));</span><br><span class="line">  		System.out.println(hashMap.containsValue(<span class="string">&quot;成都&quot;</span>));</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      result = prime * result + id;</span><br><span class="line">      result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">other</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">      <span class="keyword">if</span> (id != other.id)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><ul>
<li><p>默认初始化容量：static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</p>
<ul>
<li>数组最大容量：static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</li>
</ul>
</li>
<li><p>默认加载因子：static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</p>
</li>
<li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：static final int TREEIFY_THRESHOLD &#x3D; 8;</p>
</li>
<li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：static final int UNTREEIFY_THRESHOLD &#x3D; 6;</p>
</li>
<li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</p>
</li>
<li><p>HashMap存储的数组：transient Node&lt;K,V&gt;[] table;</p>
</li>
<li><p>HashMap存储的元素个数：transient int size;</p>
</li>
</ul>
<blockquote>
<ul>
<li>默认加载因子是什么？<ul>
<li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素超过了100*0.75&#x3D;75，那么就会进行扩容。</li>
</ul>
</li>
<li>链表调整为红黑树的链表长度阈值是什么？<ul>
<li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li>
</ul>
</li>
<li>红黑树调整为链表的链表长度阈值是什么？<ul>
<li>当红黑树的元素个数小于该阈值时就会转换成链表。</li>
</ul>
</li>
<li>链表调整为红黑树的数组最小阈值是什么？<ul>
<li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li>
</ul>
</li>
</ul>
</blockquote>
<p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYstatic <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p>
<p>当我们往对象里添加元素时调用put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                    <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//略</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75&#x3D;12时，就会进行扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>扩容的代码如下（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> newCap;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//略&#125;</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p>
<p><em>注</em>：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</p>
<hr>
<h2 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h2><p>了解完HashMap之后，再回过头来看之前的HashSet源码，为什么放在后面写你们看一下源码就知道了（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">          map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul>
<li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p>
</li>
<li><p>初始容量11，加载因子0.75。</p>
</li>
<li><p>这个集合在开发过程中已经不用了，稍微了解即可。</p>
</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul>
<li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li>
<li>它继承了Hashtable的方法，与流关系密切，此处不详解。</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul>
<li>实现了SortedMap接口（是Map的子接口），可以对key自动排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap的使用</span></span><br><span class="line"><span class="comment"> * 存储结构：红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeMap&lt;Student, Integer&gt; treeMap=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Student, Integer&gt;();</span><br><span class="line">		Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tang&quot;</span>, <span class="number">36</span>);</span><br><span class="line">		Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">101</span>);</span><br><span class="line">		Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="comment">//1.添加元素</span></span><br><span class="line">		treeMap.put(s1, <span class="number">21</span>);</span><br><span class="line">		treeMap.put(s2, <span class="number">22</span>);</span><br><span class="line">		treeMap.put(s3, <span class="number">21</span>);</span><br><span class="line">		<span class="comment">//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span></span><br><span class="line">		System.out.println(treeMap.toString());</span><br><span class="line">		<span class="comment">//2.删除元素</span></span><br><span class="line">		treeMap.remove(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;he&quot;</span>, <span class="number">10</span>));</span><br><span class="line">		System.out.println(treeMap.toString());</span><br><span class="line">		<span class="comment">//3.遍历</span></span><br><span class="line">		<span class="comment">//3.1 使用keySet()</span></span><br><span class="line">		<span class="keyword">for</span> (Student key : treeMap.keySet()) &#123;</span><br><span class="line">			System.out.println(key+<span class="string">&quot; &quot;</span>+treeMap.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2 使用entrySet()</span></span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">			System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.判断</span></span><br><span class="line">		System.out.println(treeMap.containsKey(s1));</span><br><span class="line">		System.out.println(treeMap.isEmpty());		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学生类中实现Comparable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.id-o.id;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还可以使用比较器来定制比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYTreeMap&lt;Student, Integer&gt; treeMap2=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Student, Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;			</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a><strong>TreeSet源码</strong></h2><p>和HashSet类似，放在TreeMap之后讲便一目了然（部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPYpublic <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p>
<hr>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><ul>
<li><p>概念：集合工具类，定义了除了存取以外的集合常用方法。</p>
</li>
<li><p>方法：</p>
<ul>
<li>public static void reverse(List&lt;?&gt; list)&#x2F;&#x2F;反转集合中元素的顺序</li>
<li>public static void shuffle(List&lt;?&gt; list)&#x2F;&#x2F;随机重置集合元素的顺序</li>
<li>public static void sort(List<T> list)&#x2F;&#x2F;升序排序（元素类型必须实现Comparable接口）</T></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COPY<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Collections工具类的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">		list.add(<span class="number">20</span>);</span><br><span class="line">		list.add(<span class="number">10</span>);</span><br><span class="line">		list.add(<span class="number">30</span>);</span><br><span class="line">		list.add(<span class="number">90</span>);</span><br><span class="line">		list.add(<span class="number">70</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//sort排序</span></span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">		Collections.sort(list);</span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">		System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//binarySearch二分查找</span></span><br><span class="line">		<span class="type">int</span> i=Collections.binarySearch(list, <span class="number">10</span>);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//copy复制</span></span><br><span class="line">		List&lt;Integer&gt; list2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;<span class="number">5</span>;++i1) &#123;</span><br><span class="line">			list2.add(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//该方法要求目标元素容量大于等于源目标</span></span><br><span class="line">		Collections.copy(list2, list);</span><br><span class="line">		System.out.println(list2.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//reserve反转</span></span><br><span class="line">		Collections.reverse(list2);</span><br><span class="line">		System.out.println(list2.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//shuffle 打乱</span></span><br><span class="line">		Collections.shuffle(list2);</span><br><span class="line">		System.out.println(list2.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//补充：list转成数组</span></span><br><span class="line">		Integer[] arr=list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line">		System.out.println(arr.length);</span><br><span class="line">		<span class="comment">//补充：数组转成集合 </span></span><br><span class="line">		String[] nameStrings= &#123;<span class="string">&quot;tang&quot;</span>,<span class="string">&quot;he&quot;</span>,<span class="string">&quot;yu&quot;</span>&#125;;</span><br><span class="line">		<span class="comment">//受限集合，不能添加和删除</span></span><br><span class="line">		List&lt;String&gt; list3=Arrays.asList(nameStrings);</span><br><span class="line">		System.out.println(list3);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//注：基本类型转成集合时需要修改为包装类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="IO简介"><a href="#IO简介" class="headerlink" title="IO简介"></a>IO简介</h2><h3 id="流Stream"><a href="#流Stream" class="headerlink" title="流Stream"></a>流<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Stream&spm=1001.2101.3001.7020">Stream</a></h3><p>在学习IO流之前,我们首先需要学习的概念就是Stream流<br>为了方便理解,我们可以把数据的读写操作抽象成数据在”管道”中流动,但需注意:<br>1.流只能单方向流动<br>2.输入流用来读取 → in<br>3.输出流用来写出 → out<br>4.数据只能从头到尾顺序的读写一次<br>所以以程序的角度来思考,In&#x2F;out 相对于程序而言的输入(读取)&#x2F;输出(写出)的过程.<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210517222902925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="IO流的继承结构"><a href="#IO流的继承结构" class="headerlink" title="IO流的继承结构"></a>IO流的继承结构</h3><p>在java中,根据处理的数据单位不同,可以把流分为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E6%B5%81&spm=1001.2101.3001.7020">字节流</a>和字符流<br>字节流 : 针对<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>文件<br><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81&spm=1001.2101.3001.7020">字符流</a> : 针对文本文件<br>再结合对应类型的输入和输出方向,常用的流有:</p>
<blockquote>
<p>File<br>字节流:针对二进制文件<br>InputStream<br>FileInputStream<br>BufferedInputStream<br>ObjectInputStream<br>OutputStream<br>FileOutputStream<br>BufferedOutputStream<br>ObjectOutputStream<br>字符流:针对文本文件<br>Reader<br>FileReader<br>BufferedReader<br>InputStreamReader<br>Writer<br>FileWriter<br>BufferedWriter<br>OutputStreamWriter<br>PrintWriter一行行写出</p>
</blockquote>
<h3 id="File文件类"><a href="#File文件类" class="headerlink" title="File文件类"></a>File文件类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>封装一个磁盘路径字符串,对这个路径可以执行一次操作<br>可以封装文件路径、文件夹路径、不存在的路径</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>File(String pathname)通过将给定路径名字符串转换为抽象路径名来创建一个新的File实例<br>new File(“d:&#x2F;abc&#x2F;a.txt”);<br>new File(“d:&#x2F;abc”,”a.txt”);</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210616175436943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="练习：测试常用方法"><a href="#练习：测试常用方法" class="headerlink" title="练习：测试常用方法"></a>练习：测试常用方法</h4><p>创建包: cn.tedu.file</p>
<p>创建类: TestFile.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试文件类File*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建File类对象</span></span><br><span class="line">        <span class="comment">/*1.ready目录与1.txt需要自己手动创建</span></span><br><span class="line"><span class="comment">        * 2.File需要导包：import java.io.File;</span></span><br><span class="line"><span class="comment">        * 3.路径是String类型，必须写正确，不然找不到文件</span></span><br><span class="line"><span class="comment">        * 4.完整的文件名包含两部分：文件名+后缀名*/</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1测试File中的常用方法</span></span><br><span class="line">        System.out.println(file.length());<span class="comment">//3，获取文件的字节量</span></span><br><span class="line">        System.out.println(file.exists());<span class="comment">//true,判断文件是否存在</span></span><br><span class="line">        System.out.println(file.isFile());<span class="comment">//true,判断是否为文件</span></span><br><span class="line">        System.out.println(file.isDirectory());<span class="comment">//false，判断是否为文件夹</span></span><br><span class="line">        System.out.println(file.getName());<span class="comment">//1.txt获取文件名</span></span><br><span class="line">        System.out.println(file.getParent());<span class="comment">//E:\ready 获取父级路径</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());<span class="comment">//E:\ready\1.txt 获取带盘符的完整路径：绝对路径</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.2 测试创建与删除</span></span><br><span class="line">        <span class="comment">/*new 只会帮你在内存中创建一个File类型的对象</span></span><br><span class="line"><span class="comment">        * 并不会帮你在磁盘中创建一个真实存在的2.txt文件*/</span></span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建一个之前不存在的文件2.txt,如果创建成功，会返回true</span></span><br><span class="line">        <span class="comment">/*如果指定创建文件的路径不对，会抛出异常：java.io.Exception</span></span><br><span class="line"><span class="comment">        * 所以需要提前处理这个问题，我们暂时选择在main()上抛出</span></span><br><span class="line"><span class="comment">        * 这个IO异常是目前我们遇到的强制要求必须预先处理的异常</span></span><br><span class="line"><span class="comment">        * 如果不处理，方法的调用会报错，通不过编译*/</span></span><br><span class="line">        System.out.println(file.createNewFile());<span class="comment">//创建之前不存在的文件</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\m&quot;</span>);</span><br><span class="line">        System.out.println(file.mkdir());<span class="comment">//创建之前不存在的单层文件夹</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\a\\b\\c&quot;</span>);</span><br><span class="line">        System.out.println(file.mkdirs());<span class="comment">//创建之前不存在的多层文件夹</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(file.delete());<span class="comment">//c被删除，删除空文件夹或者文件</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\a&quot;</span>);</span><br><span class="line">        System.out.println(file.delete());<span class="comment">//false,a文件夹不是空的，里面有内容</span></span><br><span class="line">    </span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>);</span><br><span class="line">        System.out.println(file.delete());<span class="comment">//2.txt被删除，可以删除文件</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.3测试展示文件列表</span></span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\ready&quot;</span>);</span><br><span class="line">        String[] list = file.list();<span class="comment">/*不常用*/</span></span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">        <span class="comment">//这句话会报错，因为这是一个String[],所以数组中每个元素都是String类型的</span></span><br><span class="line">        <span class="comment">//那么只能用String类中的方法，而isDirectory()是File类中的方法</span></span><br><span class="line">        <span class="comment">//System.out.println(list[0].isDirectory());</span></span><br><span class="line">    </span><br><span class="line">        File[] fs = file.listFiles();<span class="comment">/*常用*/</span></span><br><span class="line">        System.out.println(Arrays.toString(fs));</span><br><span class="line">        System.out.println(fs[<span class="number">0</span>].isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流读取"><a href="#字节流读取" class="headerlink" title="字节流读取"></a>字节流读取</h3><p>字节流是由字节组成的,字符流是由字符组成的.<br>Java里字符由两个字节组成.字节流是基本流，主要用在处理二进制数据。<br>所以字节流是比较常用的，可以可以处理多种不同种类的文件，比如文本文档&#x2F;音频&#x2F;视频等等</p>
<h4 id="InputStream抽象类"><a href="#InputStream抽象类" class="headerlink" title="InputStream抽象类"></a>InputStream抽象类</h4><p>此抽象类是表示字节输入流的所有类的超类&#x2F;抽象类,不可创建对象哦</p>
<blockquote>
<p>常用方法：<br>abstract int read() 从输入流中读取数据的下一个字节<br>int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中<br>int read(byte[] b, int off, int len) 将输入流中最多 len 个数据字节读入 byte 数组,off表示存时的偏移量<br>void close() 关闭此输入流并释放与该流关联的所有系统资源</p>
</blockquote>
<h4 id="FileInputStream子类"><a href="#FileInputStream子类" class="headerlink" title="FileInputStream子类"></a>FileInputStream子类</h4><p>直接插在文件上，直接读取文件数据</p>
<blockquote>
<p>创建对象<br>FileInputStream(File file)—直接传文件对象<br>通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定FileInputStream(String pathname)—传路径<br>通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定</p>
</blockquote>
<h4 id="BufferedInputStream子类"><a href="#BufferedInputStream子类" class="headerlink" title="BufferedInputStream子类"></a>BufferedInputStream子类</h4><p>BufferedInputStream 为另一个输入流添加一些功能，在创建BufferedInputStream 时，会创建一个内部缓冲区数组(默认8k大小)。在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。</p>
<blockquote>
<p>创建对象<br>BufferedInputStream(InputStream in)<br>创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</p>
</blockquote>
<h4 id="字节流读取案例"><a href="#字节流读取案例" class="headerlink" title="字节流读取案例"></a>字节流读取案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">练习：字节流读取案例</span><br><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestIn.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于练习字节输入流*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//method();//字节流的读取</span></span><br><span class="line">        method2();<span class="comment">//高效字节流的读取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本方法用于测试高效字节流的读取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个在本方法中都生效的局部变量in,注意手动初始化，值为null</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建高效字节输入流对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            InputStream in = new BufferedInputStream(</span></span><br><span class="line"><span class="comment">//                    new FileInputStream(new File(&quot;E:\\ready\\1.txt&quot;)));</span></span><br><span class="line">              in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span></span><br><span class="line">                      (<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.使用流进行读取</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b= in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流操作写在finally&#123;&#125;中</span></span><br><span class="line">            <span class="comment">//3.流用完以后一定要关闭！！！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本方法用于测试字节流的读取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个在本方法都生效的局部变量注意手动初始化</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建字节输入流对象用于读取</span></span><br><span class="line">        <span class="comment">//InputStream in = new InputStream();//报错原因：抽象类不可实例化</span></span><br><span class="line">        <span class="comment">//InputStream in = new FileInputStream(new File(&quot;E:\\ready\\1.txt&quot;));</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.开始读取</span></span><br><span class="line">        <span class="comment">/*read()每次调用都会读取一个字节，如果读到了数据的末尾，返回-1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line"><span class="comment">//            System.out.println(in.read());</span></span><br><span class="line">            <span class="comment">//需求：需要循环读取文件中的所有内容，直至读完</span></span><br><span class="line">            <span class="comment">//定义变量，记录读到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span>((b=in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();<span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="comment">/*try-catch结构中的第三个部分：finally&#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这部分不论是否捕获到异常，是一定会被执行到的代码，常用于关流*/</span></span><br><span class="line">ally &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//3.释放资源，流资源用完必须释放！！！</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流读取"><a href="#字符流读取" class="headerlink" title="字符流读取"></a>字符流读取</h3><p>常用于处理纯文本数据,读写容易出现乱码的现象,在读写时,最好指定编码集为UTF-8</p>
<h4 id="Reader抽象类"><a href="#Reader抽象类" class="headerlink" title="Reader抽象类"></a>Reader抽象类</h4><p>用于读取字符流的抽象类。</p>
<blockquote>
<p>常用方法：<br>int read() 读取单个字符<br>int read(char[] cbuf) 将字符读入数组<br>abstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分<br>int read(CharBuffer target) 试图将字符读入指定的字符缓冲区<br>abstract void close() 关闭该流并释放与之关联的所有资源</p>
</blockquote>
<h4 id="FileReader子类"><a href="#FileReader子类" class="headerlink" title="FileReader子类"></a>FileReader子类</h4><p>用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。</p>
<blockquote>
<p>创建对象<br>FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader<br>FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader</p>
</blockquote>
<h4 id="BufferedReader子类"><a href="#BufferedReader子类" class="headerlink" title="BufferedReader子类"></a>BufferedReader子类</h4><p>从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。<br>可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。</p>
<blockquote>
<p>创建对象<br>BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流</p>
</blockquote>
<h4 id="练习：字符流读取案例"><a href="#练习：字符流读取案例" class="headerlink" title="练习：字符流读取案例"></a>练习：字符流读取案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestIn2.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试字符流的读取*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIn2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//method();//测试普通字符输入流</span></span><br><span class="line">        method2();<span class="comment">//测试高效字符输入流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试高效字符输入流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个在本方法都生效的局部变量，手动初始化值null</span></span><br><span class="line">        Reader in=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.创建高效字符读取流对象</span></span><br><span class="line">            <span class="comment">//in = new BufferedReader(new FileReader(new File(&quot;E:\\ready\\1.txt&quot;)));</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.使用流对象</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.关闭流对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试普通字符输入流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.1创建一个在本方法中都生效的局部变量，注意初始化值null</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.2创建字符输入流对象，注意需要捕获异常</span></span><br><span class="line">            <span class="comment">//Reader in = new Reader();//报错原因：抽象父级不可实例化</span></span><br><span class="line">            <span class="comment">//in = new FileReader(new File(&quot;E:\\ready\\1.txt&quot;));</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\ready\\1.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.使用流对象</span></span><br><span class="line">            <span class="comment">//System.out.println(in.read());</span></span><br><span class="line">            <span class="comment">//需求：循环读取文件中的所有内容，只要不是-1，就说明还有数据，继续读取</span></span><br><span class="line">            <span class="comment">//3.1定义变量，记录读取到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span>((b = in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//3.关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流写出"><a href="#字节流写出" class="headerlink" title="字节流写出"></a>字节流写出</h3><h4 id="OutputStream抽象类"><a href="#OutputStream抽象类" class="headerlink" title="OutputStream抽象类"></a>OutputStream抽象类</h4><p>此抽象类是表示输出字节流的所有类的超类.输出流接受输出字节并将这些字节发送到某个接收器.</p>
<blockquote>
<p>常用方法:<br>Void close() 关闭此输出流并释放与此流相关的所有系统资源<br>Void flush() 刷新此输出流并强制写出所有缓冲的输出字节<br>Void write(byte[ ] b) 将b.length个字节从指定的byte数组写入此输出流<br>Void write(byte[ ] b,int off ,int len) 将指定byte数组中从偏移量off开始的len个字节写入输出流<br>Abstract void write(int b) 将指定的字节写入此输出流</p>
</blockquote>
<h4 id="FileOutputStream-子类"><a href="#FileOutputStream-子类" class="headerlink" title="FileOutputStream 子类"></a>FileOutputStream 子类</h4><p>直接插在文件上,直接写出文件数据</p>
<blockquote>
<p>构造方法(创建对象):<br>FileOutputStream(String name)<br>创建一个向具有指定名称的文件中写入数据的文件输出流<br>FileOutStream(File file)<br>创建一个向指定File对象表示的文件中写入数据的文件输出流<br>FileOutStream(File file,boolean append)—如果第二个参数为true,表示追加,不覆盖<br>创建一个向指定File对象表示的文件中写入数据的文件输出流,后面的参数是指是否覆盖原文件内容</p>
</blockquote>
<h4 id="BufferedOutputstream-子类"><a href="#BufferedOutputstream-子类" class="headerlink" title="BufferedOutputstream 子类"></a>BufferedOutputstream 子类</h4><p>该类实现缓冲的输出流,通过设置这种输出流,应用程序就可以将各个字节写入底层输出流中,而不必每次针对字节写出调用底层系统</p>
<blockquote>
<p>构造方法(创建对象):<br>BufferedOutputStream(OutputStream out)<br>创建一个新的缓冲输出流,用以将数据写入指定的底层输出流</p>
</blockquote>
<h4 id="练习-字节输出流测试"><a href="#练习-字节输出流测试" class="headerlink" title="练习: 字节输出流测试:"></a>练习: 字节输出流测试:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestOut.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试字节输出流*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method();<span class="comment">//用于测试普通字节输出流</span></span><br><span class="line">        <span class="comment">//method2();//用于测试高效字节输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试高效字节输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法都生效的局部变量，注意手动初始化</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//2.创建高效字节输出流对象</span></span><br><span class="line"><span class="comment">//          out = new BufferedOutputStream(new FileOutputStream(new File(&quot;E:\\ready\\2.txt&quot;)));</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//3.使用流对象--进行写出操作</span></span><br><span class="line">            out.write(<span class="number">97</span>);</span><br><span class="line">            out.write(<span class="number">97</span>);</span><br><span class="line">            out.write(<span class="number">97</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流操作要放在finally&#123;&#125;中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.关流</span></span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试普通字节输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法中都生效的局部变量，注意手动初始化null</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.创建try-catch-finally结构，因为IO操作可能会产生异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.创建普通字节输出流对象</span></span><br><span class="line">            <span class="comment">//out = new FileOutputStream(new File(&quot;E:\\ready\\2.txt&quot;));</span></span><br><span class="line">            <span class="comment">//out = new FileOutputStream(&quot;E:\\ready\\2.txt&quot;);</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.使用流对象--进行写出操作</span></span><br><span class="line">            out.write(<span class="number">99</span>);<span class="comment">//对应ASCII码表中的a</span></span><br><span class="line">            out.write(<span class="number">99</span>);<span class="comment">//对应ASCII码表中的b</span></span><br><span class="line">            out.write(<span class="number">99</span>);<span class="comment">//对应ASCII码表中的c</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//如果想要代码一定会执行，需要写在finally中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//5.关流操作</span></span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流写出"><a href="#字符流写出" class="headerlink" title="字符流写出"></a>字符流写出</h3><h4 id="Writer-抽象类"><a href="#Writer-抽象类" class="headerlink" title="Writer 抽象类"></a>Writer 抽象类</h4><p>写入字符流的抽象类</p>
<blockquote>
<p>常用方法:<br>Abstract void close() 关闭此流,但要先刷新它<br>Void write(char[ ] cbuf) 写入字符数组<br>Void write(int c) 写入单个字符<br>Void write(String str) 写入字符串<br>Void write(String str,int off,int len) 写入字符串的某一部分<br>Abstract void write(char[] cbuf,int off,int len)写入字符数组的某一部分</p>
</blockquote>
<h4 id="FileWriter-子类"><a href="#FileWriter-子类" class="headerlink" title="FileWriter 子类"></a>FileWriter 子类</h4><p>用来写入字符文件的便捷类,此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的.如果需要自己自定义这些值,可以先在FileOutputStream上构造一个OutputStreamWriter.</p>
<blockquote>
<p>构造方法(创建对象):<br>FileWriter(String filename)<br>根据给定的文件名构造一个FileWriter对象<br>FileWriter(String filename,boolean append)<br>根据给定的文件名以及指示是否附加写入数据的boolean值来构造FileWriter</p>
</blockquote>
<h4 id="BufferedWriter子类"><a href="#BufferedWriter子类" class="headerlink" title="BufferedWriter子类"></a>BufferedWriter子类</h4><p>将文本写入字符输出流,缓冲各个字符,从而提供单个字符,数组和字符串的高效写入.可以指定缓冲区的大小,或者接受默认的大小,在大多数情况下,默认值就足够大了</p>
<blockquote>
<p>构造方法(创建对象):<br>BufferedWriter(Writer out)<br>创建一个使用默认大小输出缓冲区的缓冲字符输出流</p>
</blockquote>
<h4 id="练习-字符输出流测试"><a href="#练习-字符输出流测试" class="headerlink" title="练习: 字符输出流测试:"></a>练习: 字符输出流测试:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建包: cn.tedu.file</span><br><span class="line">创建类: TestOut2.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于测试字符输出流*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOut2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//method();//用于测试普通字符输出流</span></span><br><span class="line">        method2();<span class="comment">//用于测试高效字符输出流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试高效字符输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法都生效的局部变量，值为null,注意手动初始化！！！</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于程序可能会抛出异常，所以需要写一个try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//存放可能会抛出异常的代码</span></span><br><span class="line">            <span class="comment">//3.创建普通字符输出流对象</span></span><br><span class="line">            <span class="comment">//out = new BufferedWriter(new FileWriter(new File(&quot;E:\\ready\\2.txt&quot;)));</span></span><br><span class="line">            <span class="comment">//out = new BufferedWriter(new FileWriter(&quot;E:\\ready\\2.txt&quot;));</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">            <span class="comment">//4.使用流对象</span></span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">            out.write(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;<span class="comment">//匹配并捕获异常</span></span><br><span class="line">            e.printStackTrace();<span class="comment">//如果捕获到异常就打印错误信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//一定会被执行到的代码块，常用于关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个用于测试普通字符输出流的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个在本方法都生效的局部变量，值为null,注意手动初始化！！！</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于程序可能会抛出异常，所以需要写一个try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//存放可能会抛出异常的代码</span></span><br><span class="line">            <span class="comment">//3.创建普通字符输出流对象</span></span><br><span class="line">            <span class="comment">//out = new FileWriter(new File(&quot;E:\\ready\\2.txt&quot;));</span></span><br><span class="line">            <span class="comment">//out = new FileWriter(&quot;E:\\ready\\2.txt&quot;);</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;E:\\ready\\2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.使用流对象</span></span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">            out.write(<span class="number">98</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;<span class="comment">//匹配并捕获异常</span></span><br><span class="line">            e.printStackTrace();<span class="comment">//如果捕获到异常就打印错误信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//一定会被执行到的代码块，常用于关流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>通过学习以上的几种流,我们也可以拓展尝试做下文件的复制:<br>创建包: cn.tedu.file<br>创建类: TestCopyFile.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本类用于练习文件复制综合案例*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCopyFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.提示并接收用户输入的两个路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入源文件路径&quot;</span>);<span class="comment">//--被复制的那个文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入新文件路径：&quot;</span>);<span class="comment">//--复制好的新文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用创建好的自定义方法完成文件复制</span></span><br><span class="line">        <span class="comment">//ZFCopy(f,t);//用字符流完成文件的复制案例</span></span><br><span class="line">        ZJCopy(f,t);<span class="comment">//用字节流完成文件的复制案例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用字节流完成文件复制案例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZJCopy</span><span class="params">(String f, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义在整个方法都生效的局部变量，注意手动初始化，引用类型默认值为null</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于代码可能会发生异常，所以需要编写try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.1创建高效字节输入流对象--FIS的参数是用户传入的源文件路径f</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f));</span><br><span class="line">            <span class="comment">//3.2创建高效字节输出流对象--FOS的参数是用户传入的新文件路径t</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(t));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.利用创建好的流对象完成业务</span></span><br><span class="line">            <span class="comment">//4.1定义变量用来保存读到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="comment">//4.2循环读取源文件中的数据，只要不是-1，说明还有数据循环继续</span></span><br><span class="line">            <span class="keyword">while</span>((b = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//4.3将读到的数据写入到新文件中</span></span><br><span class="line">                out.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜您！文件复制成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很抱歉！文件复制失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用字符流完成文件复制案例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZFCopy</span><span class="params">(String f, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义在整个方法中都生效的局部变量，注意手动初始化，默认值为null</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.由于代码可能会发生异常，所以需要编写try-catch-finally结构</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//3.1创建高效字符输入流对象</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(f));</span><br><span class="line">            <span class="comment">//3.2创建高效字符输出流对象</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(t));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.拿到流对象以后，就可以使用流对象来完成业务了</span></span><br><span class="line">            <span class="comment">//4.1定义变量用来保存读到的数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="comment">//4.2循环读取源文件，直到返回值为-1，说明没有数据了，再结束循环</span></span><br><span class="line">            <span class="keyword">while</span> ((b=in.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//4.3将本轮循环中读到的数据写入到新文件中</span></span><br><span class="line">                out.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜您！文件复制成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很抱歉！文件复制失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*关流是有顺序的：如果有多个流，最后创建的流最先关闭</span></span><br><span class="line"><span class="comment">            * 多条关流语句需要各自try-catch*/</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-IO的继承结构"><a href="#总结-IO的继承结构" class="headerlink" title="总结:IO的继承结构"></a>总结:IO的继承结构</h3><p>主流分类</p>
<ol>
<li>按照方向进行分类:输入流 输出流(相对于程序而言,从程序写数据到文件中是输出)</li>
<li>按照传输类型进行分类:字节流 字符流</li>
<li>组合: 字节输入流 字节输出流 字符输入流 字符输出流</li>
</ol>
<p>学习方法:在抽象父类中学习通用的方法,在子类中学习如何创建对象</p>
<h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流:"></a>字节输入流:</h4><p><code>InputStream 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileInputStream 子类,操作文件的字节输入流,普通类</span><br><span class="line">--BufferedInputStream 子类,缓冲字节输入流,普通类</span><br></pre></td></tr></table></figure>

<h4 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h4><p><code>Reader 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileReader,子类,操作文件的字符输入流,普通类</span><br><span class="line">--BufferedReader,子类,缓冲字符输入流,普通类</span><br></pre></td></tr></table></figure>

<h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流:"></a>字节输出流:</h4><p><code>OutputStream 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileOutputStream 子类,操作文件的字节输出流,普通类</span><br><span class="line">--BufferedOutputStream 子类,缓冲字节输出流,普通类</span><br></pre></td></tr></table></figure>

<h4 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h4><p><code>Writer 抽象类,不能new,可以作为超类,学习其所提供的共性方法</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--FileWriter,子类,操作文件的字符输出流,普通类</span><br><span class="line">--BufferedWriter,子类,缓冲字符输出流,普通类</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><h3 id="反射机制有什么用？"><a href="#反射机制有什么用？" class="headerlink" title="反射机制有什么用？"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%B0%84&spm=1001.2101.3001.7020">反射</a>机制有什么用？</h3><p>通过java语言中的反射机制可以操作字节码文件（可以读和修改<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>文件。）<br>通过反射机制可以操作代码片段。（class文件。）</p>
<h3 id="反射机制的相关类在哪个包下？"><a href="#反射机制的相关类在哪个包下？" class="headerlink" title="反射机制的相关类在哪个包下？"></a>反射机制的相关类在哪个包下？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.*;</span><br></pre></td></tr></table></figure>

<h3 id="反射机制相关的重要的类有哪些？"><a href="#反射机制相关的重要的类有哪些？" class="headerlink" title="反射机制相关的重要的类有哪些？"></a>反射机制相关的重要的类有哪些？</h3><table>
<thead>
<tr>
<th align="left">类</th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">java.lang.Class</td>
<td>代表整个字节码。代表一个类型，代表整个类。</td>
</tr>
<tr>
<td align="left">java.lang.reflect.Method</td>
<td>代表字节码中的方法字节码。代表类中的方法。</td>
</tr>
<tr>
<td align="left">java.lang.reflect.Constructor</td>
<td>代表字节码中的构造方法字节码。代表类中的构造方法。</td>
</tr>
<tr>
<td align="left">ava.lang.reflect.Field</td>
<td>代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td>
</tr>
</tbody></table>
<p><strong>注</strong>：<strong>必须先获得Class才能获取Method、Constructor、Field</strong>。</p>
<p><strong>eg.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Class:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	<span class="comment">// Field</span></span><br><span class="line">	<span class="type">int</span> no;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Constructor</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Method</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Class的三方式"><a href="#获取Class的三方式" class="headerlink" title="获取Class的三方式"></a>获取Class的三方式</h3><p>要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？</p>
<table>
<thead>
<tr>
<th align="center"><strong>方式</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class.forName(“完整类名带包名”)</td>
<td>静态方法</td>
</tr>
<tr>
<td align="center">对象.getClass()</td>
<td></td>
</tr>
<tr>
<td align="center">任何类型.class</td>
<td></td>
</tr>
</tbody></table>
<p>注：以上三种方式返回值都是<strong>Class类型</strong>。</p>
<h3 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象.newInstance()</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：newInstance()方法内部实际上调用了<strong>无参数构造方法</strong>，必须保证无参构造存在才可以。<br>否则会抛出<code>java.lang.InstantiationException</code>异常。</p>
<p><strong>eg.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 下面这段代码是以反射机制的方式创建对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射机制，获取Class，通过Class来实例化对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.User&quot;</span>);</span><br><span class="line">        <span class="comment">// newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。</span></span><br><span class="line">        <span class="comment">// 重点是：newInstance()调用的是无参构造，必须保证无参构造是存在的！</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC重点-Class-forName导致类加载"><a href="#JDBC重点-Class-forName导致类加载" class="headerlink" title="JDBC重点(Class.forName导致类加载)"></a>JDBC重点(Class.forName导致类加载)</h3><p>如果你只是希望一个类的<strong>静态代码块</strong>执行，其它代码一律不执行，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;完整类名&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法的执行会导致<strong>类加载</strong>，类加载时，静态代码块执行。</p>
<h3 id="反射Filed【反射-x2F-反编译一个类的属性】"><a href="#反射Filed【反射-x2F-反编译一个类的属性】" class="headerlink" title="反射Filed【反射&#x2F;反编译一个类的属性】"></a>反射Filed【反射&#x2F;反编译一个类的属性】</h3><h4 id="Class类方法"><a href="#Class类方法" class="headerlink" title="Class类方法"></a>Class类方法</h4><table>
<thead>
<tr>
<th align="center"><strong>方法名</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">public T <strong>newInstance</strong>()</td>
<td align="center">创建对象</td>
</tr>
<tr>
<td align="center">public String <strong>getName</strong>()</td>
<td align="center">返回完整类名带包名</td>
</tr>
<tr>
<td align="center">public String <strong>getSimpleName</strong>()</td>
<td align="center">返回类名</td>
</tr>
<tr>
<td align="center">public Field[] <strong>getFields</strong>()</td>
<td align="center">返回类中public修饰的属性</td>
</tr>
<tr>
<td align="center">public Field[] <strong>getDeclaredFields</strong>()</td>
<td align="center">返回类中所有的属性</td>
</tr>
<tr>
<td align="center">public Field <strong>getDeclaredField</strong>(String name)</td>
<td align="center">根据属性名name获取指定的属性</td>
</tr>
<tr>
<td align="center">public native int <strong>getModifiers</strong>()</td>
<td align="center">获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td align="center">public Method[] <strong>getDeclaredMethods</strong>()</td>
<td align="center">返回类中所有的实例方法</td>
</tr>
<tr>
<td align="center">public Method <strong>getDeclaredMethod</strong>(String name, Class&lt;?&gt;… parameterTypes)</td>
<td align="center">根据方法名name和方法形参获取指定方法</td>
</tr>
<tr>
<td align="center">public Constructor&lt;?&gt;[] <strong>getDeclaredConstructors</strong>()</td>
<td align="center">返回类中所有的构造方法</td>
</tr>
<tr>
<td align="center">public Constructor <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;… parameterTypes)</td>
<td align="center">根据方法形参获取指定的构造方法</td>
</tr>
<tr>
<td align="center">-—</td>
<td align="center">-—</td>
</tr>
<tr>
<td align="center">public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</td>
<td align="center">回调用类的父类</td>
</tr>
<tr>
<td align="center">public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</td>
<td align="center">返回调用类实现的接口集合</td>
</tr>
</tbody></table>
<h4 id="Field类方法"><a href="#Field类方法" class="headerlink" title="Field类方法"></a>Field类方法</h4><table>
<thead>
<tr>
<th align="center"><strong>方法名</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String <strong>getName</strong>()</td>
<td align="center">返回属性名</td>
</tr>
<tr>
<td align="center">public int <strong>getModifiers</strong>()</td>
<td align="center">获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td align="center">public Class&lt;?&gt; <strong>getType</strong>()</td>
<td align="center">以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td align="center">public void <strong>set</strong>(Object obj, Object value)</td>
<td align="center">设置属性值</td>
</tr>
<tr>
<td align="center">public Object <strong>get</strong>(Object obj)</td>
<td align="center">读取属性值</td>
</tr>
</tbody></table>
<h4 id="eg-反编译一个类的属性Field"><a href="#eg-反编译一个类的属性Field" class="headerlink" title="eg.反编译一个类的属性Field"></a>eg.反编译一个类的属性Field</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射机制，反编译一个类的属性Field（了解一下）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Student&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers()) + <span class="string">&quot; class &quot;</span> + studentClass.getSimpleName() + <span class="string">&quot; &#123;\n&quot;</span>);<span class="comment">// Class类的getName方法</span></span><br><span class="line">        <span class="comment">//获取所有的属性</span></span><br><span class="line">        Field[] fields = studentClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号</span></span><br><span class="line">            <span class="comment">// 用Modifier类的toString转换成字符串</span></span><br><span class="line">            s.append(Modifier.toString(f.getModifiers()));</span><br><span class="line">            <span class="keyword">if</span> (f.getModifiers() != <span class="number">0</span>) s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getType().getSimpleName());<span class="comment">// 获取属性的类型</span></span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(f.getName());<span class="comment">// 获取属性的名字</span></span><br><span class="line">            s.append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给属性赋值三要素"><a href="#给属性赋值三要素" class="headerlink" title="给属性赋值三要素"></a>给属性赋值三要素</h3><p><strong>eg.</strong> 给s对象的no属性赋值1111</p>
<ul>
<li>要素1：<strong>对象</strong> s</li>
<li>要素2：no <strong>属性</strong></li>
<li>要素3：1111 <strong>值</strong></li>
</ul>
<h3 id="读属性值两个要素"><a href="#读属性值两个要素" class="headerlink" title="读属性值两个要素"></a>读属性值两个要素</h3><p><strong>eg.</strong> 获取s对象的no属性的值</p>
<ul>
<li>要素1：<strong>对象</strong> s</li>
<li>要素2：no<strong>属性</strong></li>
</ul>
<hr>
<p><strong>注：</strong> Field类中set()、get()使用注意事项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">属性.set(对象, 值);</span><br><span class="line"></span><br><span class="line">属性.get(对象);</span><br></pre></td></tr></table></figure>

<h4 id="eg-★通过反射机制访问一个java对象的属性"><a href="#eg-★通过反射机制访问一个java对象的属性" class="headerlink" title="eg.★通过反射机制访问一个java对象的属性"></a>eg.★通过反射机制访问一个java对象的属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">必须掌握：</span></span><br><span class="line"><span class="comment">    怎么通过反射机制访问一个java对象的属性？</span></span><br><span class="line"><span class="comment">        给属性赋值set</span></span><br><span class="line"><span class="comment">        获取属性的值get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest07</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//不使用反射机制给属性赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">/**给属性赋值三要素：给s对象的no属性赋值1111</span></span><br><span class="line"><span class="comment">         * 要素1：对象s</span></span><br><span class="line"><span class="comment">         * 要素2：no属性</span></span><br><span class="line"><span class="comment">         * 要素3：1111</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        student.no = <span class="number">1111</span>;</span><br><span class="line">        <span class="comment">/**读属性值两个要素：获取s对象的no属性的值。</span></span><br><span class="line"><span class="comment">         * 要素1：对象s</span></span><br><span class="line"><span class="comment">         * 要素2：no属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(student.no);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制给属性赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Student&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance();<span class="comment">// obj就是Student对象。（底层调用无参数构造方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取no属性（根据属性的名称来获取Field）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">// 给obj对象(Student对象)的no属性赋值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            虽然使用了反射机制，但是三要素还是缺一不可：</span></span><br><span class="line"><span class="comment">                要素1：obj对象</span></span><br><span class="line"><span class="comment">                要素2：no属性</span></span><br><span class="line"><span class="comment">                要素3：22222值</span></span><br><span class="line"><span class="comment">            注意：反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        noField.set(obj, <span class="number">22222</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        <span class="comment">// 两个要素：获取obj对象的no属性的值。</span></span><br><span class="line">        System.out.println(noField.get(obj));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-可以访问私有属性嘛？"><a href="#set-可以访问私有属性嘛？" class="headerlink" title="set()可以访问私有属性嘛？"></a>set()可以访问私有属性嘛？</h3><p>不可以，需要打破封装，才可以。</p>
<h4 id="Fidle方法："><a href="#Fidle方法：" class="headerlink" title="Fidle方法："></a><strong>Fidle方法：</strong></h4><table>
<thead>
<tr>
<th align="center"><strong>方法</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void <strong>setAccessible</strong>(boolean flag)</td>
<td align="center">默认false，设置为true为打破封装</td>
</tr>
</tbody></table>
<p><strong>eg.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以访问私有的属性吗？</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）</span></span><br><span class="line"><span class="comment">// 这样设置完之后，在外部也是可以访问private的。</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 给name属性赋值</span></span><br><span class="line">nameField.set(obj, <span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line"><span class="comment">// 获取name属性的值</span></span><br><span class="line">System.out.println(nameField.get(obj));</span><br></pre></td></tr></table></figure>

<h3 id="反射Method【反射-x2F-反编译一个类的方法】"><a href="#反射Method【反射-x2F-反编译一个类的方法】" class="headerlink" title="反射Method【反射&#x2F;反编译一个类的方法】"></a>反射Method【反射&#x2F;反编译一个类的方法】</h3><h4 id="Method类方法"><a href="#Method类方法" class="headerlink" title="Method类方法"></a>Method类方法</h4><table>
<thead>
<tr>
<th align="center"><strong>方法名</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String <strong>getName</strong>()</td>
<td align="center">返回方法名</td>
</tr>
<tr>
<td align="center">public int <strong>getModifiers</strong>()</td>
<td align="center">获取方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td align="center">public Class&lt;?&gt; <strong>getReturnType</strong>()</td>
<td align="center">以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td align="center">public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td align="center">返回方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td align="center">public Object <strong>invoke</strong>(Object obj, Object… args)</td>
<td align="center">调用方法</td>
</tr>
</tbody></table>
<h4 id="eg-反编译一个类的方法Method"><a href="#eg-反编译一个类的方法Method" class="headerlink" title="eg.反编译一个类的方法Method"></a>eg.反编译一个类的方法Method</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">了解一下，不需要掌握（反编译一个类的方法。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest09</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s.append(Modifier.toString(userServiceClass.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(userServiceClass.getSimpleName());</span><br><span class="line">        s.append(<span class="string">&quot; &#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的Method（包括私有的！）</span></span><br><span class="line">        Method[] methods = userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取修饰符列表</span></span><br><span class="line">            s.append(Modifier.toString(m.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 获取方法的返回值类型</span></span><br><span class="line">            s.append(m.getReturnType().getSimpleName());</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 获取方法名</span></span><br><span class="line">            s.append(m.getName());</span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">// 方法的修饰符列表（一个方法的参数可能会有多个。）</span></span><br><span class="line">            Class[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                s.append(parameterTypes[i].getSimpleName());</span><br><span class="line">                <span class="keyword">if</span> (i != parameterTypes.length - <span class="number">1</span>) s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;) &#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用方法四要素"><a href="#调用方法四要素" class="headerlink" title="调用方法四要素"></a>调用方法四要素</h4><p><strong>eg.</strong> 调用对象userService的login方法</p>
<ul>
<li>要素1：<strong>对象</strong> userService</li>
<li>要素2：login <strong>方法名</strong></li>
<li>要素3：<strong>实参列表</strong></li>
<li>要素4：<strong>返回值</strong></li>
</ul>
<hr>
<p><strong>注：</strong> Method类中invoke()使用注意事项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法.invoke(对象, 实参);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="eg-★通过反射机制调用一个对象的方法"><a href="#eg-★通过反射机制调用一个对象的方法" class="headerlink" title="eg.★通过反射机制调用一个对象的方法"></a>eg.★通过反射机制调用一个对象的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重点：必须掌握，通过反射机制怎么调用一个对象的方法？</span></span><br><span class="line"><span class="comment">    五颗星*****</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射机制，让代码很具有通用性，可变化的内容都是写到配置文件当中，</span></span><br><span class="line"><span class="comment">    将来修改配置文件之后，创建的对象不一样了，调用的方法也不同了，</span></span><br><span class="line"><span class="comment">    但是java代码不需要做任何改动。这就是反射机制的魅力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest10</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 不使用反射机制，怎么调用方法</span></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            要素分析：</span></span><br><span class="line"><span class="comment">                要素1：对象userService</span></span><br><span class="line"><span class="comment">                要素2：login方法名</span></span><br><span class="line"><span class="comment">                要素3：实参列表</span></span><br><span class="line"><span class="comment">                要素4：返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>) ? <span class="string">&quot;登入成功！&quot;</span> : <span class="string">&quot;登入失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制调用方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">        <span class="comment">// 获取Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod(<span class="string">&quot;login&quot;</span>, String.class, String.class);</span><br><span class="line"><span class="comment">//        Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;);//注：没有形参就不传</span></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">// 调用方法有几个要素？ 也需要4要素。</span></span><br><span class="line">        <span class="comment">// 反射机制中最最最最最重要的一个方法，必须记住。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            四要素：</span></span><br><span class="line"><span class="comment">            loginMethod方法</span></span><br><span class="line"><span class="comment">            obj对象</span></span><br><span class="line"><span class="comment">            &quot;admin&quot;,&quot;123&quot; 实参</span></span><br><span class="line"><span class="comment">            retValue 返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resValues</span> <span class="operator">=</span> loginMethod.invoke(obj, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span>);<span class="comment">//注：方法返回值是void 结果是null</span></span><br><span class="line">        System.out.println(resValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射Constructor【反射-x2F-反编译一个类的构造方法】"><a href="#反射Constructor【反射-x2F-反编译一个类的构造方法】" class="headerlink" title="反射Constructor【反射&#x2F;反编译一个类的构造方法】"></a>反射Constructor【反射&#x2F;反编译一个类的构造方法】</h3><h3 id="Constructor类方法"><a href="#Constructor类方法" class="headerlink" title="Constructor类方法"></a>Constructor类方法</h3><table>
<thead>
<tr>
<th align="center"><strong>方法名</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String <strong>getName</strong>()</td>
<td align="center">返回构造方法名</td>
</tr>
<tr>
<td align="center">public int <strong>getModifiers</strong>()</td>
<td align="center">获取构造方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td align="center">public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td align="center">返回构造方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td align="center">public T <strong>newInstance</strong>(Object … initargs)</td>
<td align="center">创建对象【参数为创建对象的数据】</td>
</tr>
</tbody></table>
<h4 id="eg-反编译一个类的构造方法Constructor"><a href="#eg-反编译一个类的构造方法Constructor" class="headerlink" title="eg.反编译一个类的构造方法Constructor"></a>eg.反编译一个类的构造方法Constructor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反编译一个类的Constructor构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest11</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public class UserService &#123;</span></span><br><span class="line">        s.append(Modifier.toString(vipClass.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(vipClass.getSimpleName());</span><br><span class="line">        s.append(<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = vipClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors)&#123;</span><br><span class="line">            <span class="comment">//public Vip(int no, String name, String birth, boolean sex) &#123;</span></span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString(c.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//            s.append(c.getName());//包名+类名</span></span><br><span class="line">            s.append(vipClass.getSimpleName());<span class="comment">//类名</span></span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class[] parameterTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                s.append(parameterTypes[i].getSimpleName());</span><br><span class="line">                <span class="keyword">if</span> (i != parameterTypes.length - <span class="number">1</span> ) s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射机制创建对象两步骤"><a href="#反射机制创建对象两步骤" class="headerlink" title="反射机制创建对象两步骤"></a>反射机制创建对象两步骤</h3><ol>
<li>先获取到这个有参数的构造方法【用ClassgetDeclaredConstructor()方法获取】</li>
<li>调用构造方法new对象【用Constructor类的newInstance()方法new对象】</li>
</ol>
<h4 id="eg-通过反射机制调用构造方法实例化java对象"><a href="#eg-通过反射机制调用构造方法实例化java对象" class="headerlink" title="eg.通过反射机制调用构造方法实例化java对象"></a>eg.通过反射机制调用构造方法实例化java对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比上一个例子(ReflectTest11)重要一些！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通过反射机制调用构造方法实例化java对象。（这个不是重点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest12</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//不适用反射创建对象</span></span><br><span class="line">        <span class="type">Vip</span> <span class="variable">vip1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>();</span><br><span class="line">        <span class="type">Vip</span> <span class="variable">vip2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>(<span class="number">123</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;2001-10-19&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制创建对象（以前）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用无参数构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> vipClass.newInstance();<span class="comment">//Class类的newInstance方法</span></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制创建对象（现在）</span></span><br><span class="line">        <span class="comment">// 调用有参数的构造方法怎么办？</span></span><br><span class="line">        <span class="comment">// 第一步：先获取到这个有参数的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> vipClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class, String.class, <span class="type">boolean</span>.class);</span><br><span class="line">        <span class="comment">// 第二步：调用构造方法new对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> c1.newInstance(<span class="number">321</span>, <span class="string">&quot;lsi&quot;</span>, <span class="string">&quot;1999-10-11&quot;</span>, <span class="literal">true</span>);<span class="comment">//Constructor类的newInstance方法</span></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取无参数构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> vipClass.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj3</span> <span class="operator">=</span> c2.newInstance();</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> 如果需要调用无参构造方法，getDeclaredConstructor()方法形参为空即可【和Class类的newInstance()方法一样的效果】！</p>
<h3 id="★获取一个类的父类以及实现的接口"><a href="#★获取一个类的父类以及实现的接口" class="headerlink" title="★获取一个类的父类以及实现的接口"></a>★获取一个类的父类以及实现的接口</h3><p>两个方法【Class类中的】</p>
<ol>
<li>public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</li>
<li>public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重点：给你一个类，怎么获取这个类的父类，已经实现了哪些接口？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest13</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// String举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取String的父类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> vipClass.getSuperclass();</span><br><span class="line">        <span class="comment">// 获取String类实现的所有接口（一个类可以实现多个接口。）</span></span><br><span class="line">        Class[] interfaces = vipClass.getInterfaces();</span><br><span class="line">        System.out.println(superclass.getName());</span><br><span class="line">        <span class="keyword">for</span> (Class i : interfaces) &#123;</span><br><span class="line">            System.out.println(i.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>属性最重要的是<strong>名字</strong></li>
<li>实例方法最重要的是<strong>名字</strong>和<strong>形参列表</strong></li>
<li>构造方法最重要的是<strong>形参列表</strong></li>
</ol>
<hr>
<h2 id="Java网络通信"><a href="#Java网络通信" class="headerlink" title="Java网络通信"></a>Java网络通信</h2><p>由于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&spm=1001.2101.3001.7020">数据链路层</a>编程和通信与设备紧密关联，网络层编程和操作系统紧密关联。Java网络编程从传输层开始，并根据编程使用协议的层次分为高层次网络编程（基于应用层）和低层次网络编程（基于传输层）。<br>基于URL使用高层次<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">网络编程</a>，基于传输层使用低层次网络编程。</p>
<h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>物理层（Physical Layer）：局部局域网上传送数据框（frame），它负责管理电脑通信设备和网络媒体之间的互通，通过物理电气接口实现互联设备间的比特形式的信息传输<br>数据链路层（Data Link Layer）：负责网络寻址、错误侦测和改错，是网络相邻节点设备间二进制信息传输的数据通道，负责数据通道的建立和拆除。<br>网络层（Network Layer）：决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组，解决跨越多个链路的甚至不同网络设备之间的通信问题，是一种端到端的通信<br>传输层（Transport Layer）：把传输表头（TH）加至数据以形成数据包，解决处于不同网络设备间的通信传输、通信管理，对上层需要通信的数据信息分解为标准的数据单元，这些数据单元到达终端后能对这些数据单元进行重新排序和整合。<br>会话层（Session Layer）：负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接，为用户交互信息而按特点规律建立的连接，提供会话地址和会话管理服务<br>表示层（Presentation Layer）：将会话层得到的数据转化为应用层可以理解的表达形式，或则将数应用层数据转化为会话层可以传输的形式<br>应用层（Application Layer）：提供为应用软件而设的界面，以设置与另一应用软件之间的通信</p>
<h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><p>TCP与UDP都是传输层的协议</p>
<p>TCP (Transmission Control Protocol)——传输控制协议</p>
<p>UDP (User Data Protocol)——用户数据报协议</p>
<p>TCP UDP<br>传输数据可靠性 TCP是一个可靠的协议，它能确保接收方完全正确地获取发送方所发送的全部数据。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方，也不能保证接收方一定能收到。<br>通讯方式 进行数据传输之前必然要建立连接，发送方与接收方在该连接之上传递数据。 发送方和接收方未建立连接，每个数据报中都给出了完整的地址信息。<br>传输数据量 一旦连接建立起来，双方的socket就可以按统一的格式传输大量的数据。 传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。<br>特点 TCP传输量大，可靠性强。 UDP操作简单，传输效率高。<br>Java支持 ServerSocket、Socket DatagramSocket、DatagramPacket</p>
<h3 id="为什么称TCP为面向连接的可靠协议"><a href="#为什么称TCP为面向连接的可靠协议" class="headerlink" title="为什么称TCP为面向连接的可靠协议"></a>为什么称TCP为面向连接的可靠协议</h3><p>TCP协议的连接过程为：设主机A与主机B建立连接，主机A先发送一个特殊的“连接请求消息段”给B，B接收到消息后就分配相应的资源（接收缓存和发送缓存）给这个TCP连接，然后给A发送一个“允许连接消息段”，A收到这个消息段后也分配相应资源，然后给B发送“确认消息段”，这是就建立起了TCP连接，可以相互传输数据。A与B之间的连接要连续交换3次消息（三次握手法），保证了连接传输的可靠性。<br>UDP完全依赖IP协议，是无连接的协议，每个数据报都是独立的信息，可能以任何可能的路径传向目的地，传输的可靠性不能被保证。</p>
<h3 id="基于TCP-Socket-的多客户-x2F-服务器通信"><a href="#基于TCP-Socket-的多客户-x2F-服务器通信" class="headerlink" title="基于TCP Socket 的多客户&#x2F;服务器通信"></a>基于TCP Socket 的多客户&#x2F;服务器通信</h3><p>Socket编程时，目的地址和端口号需要在创建Socket对象时指出<br>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//向本机的4700端口发出客户请求</span></span><br><span class="line">            Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">4700</span>);</span><br><span class="line">            <span class="comment">//由系统标准输入设备构造BufferedReader对象</span></span><br><span class="line">            BufferedReader sin=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="comment">//由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line">            PrintWriter os=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line">            BufferedReader is=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            String readline;</span><br><span class="line">            readline=sin.readLine(); <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            <span class="keyword">while</span>(!readline.equals(<span class="string">&quot;bye&quot;</span>))&#123;<span class="comment">//若从标准输入读入的字符串为 &quot;bye&quot;则停止循环</span></span><br><span class="line">                <span class="comment">//将从系统标准输入读入的字符串输出到Server</span></span><br><span class="line">                os.println(readline);</span><br><span class="line">                os.flush();<span class="comment">//刷新输出流，使Server马上收到该字符串</span></span><br><span class="line">                <span class="comment">//在系统标准输出上打印读入的字符串</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:&quot;</span>+readline);</span><br><span class="line">                <span class="comment">//从Server读入一字符串，并打印到标准输出上</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:&quot;</span>+is.readLine());</span><br><span class="line">                readline=sin.readLine(); <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            &#125; <span class="comment">//继续循环</span></span><br><span class="line">            os.close(); <span class="comment">//关闭Socket输出流</span></span><br><span class="line">            is.close(); <span class="comment">//关闭Socket输入流</span></span><br><span class="line">            socket.close(); <span class="comment">//关闭Socket</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error&quot;</span>+e); <span class="comment">//出错，则打印出错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiTalkServer</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> clientnum=<span class="number">0</span>; <span class="comment">//静态成员变量，记录当前客户的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocket serverSocket=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> listening=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建一个ServerSocket在端口4700监听客户请求</span></span><br><span class="line">            serverSocket=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">4700</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not listen on port:4700.&quot;</span>);</span><br><span class="line">            <span class="comment">//出错，打印出错信息</span></span><br><span class="line">            System.exit(-<span class="number">1</span>); <span class="comment">//退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(listening)&#123; <span class="comment">//循环监听</span></span><br><span class="line">            <span class="comment">//监听到客户请求，根据得到的Socket对象和客户计数创建服务线程，并启动之</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerThread</span>(serverSocket.accept(),clientnum).start();</span><br><span class="line">            clientnum++; <span class="comment">//增加客户计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close(); <span class="comment">//关闭ServerSocket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Socket socket=<span class="literal">null</span>; <span class="comment">//保存与本线程相关的Socket对象</span></span><br><span class="line">    <span class="type">int</span> clientnum; <span class="comment">//保存本进程的客户计数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket socket,<span class="type">int</span> num)</span> &#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.socket=socket; <span class="comment">//初始化socket变量</span></span><br><span class="line">        clientnum=num+<span class="number">1</span>; <span class="comment">//初始化clientnum变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//线程主体</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">//由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line">            BufferedReader is=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            <span class="comment">//由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line">            PrintWriter os=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//由系统标准输入设备构造BufferedReader对象</span></span><br><span class="line">            BufferedReader sin=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="comment">//在标准输出上打印从客户端读入的字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Client:&quot;</span>+ clientnum +is.readLine());</span><br><span class="line">            <span class="comment">//从标准输入读入一字符串</span></span><br><span class="line">            line=sin.readLine();</span><br><span class="line">            <span class="keyword">while</span>(!line.equals(<span class="string">&quot;bye&quot;</span>))&#123;<span class="comment">//如果该字符串为 &quot;bye&quot;，则停止循环</span></span><br><span class="line">                os.println(line);<span class="comment">//向客户端输出该字符串</span></span><br><span class="line">                os.flush();<span class="comment">//刷新输出流，使Client马上收到该字符串</span></span><br><span class="line">                <span class="comment">//在系统标准输出上打印该字符串</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:&quot;</span>+line);</span><br><span class="line">                <span class="comment">//从Client读入一字符串，并打印到标准输出上</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:&quot;</span>+ clientnum +is.readLine());</span><br><span class="line">                line=sin.readLine();<span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            &#125;<span class="comment">//继续循环</span></span><br><span class="line">            os.close(); <span class="comment">//关闭Socket输出流</span></span><br><span class="line">            is.close(); <span class="comment">//关闭Socket输入流</span></span><br><span class="line">            socket.close(); <span class="comment">//关闭Socket</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error:&quot;</span>+e);<span class="comment">//出错，打印出错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于UDP-数据报的多客户-x2F-服务器通信"><a href="#基于UDP-数据报的多客户-x2F-服务器通信" class="headerlink" title="基于UDP 数据报的多客户&#x2F;服务器通信"></a>基于UDP 数据报的多客户&#x2F;服务器通信</h3><p>使用数据报时目的地址和端口需要在创建DatagramPacket对象时，在构造方法中指出<br>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuoteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果启动时没有给出Server的名字，那么输出错误信息并退出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Usage:java QuoteClient &lt;hostname&gt;&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">// 建立数据报套接字</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">256</span>]; <span class="comment">// 建立缓冲区</span></span><br><span class="line">        <span class="comment">// 由命令行给出的第一个参数默认为Server的域名，通过它得到Server的IP信息</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 创建DatagramPacket对象</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address, <span class="number">4445</span>);</span><br><span class="line">        socket.send(packet); <span class="comment">// 发送</span></span><br><span class="line">        <span class="comment">// 创建新的DatagramPacket对象，用来接收数据报</span></span><br><span class="line">        packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        socket.receive(packet); <span class="comment">// 接收</span></span><br><span class="line">        <span class="comment">// 根据接收的字节数组生成相应的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">received</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData());</span><br><span class="line">        <span class="comment">// 输出生成的字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Quote of the Moment:&quot;</span> + received);</span><br><span class="line">        socket.close(); <span class="comment">// 关闭数据套接字</span></span><br><span class="line">        DatagramSocket socket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//创建数据报套接字</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">sin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String readLine;</span><br><span class="line">        InetAddress address=InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//Server的IP信息</span></span><br><span class="line">        <span class="keyword">while</span>(!(readLine = sin.readLine()).equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = readLine.getBytes();</span><br><span class="line">            <span class="comment">//创建DatagramPacket对象</span></span><br><span class="line">            DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address, <span class="number">4445</span>);</span><br><span class="line">            socket.send(packet); <span class="comment">//发送</span></span><br><span class="line">            buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">256</span>];</span><br><span class="line">            <span class="comment">//创建新的DatagramPacket对象，用来接收数据报</span></span><br><span class="line">            packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line">            socket.receive(packet); <span class="comment">//接收</span></span><br><span class="line">            buf = packet.getData();</span><br><span class="line">            <span class="comment">//根据接收到的字节数组生成相应的字符串</span></span><br><span class="line">            String received=<span class="keyword">new</span> <span class="title class_">String</span>(buf);</span><br><span class="line">            <span class="comment">//打印生成的字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Quote of the Sever: &quot;</span>+received );</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close(); <span class="comment">//关闭套接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class QuoteServer &#123;</span><br><span class="line">    public static void main(String args[])throws java.io.IOException&#123;</span><br><span class="line">        new QuoteServerThread().start();// 启动一个QuoteServerThread线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuoteServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span><span class="comment">// 服务器线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// DatagramSocket</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// Reader</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">moreQuotes</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">// 标志变量。是否继续操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuoteServerThread</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;QuoteServerThread&quot;</span>);<span class="comment">// QuoteServerThread</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuoteServerThread</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">//</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">4445</span>);<span class="comment">// 创建数据报套接字端口4445</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="comment">// 线程主体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (moreQuotes) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">256</span>]; <span class="comment">// 创建缓冲区</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">                <span class="comment">// 由缓冲区构建DatagramPacket对象</span></span><br><span class="line">                socket.receive(packet); <span class="comment">// 接收数据报</span></span><br><span class="line">                <span class="comment">// 输出客户端发送的内容</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()));</span><br><span class="line">                <span class="comment">// 从屏幕获取输入内容，作为发送给客户端的内容</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">dString</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">                <span class="comment">// 如果是bey，则向客户端发完消息后退出</span></span><br><span class="line">                <span class="keyword">if</span> (dString.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                    moreQuotes = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf = dString.getBytes();<span class="comment">// 把String转换成字节数组，以便传送</span></span><br><span class="line">                <span class="comment">// 从Client端传来的Packet中得到Client地址</span></span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> packet.getAddress();</span><br><span class="line">                <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> packet.getPort(); <span class="comment">// 端口号</span></span><br><span class="line">                <span class="comment">// 根据客户端信息构建DatagramPacket</span></span><br><span class="line">                packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address, port);</span><br><span class="line">                socket.send(packet); <span class="comment">// 发送数据报</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 异常处理</span></span><br><span class="line">                e.printStackTrace(); <span class="comment">// 输出异常栈信息</span></span><br><span class="line">                moreQuotes = <span class="literal">false</span>; <span class="comment">// 标志变量置false，以结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close(); <span class="comment">// 关闭数据报套接字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用URLConnetction对象编程"><a href="#利用URLConnetction对象编程" class="headerlink" title="利用URLConnetction对象编程"></a>利用URLConnetction对象编程</h3><p>利用URLConnetction对象编程返回网站首页，并将首页内容存放到文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        URL url=  <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.luogu.com.cn/&quot;</span>);</span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">con</span> <span class="operator">=</span> url.openConnection(); <span class="comment">//构建字符流</span></span><br><span class="line">        BufferedReader is=  <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(con.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>)); </span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/luogu.html&quot;</span>); <span class="comment">// 指定路径的文件，会自动新建</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = is.readLine()) != <span class="literal">null</span> ) &#123;</span><br><span class="line">            line = line + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            fos.write(line.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/0p/wallhaven-0pj8op.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/54e1373e.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/rd/wallhaven-rdwjj7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mysql</div></div></a></div><div class="next-post pull-right"><a href="/4a17b156.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/l3/wallhaven-l3xk6q.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/99720b1c.html" title="JavaWeb"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/liuloin/lanling_img@main/img/chahua202207152142576.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-30</div><div class="title">JavaWeb</div></div></a></div><div><a href="/65b69107.html" title="Nginx"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/39/wallhaven-395kpd.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-15</div><div class="title">Nginx</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">PSPLUSE</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mydishj" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_47485366?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的世界 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRoZxtxUZA87Z-Xs8oUP1KTlLwaTlDulVpwTIfiXE75CeTdt0Kv_p8E_aB84M57ndM_86E&usqp=CAU"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E7%A7%91"><span class="toc-number">1.</span> <span class="toc-text">预科</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">什么是计算机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8F%8A%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">硬件及冯诺依曼结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">冯诺依曼结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">软件及软件开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">计算机软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.2.5.</span> <span class="toc-text">Windows常用快捷键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84Dos%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">基本的Dos命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.2.7.</span> <span class="toc-text">计算机语言发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.8.</span> <span class="toc-text">高级语言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%85%A5%E9%97%A8"><span class="toc-number">2.</span> <span class="toc-text">Java入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Java帝国的诞生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">2.1.1.</span> <span class="toc-text">Java特性与优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC"><span class="toc-number">2.1.2.</span> <span class="toc-text">Java三大版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-JRE-JVM"><span class="toc-number">2.1.3.</span> <span class="toc-text">JDK JRE JVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">2.1.4.</span> <span class="toc-text">安装开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDJDk"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">卸载JDk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85JDK"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">安装JDK</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">3.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">标识符和关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.2.1.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text">标识符注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">扩展及面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.4.</span> <span class="toc-text">变量、常量、作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">3.4.3.</span> <span class="toc-text">变量的命名规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.1.</span> <span class="toc-text">自增自减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.2.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">3.5.3.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.4.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.5.</span> <span class="toc-text">包机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaDoc%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3"><span class="toc-number">3.6.</span> <span class="toc-text">JavaDoc生成文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">Java流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92Scanner"><span class="toc-number">4.1.</span> <span class="toc-text">用户交互Scanner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#next"><span class="toc-number">4.1.1.</span> <span class="toc-text">next()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextLine"><span class="toc-number">4.1.2.</span> <span class="toc-text">nextLine()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">顺序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">switch多选择结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">循环结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.4.</span> <span class="toc-text">增强for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break-amp-continue"><span class="toc-number">4.5.</span> <span class="toc-text">break &amp; continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%83%E4%B9%A0"><span class="toc-number">4.6.</span> <span class="toc-text">流程控制练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">Java方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">方法的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92-amp-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">5.3.</span> <span class="toc-text">值传递 &amp;引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">5.4.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="toc-number">5.5.</span> <span class="toc-text">命令行传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.6.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">5.7.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">Java数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">数组的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%88%9B%E5%BB%BA"><span class="toc-number">6.2.</span> <span class="toc-text">数组的声明创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">数组的三种初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="toc-number">6.5.</span> <span class="toc-text">数组的基本特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C"><span class="toc-number">6.6.</span> <span class="toc-text">数组边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.7.</span> <span class="toc-text">数组的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.8.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">6.9.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">6.10.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">6.11.</span> <span class="toc-text">稀疏数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">初识面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-amp-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.1.</span> <span class="toc-text">面向过程&amp;面向对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.2.</span> <span class="toc-text">什么是面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.3.</span> <span class="toc-text">类与对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.4.</span> <span class="toc-text">创建与初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">7.5.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-1"><span class="toc-number">7.6.</span> <span class="toc-text">内存分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">8.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super-amp-this"><span class="toc-number">8.1.</span> <span class="toc-text">super &amp; this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">8.2.</span> <span class="toc-text">方法的重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.1.</span> <span class="toc-text">instanceof和类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="toc-number">9.2.</span> <span class="toc-text">接口(interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">10.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%86%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">简单分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">10.2.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">集合介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88"><span class="toc-number">11.2.</span> <span class="toc-text">Collection体系集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E7%88%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.</span> <span class="toc-text">Collection父接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.4.</span> <span class="toc-text">Collection子接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">11.4.1.</span> <span class="toc-text">List集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.5.</span> <span class="toc-text">List实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E9%87%8D%E7%82%B9"><span class="toc-number">11.5.1.</span> <span class="toc-text">ArrayList[重点]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">11.6.</span> <span class="toc-text">ArrayList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">11.7.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">11.8.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">11.9.</span> <span class="toc-text">LinkedList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">11.10.</span> <span class="toc-text">ArrayList和LinkedList区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">12.</span> <span class="toc-text">泛型概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88"><span class="toc-number">12.4.</span> <span class="toc-text">泛型集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">13.</span> <span class="toc-text">Set集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.1.</span> <span class="toc-text">Set子接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">Set实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">14.1.</span> <span class="toc-text">HashSet【重点】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">14.2.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">15.</span> <span class="toc-text">Map集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88"><span class="toc-number">15.1.</span> <span class="toc-text">Map体系集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">Map集合的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">15.3.</span> <span class="toc-text">HashMap【重点】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">16.</span> <span class="toc-text">HashMap源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">17.</span> <span class="toc-text">HashSet源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-number">17.1.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-number">17.2.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">17.3.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E6%BA%90%E7%A0%81"><span class="toc-number">18.</span> <span class="toc-text">TreeSet源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">19.</span> <span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E7%AE%80%E4%BB%8B"><span class="toc-number">20.</span> <span class="toc-text">IO简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81Stream"><span class="toc-number">20.1.</span> <span class="toc-text">流Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">20.2.</span> <span class="toc-text">IO流的继承结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E6%96%87%E4%BB%B6%E7%B1%BB"><span class="toc-number">20.3.</span> <span class="toc-text">File文件类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">20.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.3.2.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">20.3.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">20.3.4.</span> <span class="toc-text">练习：测试常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96"><span class="toc-number">20.4.</span> <span class="toc-text">字节流读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">20.4.1.</span> <span class="toc-text">InputStream抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream%E5%AD%90%E7%B1%BB"><span class="toc-number">20.4.2.</span> <span class="toc-text">FileInputStream子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedInputStream%E5%AD%90%E7%B1%BB"><span class="toc-number">20.4.3.</span> <span class="toc-text">BufferedInputStream子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96%E6%A1%88%E4%BE%8B"><span class="toc-number">20.4.4.</span> <span class="toc-text">字节流读取案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%8F%96"><span class="toc-number">20.5.</span> <span class="toc-text">字符流读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reader%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">20.5.1.</span> <span class="toc-text">Reader抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader%E5%AD%90%E7%B1%BB"><span class="toc-number">20.5.2.</span> <span class="toc-text">FileReader子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedReader%E5%AD%90%E7%B1%BB"><span class="toc-number">20.5.3.</span> <span class="toc-text">BufferedReader子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%8F%96%E6%A1%88%E4%BE%8B"><span class="toc-number">20.5.4.</span> <span class="toc-text">练习：字符流读取案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E5%87%BA"><span class="toc-number">20.6.</span> <span class="toc-text">字节流写出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStream%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">20.6.1.</span> <span class="toc-text">OutputStream抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream-%E5%AD%90%E7%B1%BB"><span class="toc-number">20.6.2.</span> <span class="toc-text">FileOutputStream 子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedOutputstream-%E5%AD%90%E7%B1%BB"><span class="toc-number">20.6.3.</span> <span class="toc-text">BufferedOutputstream 子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E6%B5%8B%E8%AF%95"><span class="toc-number">20.6.4.</span> <span class="toc-text">练习: 字节输出流测试:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E5%87%BA"><span class="toc-number">20.7.</span> <span class="toc-text">字符流写出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Writer-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">20.7.1.</span> <span class="toc-text">Writer 抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter-%E5%AD%90%E7%B1%BB"><span class="toc-number">20.7.2.</span> <span class="toc-text">FileWriter 子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedWriter%E5%AD%90%E7%B1%BB"><span class="toc-number">20.7.3.</span> <span class="toc-text">BufferedWriter子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%E6%B5%8B%E8%AF%95"><span class="toc-number">20.7.4.</span> <span class="toc-text">练习: 字符输出流测试:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">20.8.</span> <span class="toc-text">拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-IO%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">20.9.</span> <span class="toc-text">总结:IO的继承结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">20.9.1.</span> <span class="toc-text">字节输入流:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">20.9.2.</span> <span class="toc-text">字符输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">20.9.3.</span> <span class="toc-text">字节输出流:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">20.9.4.</span> <span class="toc-text">字符输出流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B"><span class="toc-number">21.</span> <span class="toc-text">反射简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">21.1.</span> <span class="toc-text">反射机制有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%8C%85%E4%B8%8B%EF%BC%9F"><span class="toc-number">21.2.</span> <span class="toc-text">反射机制的相关类在哪个包下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%8D%E8%A6%81%E7%9A%84%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">21.3.</span> <span class="toc-text">反射机制相关的重要的类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E7%9A%84%E4%B8%89%E6%96%B9%E5%BC%8F"><span class="toc-number">21.4.</span> <span class="toc-text">获取Class的三方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.5.</span> <span class="toc-text">通过反射实例化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC%E9%87%8D%E7%82%B9-Class-forName%E5%AF%BC%E8%87%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">21.6.</span> <span class="toc-text">JDBC重点(Class.forName导致类加载)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84Filed%E3%80%90%E5%8F%8D%E5%B0%84-x2F-%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E3%80%91"><span class="toc-number">21.7.</span> <span class="toc-text">反射Filed【反射&#x2F;反编译一个类的属性】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">21.7.1.</span> <span class="toc-text">Class类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Field%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">21.7.2.</span> <span class="toc-text">Field类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7Field"><span class="toc-number">21.7.3.</span> <span class="toc-text">eg.反编译一个类的属性Field</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">21.8.</span> <span class="toc-text">给属性赋值三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%A4%E4%B8%AA%E8%A6%81%E7%B4%A0"><span class="toc-number">21.9.</span> <span class="toc-text">读属性值两个要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-%E2%98%85%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAjava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">21.9.1.</span> <span class="toc-text">eg.★通过反射机制访问一个java对象的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%98%9B%EF%BC%9F"><span class="toc-number">21.10.</span> <span class="toc-text">set()可以访问私有属性嘛？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fidle%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">21.10.1.</span> <span class="toc-text">Fidle方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84Method%E3%80%90%E5%8F%8D%E5%B0%84-x2F-%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%91"><span class="toc-number">21.11.</span> <span class="toc-text">反射Method【反射&#x2F;反编译一个类的方法】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">21.11.1.</span> <span class="toc-text">Method类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95Method"><span class="toc-number">21.11.2.</span> <span class="toc-text">eg.反编译一个类的方法Method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="toc-number">21.11.3.</span> <span class="toc-text">调用方法四要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-%E2%98%85%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">21.11.4.</span> <span class="toc-text">eg.★通过反射机制调用一个对象的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84Constructor%E3%80%90%E5%8F%8D%E5%B0%84-x2F-%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%91"><span class="toc-number">21.12.</span> <span class="toc-text">反射Constructor【反射&#x2F;反编译一个类的构造方法】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">21.13.</span> <span class="toc-text">Constructor类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95Constructor"><span class="toc-number">21.13.1.</span> <span class="toc-text">eg.反编译一个类的构造方法Constructor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%A4%E6%AD%A5%E9%AA%A4"><span class="toc-number">21.14.</span> <span class="toc-text">反射机制创建对象两步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96java%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.14.1.</span> <span class="toc-text">eg.通过反射机制调用构造方法实例化java对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.15.</span> <span class="toc-text">★获取一个类的父类以及实现的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">21.15.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">22.</span> <span class="toc-text">Java网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">22.1.</span> <span class="toc-text">网络通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%8EUDP"><span class="toc-number">22.2.</span> <span class="toc-text">TCP与UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%B0TCP%E4%B8%BA%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8F%AF%E9%9D%A0%E5%8D%8F%E8%AE%AE"><span class="toc-number">22.3.</span> <span class="toc-text">为什么称TCP为面向连接的可靠协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP-Socket-%E7%9A%84%E5%A4%9A%E5%AE%A2%E6%88%B7-x2F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">22.4.</span> <span class="toc-text">基于TCP Socket 的多客户&#x2F;服务器通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EUDP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%A4%9A%E5%AE%A2%E6%88%B7-x2F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">22.5.</span> <span class="toc-text">基于UDP 数据报的多客户&#x2F;服务器通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8URLConnetction%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">22.6.</span> <span class="toc-text">利用URLConnetction对象编程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/65b69107.html" title="Nginx"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/39/wallhaven-395kpd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/65b69107.html" title="Nginx">Nginx</a><time datetime="2022-07-15T13:52:51.000Z" title="发表于 2022-07-15 21:52:51">2022-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/99720b1c.html" title="JavaWeb"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/liuloin/lanling_img@main/img/chahua202207152142576.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb"/></a><div class="content"><a class="title" href="/99720b1c.html" title="JavaWeb">JavaWeb</a><time datetime="2022-06-30T12:22:47.000Z" title="发表于 2022-06-30 20:22:47">2022-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/54e1373e.html" title="Mysql"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/rd/wallhaven-rdwjj7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql"/></a><div class="content"><a class="title" href="/54e1373e.html" title="Mysql">Mysql</a><time datetime="2022-06-24T13:24:32.000Z" title="发表于 2022-06-24 21:24:32">2022-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20dbfd00.html" title="Java基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/0p/wallhaven-0pj8op.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/20dbfd00.html" title="Java基础">Java基础</a><time datetime="2022-06-24T02:13:57.000Z" title="发表于 2022-06-24 10:13:57">2022-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4a17b156.html" title="Hello World"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/l3/wallhaven-l3xk6q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/4a17b156.html" title="Hello World">Hello World</a><time datetime="2022-06-23T03:38:55.000Z" title="发表于 2022-06-23 11:38:55">2022-06-23</time></div></div></div></div></div></div><!--#aside-content.aside-content--><!--  //- post--><!--  if is_post()--><!--    - const tocStyle = page.toc_style_simple--><!--    - const tocStyleVal = tocStyle === true || tocStyle === false ? tocStyle : theme.toc.style_simple--><!--    if showToc && tocStyleVal--><!--      .sticky_layout--><!--        include ./card_post_toc.pug--><!--    else--><!--      !=partial('includes/widget/card_author', {}, {cache: true})--><!--      !=partial('includes/widget/card_announcement', {}, {cache: true})--><!--      !=partial('includes/widget/card_top_self', {}, {cache: true})--><!--      .sticky_layout--><!--        if showToc--><!--          include ./card_post_toc.pug--><!--        !=partial('includes/widget/card_recent_post', {}, {cache: true})--><!--        !=partial('includes/widget/card_ad', {}, {cache: true})--><!--  else--><!--    //- page--><!--    !=partial('includes/widget/card_author', {}, {cache: true})--><!--    !=partial('includes/widget/card_announcement', {}, {cache: true})--><!--    !=partial('includes/widget/card_top_self', {}, {cache: true})--><!----><!--    .sticky_layout--><!--      if showToc--><!--        include ./card_post_toc.pug--><!--      !=partial('includes/widget/card_recent_post', {}, {cache: true})--><!--      !=partial('includes/widget/card_ad', {}, {cache: true})--><!--      !=partial('includes/widget/card_newest_comment', {}, {cache: true})--><!--      !=partial('includes/widget/card_categories', {}, {cache: true})--><!--      !=partial('includes/widget/card_tags', {}, {cache: true})--><!--      !=partial('includes/widget/card_archives', {}, {cache: true})--><!--      !=partial('includes/widget/card_webinfo', {}, {cache: true})--><!--      !=partial('includes/widget/card_bottom_self', {}, {cache: true})--></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/nm/wallhaven-nmp8k9.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By PSPLUSE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="/js/shadow.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159611061656" m="1"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>